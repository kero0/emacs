* Setup
#+PROPERTY: header-args :tangle config.el :results output silent :noweb yes :lexical t :eval never-export
#+startup: fold
#+auto_tangle: t
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
<<variables>>
#+end_src
** Requires
#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src
** Basic variables
:PROPERTIES:
:header-args: :tangle no :noweb-ref variables
:END:
*** System type
#+begin_src emacs-lisp
(eval-and-compile
  (defconst IS-MAC      (eq system-type 'darwin))
  (defconst IS-LINUX    (memq system-type '(gnu gnu/linux gnu/kfreebsd berkeley-unix)))
  (defconst IS-WINDOWS  (memq system-type '(cygwin windows-nt ms-dos)))
  (defconst IS-BSD      (memq system-type '(darwin berkeley-unix gnu/kfreebsd)))
  ;; personal or work
  (defconst IS-PERSONAL t)
  (defconst IS-WORK     (not IS-PERSONAL))
  (defconst my/available-cores
    (string-to-number
     (shell-command-to-string (if (eq system-type 'darwin)
                                  "sysctl -n hw.ncpu"
                                "nproc --all")))))
#+end_src
*** Directories
#+begin_src emacs-lisp
(eval-and-compile
  (defvar my/local-dir (expand-file-name ".local/" user-emacs-directory)
    "Default local directory.")
  (if-let ((local-dir (getenv "XDG_DATA_HOME")))
      (setq my/local-dir (expand-file-name "emacs/" local-dir)))
  (defvar my/cache-dir (expand-file-name "cache/" my/local-dir)
    "Default cache directory.")
  (if-let ((cache-dir (getenv "XDG_CACHE_HOME")))
      (setq my/cache-dir (expand-file-name "emacs/" cache-dir)))
  (defvar my/etc-dir (expand-file-name "etc/" my/local-dir)
    "Default etc directory.")
  (defvar my/emacs-dir user-emacs-directory
    "Default emacs directory."))

(make-directory my/local-dir t)
(make-directory my/cache-dir t)
#+end_src
*** Personal info
#+begin_src emacs-lisp
(eval-and-compile
  (setq user-full-name "Kirols Bakheat"
        user-mail-address "kbakheat@gmail.com"))
#+end_src

*** Indent Tabs
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src
** Macros
*** ~after!~
#+begin_src emacs-lisp
(cl-defmacro after! (features &rest body)
  "A smart wrapper around `with-eval-after-load'"
  (if (listp features)
      (pcase (length features)
        (0 `(progn ,@body))
        (1 `(with-eval-after-load (quote ,(car features))
              (progn
                ,@body)))
        (_ (if (eq (car features) 'or)
               `(progn
                  ,@(cl-map 'list
                            (lambda (feature)
                              `(after! ,feature ,@body))
                            (cdr features)))
             `(with-eval-after-load (quote ,(car features))
                (after! ,(cdr features) ,@body)))))
    `(with-eval-after-load (quote ,features)
       (progn ,@body))))
#+end_src
*** ~append!~
#+begin_src emacs-lisp
(cl-defmacro append! (var &rest values)
  "Append VALUES to the end of VAR, if they don't already exist in VAR."
  (declare (indent defun))
  `(dolist (value (list ,@values))
     (unless (member value ,var)
       (setf ,var (append ,var (list value))))))
#+end_src
*** ~add-popup!~
#+begin_src emacs-lisp
(eval-and-compile
  (cl-defmacro add-popup! (&rest rules)
    "Add popup rules."
    `(after! popper
             (append! popper-reference-buffers ,@rules)
             (popper--set-reference-vars))))
#+end_src
** Startup
#+begin_src emacs-lisp
(defun my/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'my/display-startup-time)
#+end_src
** gcmh
#+begin_src emacs-lisp
(use-package gcmh
  :unless noninteractive
  :config
  (gcmh-mode +1))
#+end_src
** Hooks
#+begin_src emacs-lisp
(defun my/disable-line-numbers ()
  (display-line-numbers-mode -1)
  (setq-local display-line-numbers nil))
#+end_src
** no-littering
#+begin_src emacs-lisp
(use-package no-littering
  :config
  (setq no-littering-etc-directory (expand-file-name "etc/" my/local-dir)
        no-littering-var-directory (expand-file-name "var/" my/local-dir)
        custom-file (no-littering-expand-etc-file-name "custom.el"))
  (load custom-file 'noerror 'nomessage))
#+end_src
** History
*** recentf
#+begin_src emacs-lisp
(use-package recentf
  :unless noninteractive
  :ensure nil
  :config
  (dolist (dir `("/nix/store/.*"
                 "/tmp/.*"
                 "/var/tmp/.*"
                 "/var/folders/.*"
                 "/private/tmp/.*"
                 "/private/var/.*"
                 "/Applications/Xcode.app/.*"
                 "/Library/.*"
                 "~/\\.cache.*"
                 ,(concat my/etc-dir ".*")
                 ,(concat my/local-dir ".*")
                 ,(concat my/cache-dir ".*")))
    (add-to-list 'recentf-exclude dir))
  (when-let ((dir (getenv "XDG_DATA_HOME")))
    (add-to-list 'recentf-exclude (concat dir "/.*")))
  (setq recentf-max-menu-items 100
        recentf-max-saved-items 100
        recentf-save-file (expand-file-name "recentf" my/local-dir))
  (recentf-mode 1))
#+end_src
*** savehist
#+begin_src emacs-lisp
(use-package savehist
  :unless noninteractive
  :ensure nil
  :config
  (setq savehist-file (expand-file-name "savehist" my/local-dir)
        savehist-save-minibuffer-history t
        savehist-autosave-interval 60
        savehist-additional-variables '(kill-ring
                                        search-ring
                                        regexp-search-ring))
  (savehist-mode 1))
#+end_src
*** saveplace
#+begin_src emacs-lisp
(use-package saveplace
  :unless noninteractive
  :ensure nil
  :config
  (setq save-place-file (expand-file-name "saveplace" my/local-dir))
  (save-place-mode 1))
#+end_src
** Custom file
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" my/etc-dir))
#+end_src
** Backup files
#+begin_src emacs-lisp
(setopt backup-directory-alist `(("." . ,(expand-file-name "backups" my/local-dir)))
        auto-save-file-name-transforms `((".*" ,(expand-file-name "auto-save/" my/local-dir) t))
        tramp-backup-directory-alist nil
        tramp-verbose 0
        tramp-chunksize 2000
        tramp-use-ssh-controlmaster-options nil)
#+end_src
** Lockfiles
#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src
** Autosave
#+begin_src emacs-lisp
(setq auto-save-default nil)
#+end_src
** Auto-revert
#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode
  :config
  (setq auto-revert-verbose nil
        auto-revert-interval 2
        auto-revert-check-vc-info t
        auto-revert-remote-files t
        global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode +1))
#+end_src
** Yes-or-No
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Authsources
#+begin_src emacs-lisp
(setq auth-sources (list (expand-file-name "authinfo.gpg" my/local-dir)))
(use-package auth-source-pass
  :ensure nil
  :unless noninteractive
  :config
  (auth-source-pass-enable))
#+end_src
** Window management
I want windows that start with '*' to be opened in the lower 1/3 of the frame. These windows should close when their buffer dies and should not be reused. If they are not in ~my/special-window-no-cursor-manage-alist~ then they should automatically grab the cursor.
#+begin_src emacs-lisp
(defvar my/special-window-no-cursor-manage-alist '("^\\*Help\\*$" "^\\*Warnings\\*$" "^\\*Backtrace\\*$" "^\\*Messages\\*$"))
#+end_src
** Early init
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes :lexical t :eval never-export
:END:
#+begin_src emacs-lisp

<<variables>>

(setq comp-eln-cache-path (expand-file-name "eln-cache/" my/cache-dir)
      native-comp-async-report-warnings-errors 'silent
      warning-minimum-level ':error
      native-comp-verbose 0)
#+end_src
*** Disable package.el
#+begin_src emacs-lisp
(setq package-enable-at-startup nil
      package-quickstart nil)
#+end_src
*** Garbage-collection
#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum ;; reset by gcmh
      gc-cons-percentage 0.6)
#+end_src
*** UI
#+begin_src emacs-lisp
(setq inhibit-startup-message t
      frame-inhibit-implied-resize t
      inhibit-splash-screen t
      use-file-dialog nil
      use-dialog-box nil
      display-line-numbers-type 'relative
      ring-bell-function 'ignore)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
(scroll-bar-mode -1)         ; Disable visible scrollbar
(tool-bar-mode -1)           ; Disable the toolbar
(tooltip-mode -1)            ; Disable tooltips
(set-fringe-mode '(25 . 10)) ; Give some breathing room
(menu-bar-mode -1)           ; Disable the menu bar

(column-number-mode)
(global-display-line-numbers-mode t)

(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
* Keybindings
** Basics
#+begin_src emacs-lisp
(cond
 (IS-MAC
  (define-key key-translation-map [S-iso-lefttab] [backtab])
  (setq mac-command-modifier      'meta
        ns-command-modifier       'meta
        mac-option-modifier       'meta
        ns-option-modifier        'meta
        mac-right-option-modifier 'super
        ns-right-option-modifier  'super))
 (IS-WINDOWS
  (setq w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super)))
;; Make ESC quit prompts
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq use-package-always-demand t
 use-package-always-defer nil
      use-package-expand-minimally t
      use-package-verbose nil)
(eval-and-compile
  (require 'use-package))
#+end_src
** which-key
#+begin_src emacs-lisp
(use-package which-key
  :unless noninteractive
  :demand
  :diminish
  :config
  (which-key-mode)
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.01
        which-key-max-description-length 32
        which-key-sort-order 'which-key-key-order-alpha
        which-key-allow-evil-operators t
        which-key-prefix-prefix "+"))
#+end_src
** Helpers
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
Macro to define nested keymaps
#+begin_src emacs-lisp
(defmacro my/map-menu! (name prefix-key &rest body)
  "Create a definer named +general-global-NAME wrapping global-definer.
   Create prefix map: +general-global-NAME-map. Prefix bindings in BODY
   with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n (concat "my/map-" name))
         (prefix-map (intern (concat n "-map"))))
    `(eval-and-compile
       (defvar-keymap ,prefix-map
         ,@body)
       (with-eval-after-load 'which-key
         (which-key-add-keymap-based-replacements my/maps/leader
           ,prefix-key               (cons ,name ,prefix-map))
         (cl-defmacro ,(intern n) (&rest body)
           `(which-key-add-keymap-based-replacements ,',prefix-map
              ,@body))))))
(defmacro my/leader-def (&rest body)
  `(with-eval-after-load 'which-key
     (which-key-add-keymap-based-replacements my/maps/leader
       ,@body)))
  #+end_src
Local bindings
#+begin_src emacs-lisp :noweb-ref keybindings :tangle no
(defvar my/major-mode-local-leader-keymap-alist nil)

(which-key-add-keymap-based-replacements my/maps/leader
  "m" '("<localleader>" .
        (lambda ()
          (interactive)
          (if-let ((map (alist-get major-mode my/major-mode-local-leader-keymap-alist nil nil (lambda (key current-mode) (derived-mode-p key)))))
              (progn
                (which-key-show-keymap map t)
                (set-transient-map (eval map)))
            (message "No matching map found")))))

(cl-defmacro my/local-leader-def (mode &rest args)
  "Create a definer named +general-global-NAME wrapping global-definer.
   Create prefix map: +general-global-NAME-map. Prefix bindings in BODY
   with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n  (symbol-name mode))
         (definer (intern (concat "my/local-leader-def-" n)))
         (hook (intern (concat n "-hook")))
         (prefix-map (intern (concat "my/maps/" (symbol-name mode)))))
    `(eval-and-compile
       (defvar-keymap ,prefix-map
         ,@args)
       (push (cons ',mode ',prefix-map) my/major-mode-local-leader-keymap-alist)
       (cl-defmacro ,definer (&rest body)
         `(with-eval-after-load 'which-key (which-key-add-keymap-based-replacements ',,prefix-map
                                             ,@body))))))
#+end_src
Do something in other window
#+begin_src emacs-lisp
(defun my/do-in-other-window (fn &rest args)
  (let ((buf (current-buffer)))
    (other-window 1)
    (apply fn args)
    (switch-to-buffer buf)))
#+end_src
*** Assorted Keybindings
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
**** Quit
#+begin_src emacs-lisp
(my/map-menu! "Quit" "q"
  "q" '("Quit Emacs" . save-buffers-kill-terminal)
  "Q" '("Quit Emacs immediately" . kill-emacs)
  "r" '("Restart Emacs" . restart-emacs))
#+end_src
**** Buffer
#+begin_src emacs-lisp
(defvar my/kill-buffer-fun #'kill-buffer)
(defun my/kill-buffer (&optional buf)
  (interactive)
  (let ((buf (or buf (current-buffer)))
        (kill-buffer-query-functions '()))
    (funcall my/kill-buffer-fun buf)))

(defun my/kill-other-window ()
  (interactive)
  (my/do-in-other-window (lambda () (progn (my/kill-buffer) (delete-window)))))

(my/map-menu! "Buffer" "b"
  "B" '("Switch buffer other window" . switch-to-buffer-other-window)
  "d" '("Kill current buffer" . kill-current-buffer)
  "k" '("Kill buffer" . my/kill-buffer)
  "K" '("Kill buffer other window" . my/kill-other-window)
  "r" '("Revert buffer" . revert-buffer)
  "[" '("Previous buffer" . previous-buffer)
  "]" '("Next buffer" . next-buffer)
  "n" '("Next buffer" . next-buffer)
  "p" '("Previous buffer" . previous-buffer)
  "s" '("Save buffer" . save-buffer)
  "S" '("Save some buffers" . save-some-buffers)
  "u" '("Bury buffer" . bury-buffer)
  "U" '("Unbury buffer" . unbury-buffer)
  "x" '("Open scratch buffer" . scratch-buffer))
(my/leader-def
 "x" '("Open scratch buffer" . scratch-buffer))
#+end_src
**** Code
#+begin_src emacs-lisp
(my/map-menu! "Code" "c"
  "c" '("Recompile" . recompile)
  "C" '("Compile" . compile))
#+end_src
**** File
#+begin_src emacs-lisp
(defun my/find-file-other-window ()
  (interactive)
  (my/do-in-other-window #'find-file))
(defun my/find-file-sudo ()
  (interactive)
  (let ((file-name (read-file-name "Find file (as root): ")))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(defun my/this-file-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(my/map-menu! "File" "f"
  "f" '("Find file" . find-file)
  "F" '("Find file other window" . find-file-other-window)
  "s" '("Save buffer" . save-buffer)
  "S" '("Save file as" . write-file)
  "r" '("Recent files" . recentf-open-files)
  "R" '("Rename file" . rename-file)
  "d" '("Delete file" . delete-file)
  "u" '("Find file as root" . my/find-file-sudo)
  "U" '("Open this file as root" . my/this-file-sudo))
#+end_src
**** Git
#+begin_src emacs-lisp
(my/map-menu! "Git" "g")
#+end_src
**** Open
#+begin_src emacs-lisp
(defvar my/open-proc (cond (IS-MAC "open")
                           (IS-LINUX "xdg-open"))
  "The defualt process to open files with.")
(defun my/default-open (file)
  (interactive)
  (start-process my/open-proc nil my/open-proc file))

(my/map-menu! "Open" "o"
  "o" '("Open file" . (lambda () (interactive) (my/default-open (buffer-file-name))) )
  "s" '("Shell" . shell))
#+end_src
**** REPL
#+begin_src emacs-lisp
(defvar my/repl-alist '((emacs-lisp-mode . ielm)
                        (fallback . my/repl-fallback))
  "Alist of modes to repls.")
(defvar my/repl-fallback #'shell "The fallback repl to use.")
(defun my/repl--open-or-create ()
  (let* ((mode (buffer-local-value 'major-mode (current-buffer)))
         (repl (alist-get mode my/repl-alist my/repl-fallback))
         (repl-buffer-name (concat "*"
                                   (symbol-name (if (eq repl my/repl-fallback) mode repl))
                                   ":repl*")))
    (if (get-buffer repl-buffer-name)
        (popper-display-popup-at-bottom (get-buffer repl-buffer-name))
      (progn
        (add-popup! repl-buffer-name)
        (funcall repl)
        (rename-buffer repl-buffer-name)))))
(defun my/repl--choose (arg)
  (interactive (list (completing-read "Choose repl: " (mapcar #'symbol-name (mapcar #'car my/repl-alist)) nil t)))
  (let* ((repl (if (string= arg "fallback")
                   my/repl-fallback
                 (alist-get (intern arg) my/repl-alist my/repl-fallback)))
         (repl-buffer-name (concat "*"
                                   (symbol-name repl)
                                   ":repl*")))
    (if-let ((buffer (get-buffer repl-buffer-name)))
        (funcall popper-display-function buffer)
      (progn
        (funcall repl)
        (rename-buffer repl-buffer-name)
        (popper-lower-to-popup (get-buffer repl-buffer-name))))))

(defun my/repl (arg)
  (interactive "P")
  (if arg
      (call-interactively #'my/repl--choose)
    (my/repl--open-or-create)))
(my/map-Open "r" '("REPL" . my/repl))
#+end_src
**** Toggle
#+begin_src emacs-lisp
(defun my/toggle-comment (beg end)
  "Comment or uncomment current region or line."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list (line-beginning-position) (line-end-position))))
  (comment-or-uncomment-region beg end))
(my/map-menu! "Toggle" "t"
  "d" '("debug" . toggle-debug-on-error)
  "/" '("comment" . comment-or-uncomment-region))
#+end_src
**** Search
#+begin_src emacs-lisp
(my/map-menu! "Search" "s")
#+end_src
** Keybinding setup
#+begin_src emacs-lisp :noweb yes
(eval-and-compile
  (defvar my/leader-def-prefix (kbd "SPC")
    "Prefix for general.el leader keybindings.")
  (defvar my/leader-def-prefix-alt (kbd "M-SPC")
    "Alternative prefix for general.el leader keybindings.")
  (defvar my/local-leader-def-prefix "m"
    "Prefix for general.el local leader keybindings.
   Relative to `my/leader-def-prefix'.")
  (defvar my/prefix-states '(normal visual motion)
    "States in which to bind general.el leader keybindings."))


(eval-and-compile
  (defvar-keymap my/maps/leader
    "SPC"             '("Find file" . project-find-file)
    "H"               '("Help at point" . helpful-at-point)
    ";"               '("M-x" . execute-extended-command)
    ":"               '("Eval" . eval-expression)
    "."               '("Repeat" . repeat)
    "r"               '("Run command" . async-shell-command)
    "R"               '("Run command synchronously" . shell-command))
  (require 'which-key)
  (require 'bind-key)
  (which-key-add-keymap-based-replacements my/maps/leader
    "h"               `("Help" . ,help-map))
  <<keybindings>>
  (provide 'my/map-loaded))
#+end_src
** evil
#+begin_src emacs-lisp
(use-package evil
  :unless noninteractive
  :preface (setq evil-want-integration t)
  :init
  (setq evil-want-keybinding nil
        evil-want-C-u-scroll t
        evil-want-C-i-jump t
        evil-want-Y-yank-to-eol t
        evil-want-fine-undo t
        select-enable-clipboard nil)
  :config
  (evil-mode)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
  (evil-define-key '(normal visual) 'global my/leader-def-prefix my/maps/leader)
  (bind-key my/leader-def-prefix-alt my/maps/leader)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)

  (after! my/map-loaded
          (my/leader-def
           "w" '("Window" . evil-window-map))
          (my/leader-def
           "u" '("Universal argument" . universal-argument))))

(use-package evil-collection
  :after evil
  :unless noninteractive
  :custom
  (evil-collection-setup-minibuffer t)
  (evil-collection-key-blacklist '("SPC"))
  :config
  (unless noninteractive
    (evil-collection-init))
  (evil-define-key 'normal minibuffer-local-map
    [escape] 'abort-recursive-edit))
#+end_src
*** evil-lion
#+begin_src emacs-lisp
(use-package evil-lion
  :after evil
  :unless noninteractive
  :config
  (evil-lion-mode))
#+end_src
*** evil-surround
#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :unless noninteractive
  :config
  (global-evil-surround-mode 1)
  (use-package expand-region)
  (use-package evil-embrace
    :config (evil-embrace-enable-evil-surround-integration)))
#+end_src
*** evil-commentary
#+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :unless noninteractive
  :config
  (evil-commentary-mode))
#+end_src
*** evil-nerd-commenter
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :unless noninteractive
  :config
  (evilnc-default-hotkeys))
#+end_src
*** evil-goggles
#+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :unless noninteractive
  :init
  (setq evil-goggles-duration 0.05)
  :config
  (push '(evil-operator-eval
          :face evil-goggles-yank-face
          :switch evil-goggles-enable-yank
          :advice evil-goggles--generic-async-advice)
        evil-goggles--commands)
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces))
#+end_src
*** evil-snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :unless noninteractive
  :custom
  (evil-snipe-use-vim-sneak-bindings t)
  (evil-snipe-smart-case t)
  :config
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))
#+end_src
*** evil-exchange
#+begin_src emacs-lisp
(use-package evil-exchange
  :after evil
  :unless noninteractive
  :config
  (evil-exchange-cx-install))
#+end_src
*** evil-mc
#+begin_src emacs-lisp
(use-package evil-mc
  :after evil
  :unless noninteractive
  :hook (after-init . global-evil-mc-mode)
  :init
  (use-package evil-multiedit
    :custom
    (evil-multiedit-dwim-motion-keys t)
    (evil-multiedit-ignore-indent-and-trailing t)
    (evil-multiedit-scope 'buffer)
    (evil-multiedit-store-in-search-history t))
  :config
  (evil-define-key 'normal 'global
    "gm"  `("Multi-cursor" . ,evil-mc-cursors-map))
  (bind-keys
   ("M-d" . evil-mc-make-and-goto-next-match)
   ("M-S-d" . evil-mc-make-and-goto-prev-match))
  (evil-define-key 'visual 'global
    "A" 'evil-mc-make-cursor-in-visual-selection-end
    "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  (my/map-menu! "Multi-Cursor" "c m"
    "a" '("Make all cursors" . evil-mc-make-all-cursors)
    "n" '("Make and go to next match" . evil-mc-make-and-goto-next-match)
    "N" '("Make and go to previous match" . evil-mc-make-and-goto-prev-match)
    "q" '("Undo all cursors" . evil-mc-undo-all-cursors))
  (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)
  (global-evil-mc-mode 1))
#+end_src
*** Extra Text Objects
#+begin_src emacs-lisp
(use-package evil-textobj-anyblock
  :unless noninteractive
  :after evil
  :config
  (setq evil-textobj-anyblock-blocks
        '(("(" . ")")
          ("{" . "}")
          ("\\[" . "\\]")
          ("<" . ">")))
  (define-key evil-inner-text-objects-map "b" 'evil-textobj-anyblock-inner-block)
  (define-key evil-outer-text-objects-map "b" 'evil-textobj-anyblock-a-block)

  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote))
#+end_src
* Popper
#+begin_src emacs-lisp
(use-package popper
  :unless noninteractive
  :demand t
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "\\*helpful .*\\*"
          "\\*.*:repl\\*"
          "\\*scratch\\*"
          special-mode
          help-mode
          compilation-mode))

  (if (featurep 'perspective)
      (setq popper-group-function #'popper-group-by-perspective)
    (setq popper-group-function #'popper-group-by-directory))
  (setq popper-display-control t)

  (setq popper-display-function #'popper-display-popup-at-bottom)
  (setq popper-window-height 0.4)
  :config
  (my/map-menu! "Popper" "`"
    "`" '("Toggle latest" . popper-toggle)
    "c" '("Cycle" . popper-cycle)
    "T" '("Toggle type" . popper-toggle-type))
  (bind-key "C-`"   #'popper-toggle)
  (bind-key "M-`"   #'popper-cycle)
  (bind-key "C-M-`" #'popper-toggle-type)
  (defun my/popper-display-function (buffer &optional alist)
    "my display function for popper"
    (if (-any (lambda (regex) (string-match regex (buffer-name buffer))) my/special-window-no-cursor-manage-alist)
        (popper-display-popup-at-bottom buffer alist)
      (popper-select-popup-at-bottom buffer alist)))
  (setopt popper-display-function #'my/popper-display-function)
  (popper-mode +1))
#+end_src
* UI
** Fancy Compile
#+begin_src emacs-lisp
(use-package ansi-color
  :unless noninteractive
  :ensure nil
  :hook  (compilation-filter . ansi-color-compilation-filter))
#+end_src
** Fonts
#+begin_src emacs-lisp
(defconst my/font/name "JetBrainsMono Nerd Font Mono") ;; ligatures assumes this font
(defvar my/font/size 180)

(set-face-attribute 'default nil :font my/font/name :height my/font/size)
(set-face-attribute 'fixed-pitch nil :font my/font/name :height my/font/size)
(set-face-attribute 'variable-pitch nil :font my/font/name :height my/font/size :weight 'regular)

(set-fontset-font "fontset-default" nil (font-spec :name my/font/name))
(set-fontset-font "fontset-default" 'ethiopic (font-spec :name "Noto Sans Ethiopic"))
(set-fontset-font "fontset-default" 'coptic (font-spec :name "Noto Sans Coptic"))
(set-fontset-font "fontset-default" 'egyptian (font-spec :name "Noto Sans Egyptian Hieroglyphs"))

(my/leader-def "U" '("Insert Unicode char (by name)" . insert-char))
(my/map-menu! "Input-Language" "I"
  "C"   '("Coptic" . (lambda () (interactive) (set-input-method "coptic")))
  "d"   '("Default" . (lambda () (interactive) (set-input-method nil)))
  "ESC" '("Default" . (lambda () (interactive) (set-input-method nil))))
(keymap-set global-map "C-c l" (cons "Input-Language" my/map-Input-Language-map))

(when (daemonp)
  (add-to-list 'default-frame-alist `(font . ,my/font/name)))

(use-package ligature
  :hook ((prog-mode text-mode) . ligature-mode)
  :config
  ;; Enable all JetBrains Mono ligatures in programming modes
  (ligature-set-ligatures '(prog-mode text-mode) '("-|" "--" "-~" "---" "-<" "--" "->" "->>" "-->" "///" "/=" "/=="
                                                   "/>" "//" "/*" "*>" "***" "*/" "<-" "<<-" "<=>" "<=" "<|" "<||"
                                                   "<|||" "<|>" "<:" "<>" "<-<" "<<<" "<==" "<<=" "<=<" "<==>" "<-|"
                                                   "<<" "<~>" "<=|" "<~~" "<~" "<$>" "<$" "<+>" "<+" "</>" "</" "<*"
                                                   "<*>" "<->" "<!--" ":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=" "=>>"
                                                   "==>" "=/=" "=!=" "=>" "===" "=:=" "==" "!==" "!!" "!=" ">]" ">:"
                                                   ">>-" ">>=" ">=>" ">>>" ">-" ">=" "&&&" "&&" "|||>" "||>" "|>" "|]"
                                                   "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||" ".." ".?" ".=" ".-" "..<"
                                                   "..." "+++" "+>" "++" "[||]" "[<" "[|" "{|" "??" "?." "?=" "?:" "##"
                                                   "###" "####" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" ";;" "_|_"
                                                   "__" "~~" "~~>" "~>" "~-" "~@" "$>" "^=" "]#"))
  (global-ligature-mode t))
#+end_src
** Dashboard
#+begin_src emacs-lisp
(use-package nerd-icons)
(use-package dashboard
  :unless noninteractive
  :init
  (setq dashboard-banner-logo-title "Welcome to Emacs Dashboard"
        dashboard-startup-banner 'logo
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-display-icons-p t
        dashboard-icon-type 'nerd-icons
        dashboard-projects-backend (if (package-installed-p 'projectile) 'projectile 'project)
        dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)
                          (registers . 5))
        dashboard-set-navigator t
        dashboard-set-init-info t
        inhibit-startup-screen t)
  :config
  (dashboard-setup-startup-hook)
  (when (daemonp)
    (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name))))
  (add-hook 'dashboard-mode-hook #'my/disable-line-numbers))
#+end_src
** Theme
#+begin_src emacs-lisp
(setq
 modus-themes-italic-constructs t
 modus-themes-bold-constructs t
 modus-themes-subtle-line-numbers nil
 modus-themes-tabs-accented t
 modus-themes-variable-pitch-ui t
 modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

 ;; Options for `modus-themes-prompts' are either nil (the
 ;; default), or a list of properties that may include any of those
 ;; symbols: `background', `bold', `gray', `intense', `italic'
 modus-themes-prompts '(background bold intense italic)

 ;; The `modus-themes-completions' is an alist that reads three
 ;; keys: `matches', `selection', `popup'.  Each accepts a nil
 ;; value (or empty list) or a list of properties that can include
 ;; any of the following (for WEIGHT read further below):
 ;;
 ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
 ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
 ;; `popup' - same as `selected'
 ;; `t' - applies to any key not explicitly referenced (check docs)
 ;;
 ;; WEIGHT is a symbol such as `semibold', `light', or anything
 ;; covered in `modus-themes-weights'.  Bold is used in the absence
 ;; of an explicit WEIGHT.
 modus-themes-completions
 '((matches . (semibold))
   (selection . (extrabold accented))
   (popup . (extrabold accented)))

 modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

 ;; The `modus-themes-headings' is an alist with lots of possible
 ;; combinations, include per-heading-level tweaks: read the
 ;; manual or its doc string
 modus-themes-headings
 '((0 . (variable-pitch light (height 2.2)))
   (1 . (rainbow variable-pitch light (height 1.6)))
   (2 . (rainbow variable-pitch light (height 1.4)))
   (3 . (rainbow variable-pitch regular (height 1.3)))
   (4 . (rainbow regular (height 1.2)))
   (5 . (rainbow (height 1.1)))
   (t . (variable-pitch extrabold))))

(setq modus-themes-italic-constructs t
      modus-themes-bold-constructs t
      modus-themes-mixed-fonts t
      modus-themes-variable-pitch-ui t
      modus-themes-custom-auto-reload nil
      modus-themes-disable-other-themes t

      ;; Options for `modus-themes-prompts' are either nil (the
      ;; default), or a list of properties that may include any of those
      ;; symbols: `italic', `WEIGHT'
      modus-themes-prompts '(italic bold)

      ;; The `modus-themes-completions' is an alist that reads two
      ;; keys: `matches', `selection'.  Each accepts a nil value (or
      ;; empty list) or a list of properties that can include any of
      ;; the following (for WEIGHT read further below):
      ;;
      ;; `matches'   :: `underline', `italic', `WEIGHT'
      ;; `selection' :: `underline', `italic', `WEIGHT'
      modus-themes-completions
      '((matches . (semibold))
        (selection . (extrabold accented)))

      modus-themes-common-palette-overrides
      '((bg-prose-block-contents bg-magenta-nuanced)
        (fg-prose-block-delimiter fg-main))

      ;; The `modus-themes-headings' is an alist: read the manual's
      ;; node about it or its doc string.  Basically, it supports
      ;; per-level configurations for the optional use of
      ;; `variable-pitch' typography, a height value as a multiple of
      ;; the base font size (e.g. 1.5), and a `WEIGHT'.
      modus-themes-headings
      '((1 . (variable-pitch 1.5))
        (2 . (1.3))
        (agenda-date . (1.3))
        (agenda-structure . (variable-pitch light 1.8))
        (t . (1.1))))

(load-theme 'modus-operandi t)
(setq modus-themes-to-toggle '(modus-operandi modus-vivendi))
(my/map-Toggle
 "t" '("theme" . modus-themes-toggle))
#+end_src

** Indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :unless noninteractive
  :hook (prog-mode . highlight-indent-guides-mode)
  :hook (conf-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-delay 0))
#+end_src
** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :unless noninteractive
  :config
  (doom-modeline-mode 1)
  :custom
  (doom-modeline-height 15)
  (doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode)))
  #+end_src
** Word Wrapping
#+begin_src emacs-lisp
(global-visual-line-mode t)
(my/map-Toggle
 "w" '("Word wrap" . visual-line-mode))
#+end_src
** Rainbow delimeters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Highlight todos
#+begin_src emacs-lisp
(use-package hl-todo
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode))
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"       warning bold)
          ("FIXME"      error bold)
          ("REVIEW"     font-lock-keyword-face bold)
          ("NOTE"       success bold)
          ("DEPRECATED" font-lock-doc-face bold))))
#+end_src
** evil-owl
#+begin_src emacs-lisp
(use-package evil-owl
  :after evil
  :unless noninteractive
  :config
  (setq evil-owl-max-string-length 500)
  (add-to-list 'display-buffer-alist
               '("*evil-owl*"
                 (display-buffer-in-side-window)
                 (side . bottom)
                 (window-height . 0.3)))
  (evil-owl-mode))
#+end_src
** Whitespace butler
#+begin_src emacs-lisp
(use-package ws-butler
  :hook ((prog-mode text-mode) . ws-butler-mode))
#+end_src
* Bookmarks
** Evil
#+begin_src emacs-lisp
(use-package evil-fringe-mark
  :unless noninteractive
  :requires evil
  :after evil
  :hook (after-init . global-evil-fringe-mark-mode)
  :init
  ;; Persist global marks
  (after! savehist
          (add-to-list 'savehist-additional-variables 'evil-markers-alist))
  ;; Persist local marks
  (append! desktop-locals-to-save evil-markers-alist)
  ;; Show Marks in buffer
  (my/map-Open "`" '("Show marks" . evil-show-marks))
  :config
  (setq evil-fringe-mark-show-special t)
  (my/map-Toggle "f" '("Evil Marks" . evil-fringe-mark-mode)))
#+end_src

** Bookmark
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :unless noninteractive
  :after evil
  :config (my/map-menu! "Bookmarks" "B"
            "b" '("Jump" . bookmark-jump)
            "l" '("List" . bookmark-bmenu-list)
            "s" '("Set" . bookmark-set)
            "r" '("Rename" . bookmark-rename)
            "d" '("Delete" . bookmark-delete)
            "a" '("Add" . bookmark-set))
  :init
  (setq bookmark-default-file (concat my/cache-dir "bookmarks")
        bookmark-save-flag 1))
#+end_src
* Ripgrep
#+begin_src emacs-lisp
(use-package rg
  :unless noninteractive
  :hook (rg-mode . (lambda ()
                     (wgrep-rg-setup)
                     (define-key rg-mode-map (kbd "n") 'evil-search-next)
                     (define-key rg-mode-map (kbd "N") 'evil-search-previous)))
  :custom
  (rg-custom-type-aliases nil)
  (rg-default-alias-fallback "everything")
  (rg-group-result t)
  (rg-hide-command t)
  (rg-show-header t)
  (rg-show-columns nil)
  :init
  (use-package wgrep)
  (my/map-Search
   "p" '("Project Search" . my/grep-project)
   "S" '("Ripgrep menu" . rg-menu))
  :config
  (add-popup! "^\\*eshell.*\\*$" 'rg-mode)
  (rg-define-search my/grep-project
    :query ask
    :format regexp
    :files ask
    :dir project
    :confirm prefix
    :flags ("--hidden -g !.git")))
#+end_src
* Project management
** Projectile
#+begin_src emacs-lisp
(defvar my/projectile-ignore-projects '("^/sudo:" "^/docker:" "^/nix/store"))
(use-package projectile
  :diminish
  :unless noninteractive
  :custom
  (projectile-switch-project-action #'projectile-dired)
  (projectile-sort-order 'recently-active)
  (projectile-file-exists-remote-cache-expire (* 10 60))
  (projectile-require-project-root t)
  (projectile-per-project-compilation-buffer t)
  :hook after-init
  :init
  (eval-and-compile
    (setopt projectile-ignored-project-function
            (defun my/projectile-ignore-projects (project-root)
                "Ignore matching regexes in `my/projectile-ignore-projects'."
                (cl-some (lambda (regex) (string-match-p regex project-root))
                         my/projectile-ignore-projects))))
  :config
  (bind-keys
   ([remap next-buffer] . projectile-next-project-buffer)
   ([remap previous-buffer] . projectile-previous-project-buffer))
  (after! evil
          (bind-keys
           ([remap evil-next-buffer] . projectile-next-project-buffer)
           ([remap evil-previous-buffer] . projectile-previous-project-buffer)))
  (my/map-Buffer
   "]" '("Next Buffer" . projectile-next-project-buffer)
   "[" '("Previous Buffer" . projectile-previous-project-buffer))
  (put 'dired-find-alternate-file 'disabled nil)
  (my/leader-def
   "p" '("projectile" . projectile-command-map))
  (append! projectile-project-root-files-bottom-up "Androib.bp"))
#+end_src
** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :unless noninteractive
  :custom
  (persp-mode-prefix-key nil)
  (persp-suppress-no-prefix-key-warning t)
  (persp-state-default-file  (concat my/local-dir "perspective"))
  (persp-sort 'access)
  (my/kill-buffer-fun #'persp-kill-buffer*)
  :bind
  ([remap kill-buffer] . persp-kill-buffer*)
  :hook (after-init . persp-mode)
  :hook (ibuffer . (lambda ()
                     (persp-ibuffer-set-filter-groups)
                     (unless (eq ibuffer-sorting-mode 'alphabetic)
                       (ibuffer-do-sort-by-alphabetic))))
  :hook (kill-emacs . persp-state-save)
  :unless noninteractive
  :config
  (my/leader-def
   "TAB" '("Workspaces" . perspective-map))
  (which-key-add-keymap-based-replacements perspective-map
    "TAB" '("Switch" . persp-switch))
  (if (package-installed-p 'projectile)
      (after! projectile
              (use-package persp-projectile
                :demand
                :bind ([remap projectile-switch-project] . projectile-persp-switch-project))))
  :hook (ibuffer . (lambda ()
                     (persp-ibuffer-set-filter-groups)
                     (unless (eq ibuffer-sorting-mode 'alphabetic)
                       (ibuffer-do-sort-by-alphabetic))))
  :hook (kill-emacs . persp-state-save))
#+end_src
* Buffer management
#+begin_src emacs-lisp
(use-package ibuffer
  :unless noninteractive
  :ensure nil
  :commands ibuffer
  :init (my/map-Buffer
         "i" '("ibuffer" . ibuffer))
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-saved-filters nil)
  (define-ibuffer-column size
    (:name "Size" :inline t)
    (file-size-human-readable (buffer-size))))
                                        ; next/prev buffer skip special buffers
(setq switch-to-prev-buffer-skip-regexp '("^\\*.*\\*$"))
#+end_src
* Dired
#+begin_src emacs-lisp
(use-package dired
  :unless noninteractive
  :ensure nil
  :demand
  :config
  (after! evil
          (evil-define-key 'normal 'global
            "-" #'dired-jump))
  (my/map-Open
   "d" '("dired" . dired-jump)
   "D" '("dired other window" . dired-jump-other-window))
  (require 'dired-aux)
  (require 'dired-x)
  (setq dired-listing-switches "-lahFLHvZD --group-directories-first"
        dired-dwim-target t
        dired-recursive-copies 'always
        dired-recursive-deletes 'always
        dired-hide-details-hide-symlink-targets nil
        dired-hide-details-hide-information-lines nil
        insert-directory-program (if IS-MAC (executable-find "gls") insert-directory-program)
        dired-use-ls-dired t
        dired-auto-revert-buffer t
        dired-kill-when-opening-new-dired-buffer t)
  (evil-collection-define-key 'normal 'dired-mode-map
    (kbd "<RET>")  #'dired-find-alternate-file
    "h" 'dired-single-up-directory
    "l" 'dired-single-buffer)
  (add-hook 'dired-mode-hook #'hl-line-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode))
#+end_src
** History
#+begin_src emacs-lisp
(after! dired
        (use-package dash)

        (defvar dired-hist-list nil
          "The stack of previously visited Dired buffers.")

        (defun dired-hist--update ()
          "Update the Dired buffer history stack."
          (if (-contains? dired-hist-list default-directory)
              (setq dired-hist-list (remove default-directory dired-hist-list)))
          (add-to-list 'dired-hist-list default-directory))

        (defun dired-hist-recent ()
          "Use dired to visit a recent directory"
          (interactive)
          (let ((dir (completing-read "Dired History: " dired-hist-list nil t)))
            (if dir (dired dir))))

        (after! savehist
                (append! savehist-additional-variables '(dired-hist-list . 50)))

        (define-minor-mode dired-hist-mode
          "Keep track of visited Dired buffers and switch between them."
          :group 'dired-hist
          :global t
          :lighter nil
          (if dired-hist-mode
              (add-hook 'dired-mode-hook #'dired-hist--update)
            (remove-hook 'dired-mode-hook #'dired-hist--update)))

        (message "%s" dired-hist-mode)

        (bind-key "_"  #'dired-hist-recent 'evil-normal-state-map (lambda () dired-hist-mode))

        (dired-hist-mode 1))
#+end_src
** Writable file tree
#+begin_src emacs-lisp
(use-package wdired
  :ensure nil
  :after dired
  :custom
  (wdired-allow-to-change-permissions 'advanced)
  (wdired-allow-to-redirect-links t)
  (wdired-confirm-overwrite t)
  :config
  (my/local-leader-def dired-mode
      "w" '("wdired" . wdired-change-to-wdired-mode))
  (after! evil-collection
          (evil-collection-wdired-setup)))
#+end_src
** Icons
#+begin_src emacs-lisp
(use-package nerd-icons-dired
  :hook
  (dired-mode . nerd-icons-dired-mode))
#+end_src
** Colors
#+begin_src emacs-lisp
(use-package diredfl
  :after dired
  :config (diredfl-global-mode))
#+end_src
** Copy
#+begin_src emacs-lisp
(use-package dired-rsync
  :bind ([remap dired-do-copy] . dired-rsync))
#+end_src
* Tree Sitter
#+begin_src emacs-lisp
(use-package treesit-auto
  :unless noninteractive
  :custom
  (treesit-auto-install nil)
  (treesit-font-lock-level 4)
  :config
  (define-minor-mode my/treesit-mode "My treesit mode. For easily binding keys"
    :interactive nil)
  (if-let ((path (getenv "MY_TREESIT_PATH")))
      (add-to-list 'treesit-extra-load-path path))
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src
** expreg
#+begin_src emacs-lisp
(use-package expreg
  :bind
  (("C-<tab>" . expreg-expand))
  (:map evil-visual-state-map
        ("<tab>" . expreg-expand))
  (:repeat-map expreg-repeat-map
               ("<tab>" . expreg-expand)
               ("<backtab>" . expreg-contract)))
#+end_src
** evil text obj
#+begin_src emacs-lisp :tangle no
(use-package evil-textobj-tree-sitter
  :after (evil treesit)
  :unless noninteractive
  :config
  (require 'evil-textobj-tree-sitter-core)
  (defun meain/fancy-narrow-to-thing (thing)
    (interactive)
    (if (buffer-narrowed-p) (fancy-widen))
    (let ((range (evil-textobj-tree-sitter--range 1 (list (intern thing)))))
      (fancy-narrow-to-region (car range) (cdr range))))
  (my/map-menu! "Narrow" "N"
    "n" `("widen" . ,(lambda () (interactive) (fancy-widen)))
    "f" `("function" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "function.outer")))
    "c" `("class" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "class.outer")))
    "C" `("comment" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "comment.outer")))
    "o" `("loop" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "loop.outer")))
    "i" `("conditional" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "conditional.outer")))
    "a" `("parameter" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "parameter.outer"))))
  ;; copied from doomemacs
  (defvar +tree-sitter-inner-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-outer-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-previous-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-next-map (make-sparse-keymap))

  (evil-define-key '(visual operator) 'my/treesit-mode
    "i" +tree-sitter-inner-text-objects-map
    "a" +tree-sitter-outer-text-objects-map)
  (evil-define-key 'normal 'my/treesit-mode
    "[g" +tree-sitter-goto-previous-map
    "]g" +tree-sitter-goto-next-map)
  (which-key-add-keymap-based-replacements +tree-sitter-inner-text-objects-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.inner" "call.inner")))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.inner"))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.inner"))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.inner"))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.inner"))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.inner"))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.inner")))
  (which-key-add-keymap-based-replacements +tree-sitter-outer-text-objects-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.outer"))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.outer"))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.outer"))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.outer"))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.outer"))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.outer")))
  (which-key-add-keymap-based-replacements +tree-sitter-goto-previous-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer") t))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.outer" t))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.outer" t))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.outer" t))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.outer" t))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.outer" t))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.outer" t)))
  (which-key-add-keymap-based-replacements +tree-sitter-goto-next-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.outer"))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.outer"))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.outer"))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.outer"))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.outer"))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.outer"))))
#+end_src
* Eval region
#+begin_src emacs-lisp
(after! evil
        (defun my/elisp-eval-region (beg end)
          (interactive "r")
          (eval-region beg end t))
        (defvar my/evil-extra-operator-eval-modes-alist
          '((emacs-lisp-mode my/elisp-eval-region)))

        (evil-define-operator my/evil-operator-eval (beg end)
          :move-point nil
          (interactive "<r>")
          (let* ((mode (if (org-in-src-block-p) (intern (car (org-babel-get-src-block-info))) major-mode))
                 (ele (assoc mode my/evil-extra-operator-eval-modes-alist))
                 (f-a (cdr-safe ele))
                 (func (car-safe f-a))
                 (args (cdr-safe f-a)))
            (if (fboundp func)
                (apply func beg end args)
              (eval-region beg end t))))
        (evil-define-key 'motion 'global "gr" 'my/evil-operator-eval))
#+end_src
* Calc
#+begin_src emacs-lisp
(use-package calc
  :unless noninteractive
  :ensure nil ;; built-in
  :commands (calc full-calc)
  :init (my/map-Open
         "c" '("calc" . calc)
         "C" '("full-calc" . full-calc))
  :config
  (setq calc-angle-mode 'rad
        calc-algebraic-mode t
        calc-display-trail t
        calc-group-digits t
        calc-line-numbering t
        calc-multiplication-has-precedence t
        calc-number-radix 10
        calc-symbolic-mode t
        calc-undo-length 1000
        calc-window-height 15)
  (defmath uconvert (v u)
    "Convert value V to compatible unit U."
    (math-convert-units v u))
  (add-hook 'calc-mode-hook #'my/disable-line-numbers))
#+end_src
* String Inflection
#+begin_src emacs-lisp
(use-package string-inflection
  :unless noninteractive
  :after evil
  :config
  (my/map-menu! "naming convention" "c ~"
    "~" '("cycle" . string-inflection-all-cycle)
    "t" '("toggle" . string-inflection-toggle)
    "c" '("CamelCase" . string-inflection-camelcase)
    "d" '("downCase" . string-inflection-lower-camelcase)
    "k" '("kebab-case" . string-inflection-kebab-case)
    "_" '("under_score" . string-inflection-underscore)
    "u" '("Upper_Score" . string-inflection-capital-underscore)
    "U" '("UP_CASE" . string-inflection-upcase))
  (evil-define-operator evil-operator-string-inflection (beg end _type)
    "Define a new evil operator that cycles symbol casing."
    :move-point nil
    (interactive "<R>")
    (string-inflection-all-cycle)
    (setq evil-repeat-info '([?g ?~])))
  (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection))
    #+end_src
* Smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :unless noninteractive
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  (sp-show-pair-from-inside t)
  (sp-cancel-autoskip-on-backward-movement nil)
  (sp-pair-overlay-keymap (make-sparse-keymap))
  (sp-max-prefix-length 25)
  (sp-max-pair-length 4)
  :hook (prog-mode . smartparens-mode)
  :hook (prog-mode . show-smartparens-mode)
  :config
  (my/map-Toggle "p" '("smartparens" . smartparens-mode))
  (use-package smartparens-config :ensure nil)
  (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode emacs-lisp-mode) "'" nil :actions nil)
  (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode emacs-lisp-mode) "`" nil :actions nil)
  (show-smartparens-global-mode t))
(use-package evil-smartparens
  :unless noninteractive
  :after (evil smartparens)
  :hook (smartparens-mode . evil-smartparens-mode)
  :hook (smartparens-strict-mode . evil-smartparens-mode))
#+end_src
* Help
** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :unless noninteractive
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-command] . helpful-command)
  :config
  (evil-define-key 'normal 'global
    "K" #'helpful-at-point)
  (append! my/special-window-no-cursor-manage-alist "^\\*helpful .*\\*$")
  (after! undo-tree
          (append! undo-tree-incompatible-major-modes #'helpful-mode)))
#+end_src
** Man & TLDR
#+begin_src emacs-lisp
(use-package tldr
  :unless noninteractive
  :commands (tldr tldr-update-docs)
  :bind (:map help-map
              ("t" . tldr)
              ("w" . woman))
  :init
  (append! my/special-window-no-cursor-manage-alist "^\\*tldr\\*$")
  (add-popup! "^\\*tldr\\*$" 'tldr-mode)
  (setq tldr-directory-path (concat my/cache-dir "tldr/")))
#+end_src
* Undo
** Undo Fu
#+begin_src emacs-lisp
(unless noninteractive
  (use-package undo-fu
    :demand t
    :custom
    (undo-limit         (* 512 1024 1024))
    (undo-strong-limit  (* 1024 1024 1024))
    (undo-outer-limit   (* 2 1024 1024 1024))
    (evil-undo-system 'undo-fu)
    :bind
    ([remap undo] . undo-fu-only-undo)
    ([remap redo] . undo-fu-only-redo)
    ("C-_"        . undo-fu-only-undo)
    ("M-_"        . undo-fu-only-redo)
    ("C-M-_"      . undo-fu-only-redo-all))
  (use-package undo-fu-session
    :after undo-fu
    :demand t
    :hook (after-init . global-undo-fu-session-mode)
    :bind
    ("C-x r u"    . undo-fu-session-save)
    ("C-x r U"    . undo-fu-session-recover)
    :custom
    (undo-fu-session-directory (concat my/cache-dir "undo-fu-session/"))
    (undo-fu-session-compression 'zst)
    :config
    (setopt undo-fu-session-make-file-name-function
            (defun my/undo-fu-session-make-file-name (filename ext)
              "Take the path FILENAME, EXT and return a name base on this."
              (declare (important-return-value t) (side-effect-free error-free))
              (concat
               (file-name-concat undo-fu-session-directory
                                 (sha1
                                  (convert-standard-filename (expand-file-name filename))))
               ext)))))
#+end_src
** Vundo
#+begin_src emacs-lisp
(use-package vundo
  :unless noninteractive
  :bind (:map my/map-Open-map ("u" . vundo))
  :custom
  (vundo-compact-display nil)
  (vundo-glyph-alist vundo-unicode-symbols))
#+end_src
* Completion
** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :unless noninteractive
  :demand
  :custom
  (corfu-cycle t)
  (corfu-auto t)
  (corfu-auto-prefix 2)
  (corfu-preselect 'prompt)
  (corfu-on-exact-match nil)
  (corfu-scroll-margin 5)
  (corfu-quit-at-boundary t)
  (completion-cycle-threshold t)
  (read-extended-command-predicate #'command-completion-default-include-p)
  (completion-styles '(orderless basic))
  (tab-always-indent 'complete)
  (text-mode-ispell-word-completion nil)
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous))
  :config
  (global-corfu-mode)

  ;; Use Dabbrev with Corfu!
  (use-package dabbrev
    :unless noninteractive
    :ensure nil
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . dabbrev-expand))
    ;; Other useful Dabbrev configurations.
    :config
    (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
    ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
    (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode)))
#+end_src
*** Corfu Popup Info
#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-hide nil)
  (corfu-popupinfo-delay '(0.25 . 0)))
#+end_src
*** Corfu History
#+begin_src emacs-lisp
(use-package corfu-history
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-history-mode)
  :config
  (after! savehist
          (append! savehist-additional-variables 'corfu-history)))
#+end_src
** Icons
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :requires corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
** Cape
#+begin_src emacs-lisp
(use-package cape
  :unless noninteractive
  :custom
  (text-mode-ispell-word-completion nil)
  :config
  (require 'cape-keyword)
  (my/map-menu! "Completions" "c p"
    "p" '("Complete at point" . completion-at-point)
    "t" '("Complete tag" . complete-tag)
    "d" '("Dabbrev" . cape-dabbrev)
    "f" '("File" . cape-file)
    "k" '("Keyword" . cape-keyword)
    "s" '("Symbol" . cape-elisp-symbol)
    "a" '("Abbrev" . cape-abbrev)
    "l" '("Line" . cape-line)
    "w" '("Dict" . cape-dict)
    "\\" '("Tex" . cape-tex))
  (append! completion-at-point-functions
    #'cape-abbrev
    #'cape-dabbrev
    #'ispell-completion-at-point
    #'cape-file
    #'cape-elisp-block
    #'cape-history
    #'cape-keyword))
#+end_src
** Tempel
#+begin_src emacs-lisp
(use-package tempel
  :unless noninteractive
  :demand (not noninteractive)
  :custom
  (tempel-trigger-prefix "<")
  :config
  (define-key tempel-map (kbd "<TAB>") #'tempel-next)
  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
    ;; only triggers on exact matches. Alternatively use `tempel-complete' if
    ;; you want to see all matches, but then Tempel will probably trigger too
    ;; often when you don't expect it.
    ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
    ;; such that it will be tried first.
    (unless (member #'tempel-expand completion-at-point-functions)
      (make-local-variable 'completion-at-point-functions)
      (push #'tempel-expand completion-at-point-functions)))
  :hook (prog-mode . tempel-setup-capf)
  :hook (text-mode . tempel-setup-capf))
(use-package tempel-collection
  :after tempel
  :config
  (tempel-collection))
#+end_src
** Marginalia
#+begin_src emacs-lisp
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  :unless noninteractive
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))
  ;; load after completion-at-point
  :config (marginalia-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp
;; Enable orderless matching style.  See `+orderless-dispatch' in
;; `consult-config.el' for an advanced Orderless style dispatcher.
(use-package orderless
  :unless noninteractive
  :after vertico
  :custom
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles . (partial-completion)))))
  :config
  (append! completion-styles
    'orderless
    'partial-completion
    'basic))
#+end_src
** Vertico
#+begin_src emacs-lisp
;; Enable vertico
(use-package vertico
  :unless noninteractive
  :custom
  ;; Enable cycling for `vertico-next' and `vertico-previous'.
  (vertico-cycle t)
  ;; Grow and shrink the Vertico minibuffer
  (resize-mini-windows 'grow-only)
  (vertico-count 20)
  :config
  (vertico-mode)
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src
** Consult
#+begin_src emacs-lisp
(use-package consult
  :unless noninteractive
  :custom
  (consult-line-start-from-top t)
  :bind
  (:map my/maps/leader
        ("/" . consult-ripgrep))
  (:map my/map-Search-map
        ("s" . consult-line))
  (:map my/map-Buffer-map
        ("b" . consult-buffer))
  (:map my/map-File-map
        ("r" . consult-recent-file))
  (:map help-map
        ("h" . consult-man)))
(use-package consult-flymake
  :ensure consult
  :commands consult-flymake
  :init
  (after! flycheck
          (my/map-menu! "Errors" "c e"
            "f" '("Consult Flymake" . consult-flymake))))
#+end_src
** Embark
#+begin_src emacs-lisp
(use-package embark
  :unless noninteractive
  :commands (embark-act
             embark-bindings
             embark-collect
             embark-export)
  :config
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  (setq which-key-use-C-h-commands nil
        prefix-help-command #'embark-prefix-help-command)
  (bind-key [remap describe-bindings] #'embark-bindings)
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (setq embark-prompter 'embark-completing-read-prompter)
  (add-popup! #'embark-collect-mode)
  :init
  (my/map-menu! "Embark" "e"
    "o" '("export" . embark-export)
    "e" '("act" . embark-act)
    "b" '("bindings" . embark-bindings)
    "c" '("collect" . embark-collect))
  (bind-key
   "C-c e" `("embark" . ,my/map-Embark-map)))
(use-package embark-consult
  :if (and (featurep 'embark)
           (featurep 'consult))
  :after (embark consult)
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src
** Prescient
#+begin_src emacs-lisp
(use-package prescient
  :unless noninteractive
  :config
  (use-package corfu-prescient
    :hook corfu-mode)
  (use-package vertico-prescient
    :hook vertico-mode))
#+end_src
* Terminal
** EAT
#+begin_src emacs-lisp
(use-package eat
  :unless noninteractive
  :hook (eshell-load . eat-eshell-mode)
  :commands eat
  :custom
  (eat-shell-prompt-annotation-delay 0)
  (eat-very-visible-cursor-type '(nil nil nil))
  (eat-default-cursor-type '(nil nil nil))
  (eat-vertical-bar-cursor-type '(nil nil nil))
  (eat-horizontal-bar-cursor-type '(nil nil nil))
  (eat-very-visible-horizontal-bar-cursor-type '(nil nil nil))
  (eat-very-visible-vertical-bar-cursor-type '(nil nil nil))
  (eat-kill-buffer-on-exit t)
  :init
  (if (featurep 'projectile)
      (defun my/eat ()
        (interactive)
        (let ((project (projectile-acquire-root)))
          (projectile-with-default-dir project
            (let ((eat-buffer-name (projectile-generate-process-name "eat" project)))
              (eat)))))
    (defun my/eat ()
      (interactive)
      (eat)))
  (my/map-Open "t" '("Terminal" . my/eat))
  :config
  (add-hook 'eat-mode-hook
            (defun my/eat-hook ()
              (setq-local process-adaptive-read-buffering t)
              (setq-local read-process-output-max (* 64 1024 1024))))
  (add-popup!
   "^\\*eat.*\\*$"  'eat-mode)
  (eat-eshell-mode))
#+end_src
** Eshell
#+begin_src emacs-lisp
(use-package eshell
  :unless noninteractive
  :ensure nil
  :commands eshell
  :init
  (setq my/repl-fallback #'eshell)
  (my/map-Open
   "e" '("eshell" . eshell))
  (setq eshell-aliases-file (concat my/cache-dir "eshell/alias")
        eshell-history-file-name (concat my/cache-dir "eshell/history")
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input 'all
        eshell-error-if-no-glob t
        eshell-glob-case-insensitive t
        eshell-scroll-show-maximum-output nil)
  (make-directory (concat my/cache-dir "eshell") t)
  :config
  (add-popup! "^\\*eshell.*\\*$" 'eshell-mode)
  (add-hook 'eshell-mode-hook #'my/disable-line-numbers)
  (after! corfu (add-hook 'eshell-mode-hook #'corfu-mode)))
(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+end_src
* Formatting and linting/checking
** Format on save
#+begin_src emacs-lisp
(use-package apheleia
  :unless noninteractive
  :custom
  (apheleia-remote-algorithm 'local)
  :config (apheleia-global-mode +1))
#+end_src
** Linting
#+begin_src emacs-lisp
(use-package flycheck
  :unless noninteractive
  :config
  (my/map-Errors
   "e" '("List errors" . flycheck-list-errors)
   "n" '("Next error" . flycheck-next-error)
   "p" '("Previous error" . flycheck-previous-error)
   "d" '("Describe checker" . flycheck-describe-checker)
   "v" '("Verify setup" . flycheck-verify-setup))
  (global-flycheck-mode)
  (add-popup! "^\\*Flycheck.*\\*$" #'flycheck-error-list-mode)
  :custom
  (flycheck-indication-mode 'left-margin))
#+end_src
** Jinx
#+begin_src emacs-lisp
(use-package jinx
  :unless noninteractive
  :demand (not noninteractive)
  :hook (emacs-startup . global-jinx-mode)
  :custom
  (ispell-aspell-dict-dir (cdr (split-string (getenv "ASPELL_CONF"))))
  (jinx-languages "en_US")
  :config
  (evil-define-key 'normal 'global
    "]s" '("Spelling error" . jinx-next)
    "[s" '("Spelling error" . jinx-previous)
    "z=" 'jinx-correct)
  (after! vertico
          (use-package vertico-grid :ensure nil)
          (use-package vertico-multiform :ensure nil)
          (add-to-list 'vertico-multiform-categories
                       '(jinx grid (vertico-grid-annotate . 20)))
          (vertico-multiform-mode 1)))
#+end_src
* Environment
#+begin_src emacs-lisp
(use-package inheritenv)
(use-package envrc
  :hook (after-init . envrc-global-mode))
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+end_src
* Git
** Magit
#+begin_src emacs-lisp
(use-package magit
  :unless noninteractive
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (magit-log-arguments '("--graph" "--decorate" "--color"))
  (magit-format-file-function #'magit-format-file-nerd-icons)
  (magit-wip-merge-branch nil)
  :config
  (my/map-Git
   "g" '("Status" . magit-status)
   "b" '("Blame" . magit-blame)
   "l" '("Log" . magit-log)
   "c" '("commit" . magit-commit)
   "G" '("Status here" . magit-status-here)
   "S" '("Stage file" . magit-stage-buffer-file)
   "U" '("Unstage file" . magit-unstage-file))
  (keymap-unset magit-mode-map "SPC")
  (add-popup! "\\*\\*magit-process:.*\\*\\*")
  (append! magit-status-sections-hook #'magit-insert-modules)

  (require 'magit-wip)
  (magit-wip-mode)

  (defun my/ansi-color-buffer (proc &rest args)
    (interactive)
    (with-current-buffer (process-buffer proc)
      (read-only-mode -1)
      (ansi-color-apply-on-region (point-min) (point-max))
      (read-only-mode 1)))

  (advice-add 'magit-process-filter :after #'my/ansi-color-buffer))
  #+end_src
** ediff
#+begin_src emacs-lisp
(after! org
        (require 'ediff)
        (add-hook 'ediff-prepare-buffer-hook #'org-show-all))
(setq ediff-diff-options ""
      ediff-custom-diff-options "-u"
      ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-vertically)
#+end_src
** Time Machine
#+begin_src emacs-lisp
(use-package git-timemachine
  :unless noninteractive
  :custom
  (git-timemachine-show-minibuffer-details t)
  :init
  (my/map-Git
   "t" '("Time machine" . git-timemachine))
  :bind
  (:map git-timemachine-mode-map
        ("C-l" . git-timemachine-show-previous-revision)
        ("C-j" . git-timemachine-show-next-revision)
        ("q"   . git-timemachine-quit-to-invoking-buffer))
  :config
  (add-hook 'git-timemachine-mode-hook 'evil-normalize-keymaps))
#+end_src
** Forge
#+begin_src emacs-lisp
(use-package forge
  :unless noninteractive
  :after magit
  :init
  (setq forge-add-default-bindings nil))
#+end_src
** diff-hl
#+begin_src emacs-lisp
(use-package diff-hl
  :custom
  (vc-handled-backends '(Git))
  (fringes-outside-margins t)
  (vc-git-diff-switches '("--histogram"))
  (diff-hl-flydiff-delay 0.5)
  (diff-hl-update-async t)
  (diff-hl-show-staged-changes nil)
  :bind (:map my/map-Git-map
              ("r" . diff-hl-revert-hunk))
  :hook (prog-mode text-mode)
  :hook (magit-post-refresh . diff-hl-magit-post-refresh))

(use-package diff-hl-margin
  :ensure diff-hl
  :hook (diff-hl-mode))
(use-package diff-hl-dired
  :ensure diff-hl
  :hook dired-mode)
#+end_src
* Eglot
#+begin_src emacs-lisp
(use-package eglot
  :unless noninteractive
  :ensure nil ;; included in emacs29+
  :commands (eglot eglot-ensure)
  :init
  (use-package markdown-mode) ;; Better formatting eldoc
  (setq eglot-events-buffer-size 0) ;; don't log events
  (setq eglot-extend-to-xref t)
  :config
  (my/map-menu! "LSP" "cl"
    "a" #'eglot-code-actions
    "Q" #'eglot-reconnect
    "q" #'eglot-shutdown-all
    "r" #'eglot-rename
    "f" #'eglot-format-buffer)
  (when (featurep 'tempel)
    (use-package eglot-tempel))
  (after! cape
          (add-hook
           'eglot-managed-mode-hook
           (defun my/eglot-managed-mode-hook-completions ()
             (append! completion-category-overrides '((eglot (styles orderless))))
             (setq-local completion-category-defaults nil)
             (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
             (advice-add 'eglot-completion-at-point :around #'cape-wrap-noninterruptible)
             (setq-local completion-at-point-functions (list #'eglot-completion-at-point))))))
#+end_src
** Eglot Tempel
#+begin_src emacs-lisp
(use-package eglot-tempel
  :unless noninteractive
  :after (eglot tempel))
#+end_src
** Booster
#+begin_src emacs-lisp
(use-package eglot-booster
  :after eglot
  :custom
  (eglot-booster-io-only (not (version< emacs-version "30")))
  :config
  (eglot-booster-mode)
  (setf (car eglot-booster--boost) (executable-find "emacs-lsp-booster")))
#+end_src
** Flycheck Eglot
#+begin_src emacs-lisp
(use-package flycheck-eglot
  :unless noninteractive
  :after (flycheck eglot)
  :custom (flycheck-eglot-exclusive nil)
  :config (global-flycheck-eglot-mode 1))
#+end_src
** eldoc
#+begin_src emacs-lisp
(use-package eldoc
  :ensure nil
  :unless noninteractive
  :hook
  (eglot-mode . eldoc-mode)
  (emacs-lisp-mode . eldoc-mode)
  :config
  (add-popup! "\\*eldoc\\*")
  :custom
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t))
#+end_src
*** eldoc-box
#+begin_src emacs-lisp
(use-package eldoc-box
  :hook (emacs-lisp-mode . eldoc-box-hover-at-point-mode)
  :hook (eglot--managed-mode . eldoc-box-hover-at-point-mode))
#+end_src

** dape
#+begin_src emacs-lisp
(use-package dape
  ;; To use window configuration like gud (gdb-mi)
  :bind
  (:map my/map-Open-map
        ("?" . dape))
  :custom
  (dape-buffer-window-arrangment 'gud)
  (dape-buffer-window-arrangment 'right)
  (dape-adapter-dir (concat my/local-dir "dape-adapters/"))
  :config
  (my/leader-def
   "d" (cons "Debug" dape-global-map))
  ;; By default dape uses gdb keybinding prefix
  (setq dape-key-prefix "\C-x\C-a")

  ;; Kill compile buffer on build success
  ;; (add-hook 'dape-compile-compile-hooks 'kill-buffer)

  ;; Save buffers on startup, useful for interpreted languages
  (add-hook 'dape-on-start-hooks
            (defun dape--save-on-start ()
              (save-some-buffers t t))))
#+end_src
* Languages
** Nix
#+begin_src emacs-lisp
(use-package nix-ts-mode
  :mode "\\.nix\\'"
  :config
  (define-minor-mode nix-mode "Fake `nix-mode'. Used with `nix-ts-mode'")
  (add-hook 'nix-ts-mode-hook #'nix-mode)
  (add-hook 'nix-ts-mode-hook #'my/treesit-mode)
  (after! apheleia
          (setf (alist-get 'nixfmt apheleia-formatters)
                '("nixfmt"))
          (setf (alist-get 'nix-ts-mode apheleia-mode-alist)
                '(nixfmt)))
  (after! eglot
          (setf (alist-get 'nix-ts-mode eglot-server-programs) (alist-get 'nix-mode eglot-server-programs))
          (add-hook 'nix-mode-hook #'eglot-ensure))
  (provide 'nix-mode))

(use-package nix-drv-mode
  :ensure nix-mode
  :mode "\\.drv\\'")
(use-package nix-shell
  :ensure nix-mode
  :commands (nix-shell-unpack nix-shell-configure nix-shell-build))
(use-package nix-repl
  :ensure nix-mode
  :after nix-mode
  :bind (:map my/map-Open-map :filter nix-mode
              ("r" . nix-repl)))
(use-package agenix
  :mode ("\\.age\\'" . agenix-mode-if-with-secrets-nix)
  :config
  (after! envrc (add-hook 'agenix-pre-mode-hook #'envrc-mode)))
#+end_src
** Python
#+begin_src emacs-lisp
(use-package python
  :ensure nil
  :mode ("\\.py\\'" . python-mode)
  :mode ("[./]flake8\\'" . conf-mode)
  :mode ("/Pipfile\\'" . conf-mode)
  :interpreter ("python" . python-mode)
  :init
  (setq python-check-command "pyflakes")
  :config
  (after! apheleia
          (add-hook 'python-mode-hook (lambda ()
                                        (setq-local apheleia-formatter '(ruff ruff-isort)))))
  (after! treesit-auto
          (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode)))

  (add-hook 'python-ts-mode-hook (defun my/python-ts-base-hook () (run-hooks 'python-mode-hook)))
  (add-hook 'python-ts-mode-hook #'my/treesit-mode)

  (add-hook 'python-mode-hook (lambda ()
                                (setf
                                 (alist-get 'python-mode my/repl-alist) #'run-python
                                 (alist-get 'python-ts-mode my/repl-alist) #'run-python)))

  (my/local-leader-def python-mode
      "r" '("repl/python" . run-python)
      "b" '("send buffer to repl" . python-shell-send-buffer))
  (after! dape
          ;; for some reason "python" doesn't find the module "debugpy". It seems that dape
          ;; uses a strange way to lookup in path. This lets it find the installed debugger
          ;; when I'm using my global python env and can be reset in dir locals or direnv
          ;; otherwise
          (plist-put (alist-get 'debugpy dape-configs) 'command (executable-find "python3")))
  (add-hook 'python-mode-hook 'eglot-ensure))

(use-package flymake-ruff
  :unless noninteractive
  :hook (eglot-managed-mode . flymake-ruff-load))

(use-package ob-python
  :ensure nil
  :after org
  :commands org-babel-execute:python
  :init
  (add-to-list 'org-babel-load-languages '(python . t))
  (setq org-babel-python-command "python3"))
#+end_src
*** Virtual Environments
#+begin_src emacs-lisp
(use-package pyvenv
  :config
  ;; Display virtual envs in the menu bar
  (setq pyvenv-menu t)
  ;; Restart the python process when switching environments
  (add-hook 'pyvenv-post-activate-hooks (lambda ()
                                          (pyvenv-restart-python)))
  (my/local-leader-def-python-mode
   "v" '("workon" . pyvenv-workon))
  :after python
  :hook (python-mode . pyvenv-mode))

(use-package poetry
  :after python
  :hook (python-mode . poetry-tracking-mode)
  :config (my/local-leader-def-python-mode
           "p" '("poetry" . poetry)))

#+end_src
*** Numpy Docstring
#+begin_src emacs-lisp
(use-package numpydoc
  :after python-mode
  :init
  (after! yasnippet
          (setq numpydoc-insertion-style 'numpydoc))
  :config (my/local-leader-def-python-mode
           "d" '("generate docstring" . numpydoc-generate)))
#+end_src
** C/C++
#+begin_src emacs-lisp
(unless noninteractive
  (after! eglot
          (let ((val (list "clangd"
                           "--background-index"
                           "--log=error"
                           "--completion-style=detailed"
                           "--all-scopes-completion"
                           "--header-insertion-decorators"
                           "--header-insertion=iwyu"
                           "--function-arg-placeholders=true"
                           (format "-j=%d" my/available-cores)
                           "--clang-tidy"
                           "--enable-config")))
            (setf (alist-get 'c++-ts-mode eglot-server-programs) val)
            (setf (alist-get 'c-ts-mode eglot-server-programs) val)))
  (use-package c-ts-mode
    ;; builtin
    :ensure nil
    :mode
    (("\\.c\\'" . c-ts-mode)
     ("\\.h\\'" . c-or-c++-ts-mode))
    :hook (c-ts-mode . eglot-ensure)
    :hook (c-ts-mode . my/treesit-mode)
    :hook (c-ts-mode . (lambda () (run-hooks 'c-mode-hook)))
    :config
    (setq-default c-basic-offset 2))

  (use-package c++-ts-mode
    ;; builtin
    :ensure nil
    :mode
    (("\\.cpp\\'" . c++-ts-mode)
     ("\\.cc\\'" . c++-ts-mode)
     ("\\.hh\\'" . c++-ts-mode)
     ("\\.hpp\\'" . c++-ts-mode))
    :hook (c++-ts-mode . eglot-ensure)
    :hook (c++-ts-mode . my/treesit-mode)
    :hook (c++-ts-mode . (lambda () (run-hooks 'c++-mode-hook)))
    :config
    (setq-default c-basic-offset 2)))
#+end_src
** Rust
#+begin_src emacs-lisp
(use-package rustic
  :mode ("\\.rs$" . rustic-mode)
  :init
  (defun my/startup-rust ()
    (setq-local compile-command "cargo run")
    (when (boundp 'flycheck-checkers)
      (make-local-variable 'flycheck-checkers)
      (push 'rustic-clippy flycheck-checkers)))
  (add-hook 'rustic-mode-hook #'my/startup-rust)
  :config
  (setq rustic-lsp-client 'eglot)
  (add-hook 'rustic-mode-hook 'eglot-ensure)
  (setq rustic-indent-method-chain t)
  (my/local-leader-def rustic-mode
      "b" '("build" . nil)
      "b b" '("build" . rustic-cargo-build)
      "b r" '("run" . rustic-cargo-run)
      "b a" '("audit" . rustic-cargo-audit)
      "b t" '("test" . rustic-cargo-test)
      "b c" '("check" . rustic-cargo-check)
      "b d" '("doc" . rustic-cargo-build-doc)
      "b D" '("doc open" . rustic-cargo-doc)
      "b n" '("new" . rustic-cargo-new)
      "c" '("cargo" . nil)
      "c o" '("outdated" . rustic-cargo-outdated)
      "c a" '("add" . rustic-cargo-add)
      "c d" '("rm" . rustic-cargo-rm)
      "c A" '("add missing" . rustic-cargo-add-missing-dependencies)
      "m" '("macro expand" . rustic-cargo-expand)))
(use-package rustic-babel
  :ensure nil
  :after org
  :commands (org-babel-execute:rustic)
  :init
  (add-to-list 'org-src-lang-modes '("rust" . rustic))
  (add-to-list 'org-babel-tangle-lang-exts '("rustic" . "rs"))
  (defalias 'org-babel-execute:rust #'org-babel-execute:rustic))
#+end_src
** Lua
#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua$")
#+end_src
** Haskell
#+begin_src emacs-lisp
(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :mode ("\\.cabal\\'" . haskell-cabal-mode)
  :config
  (use-package haskell :ensure nil)
  (add-hook 'haskell-mode-hook 'eglot-ensure)
  (my/local-leader-def haskell-mode
      "b" 'haskell-process-cabal-build
      "c" 'haskell-cabal-visit-file
      "h" 'haskell-hide-toggle
      "H" 'haskell-hide-toggle-all))
(use-package ob-haskell
  :ensure nil
  :after org
  :commands org-babel-execute:haskell
  :init
  (add-to-list 'org-babel-load-languages '(haskell . t)))
#+end_src
** Julia
#+begin_src emacs-lisp
(use-package julia-mode
  :mode ("\\.jl\\'" . julia-mode)
  :config
  (add-hook 'julia-mode-hook #'eglot-ensure)
  (my/local-leader-def julia-mode
      "b" 'julia-repl-send-buffer
      "r" 'julia-repl-send-region-or-line
      "R" 'julia-repl
      "f" 'julia-repl-send-defun
      "l" 'julia-repl-send-line
      "s" 'julia-repl
      "S" 'julia-repl-switch)
  (defun my/julia-def ()
    (my/map-Open :keymaps 'local
                 "r" 'julia-repl-send-region-or-line
                 "f" 'julia-repl-send-defun
                 "l" 'julia-repl-send-line))
  (add-hook 'julia-mode-hook #'my/julia-def))
;; First use requires running 'import Pkg; Pkg.add("LanguageServer")' in the Julia REPL
#+end_src
*** REPL
#+begin_src emacs-lisp
(use-package julia-vterm
  :hook (julia-mode . julia-vterm-mode)
  :init (setq julia-vterm-repl-program (concat (executable-find "julia") " --color=yes --startup-file=no -t " (number-to-string my/available-cores)))
  :config
  (add-popup! "\\*julia:main\\*")
  (add-hook 'julia-mode-hook (lambda () (setf (alist-get 'julia-mode my/repl-alist) #'julia-vterm-repl))))
#+end_src
*** Babel
#+begin_src emacs-lisp
(use-package ob-julia-vterm
  :after org
  :commands org-babel-execute:julia-vterm
  :init
  (add-to-list 'org-babel-load-languages '(julia-vterm . t)))
#+end_src
** Kotlin
#+begin_src emacs-lisp
(use-package kotlin-ts-mode
  :hook (kotlin-ts-mode . eglot-ensure)
  :mode "\\.kts?\\'"
  :config
  (setenv "JAVA_OPTS" "-Xmx8g")
  (add-hook 'kotlin-ts-mode-hook
            (defun my/kotlin-ts-setup ()
              (setq-local
               read-process-output-max (* 16 1024 1024)
               eglot-autoshutdown t
               eglot-connect-timeout 300
               eglot-ignored-server-capabilities '(:documentFormattingProvider
                                                   :documentRangeFormattingProvider
                                                   :documentOnTypeFormattingProvider
                                                   :documentHighlightProvider))))
  (after! eglot
          (add-to-list 'eglot-server-programs '(kotlin-ts-mode "kotlin-language-server")))
  (defun my/gradlew-command (command)
    "Run gradlew in this project."
    (interactive "Command: ")
    (let ((default-directory (locate-dominating-file buffer-file-name "gradlew"))
          (compilation-read-command nil)
          (compile-command (format "sh gradlew %s" command)))
      (call-interactively #'compile)))
  (my/local-leader-def kotlin-ts-mode
      "t t"  '("go to test" . kotlin-ts-mode-goto-test-file)
      "t r"  '("run test function" . kotlin-ts-mode-run-current-test-function)
      "t R"  '("run test class" . kotlin-ts-mode-run-current-test-class)
      "t a" '("gradlew test" . (lambda () (interactive) (my/gradlew-command "test")))

      "a" '("gradlew assemble" . (lambda () (interactive) (my/gradlew-command "assemble")))
      "b" '("gradlew build" . (lambda () (interactive) (my/gradlew-command "build")))
      "r" '("gradlew run" . (lambda () (interactive) (my/gradlew-command "run")))))

(use-package flycheck-kotlin
  :hook (kotlin-ts-mode . flycheck-kotlin-setup))

(use-package java-imports
  :hook (kotlin-ts-mode . java-imports-scan-file)
  :custom
  (java-imports-find-block-function 'java-imports-find-place-sorted-block))
(use-package flymake-ktlint
  :after kotlin-ts-mode
  :custom
  (ktlint-flymake-args '("--android")))
#+end_src
** Java
#+begin_src emacs-lisp
(use-package java-ts-mode
  :ensure nil
  :hook (java-ts-mode . (lambda () (run-hooks 'java-mode-hook)))
  :hook (java-mode . eglot-ensure)
  :config
  (unless noninteractive
    (after! eglot
            (let ((args
                   (format
                    "--add-modules=ALL-SYSTEM
                  -data %s
                  --add-opens java.base/java.util=ALL-UNNAMED
                  --add-opens java.base/java.lang=ALL-UNNAMED
                  -XX:+UseAdaptiveSizePolicy
                  -XX:GCTimeRatio=4
                  -XX:AdaptiveSizePolicyWeight=90
                  --jvm-arg=-XX:+UseG1GC
                  --jvm-arg=-XX:+UseStringDeduplication
                  -Xmx32G
                  -Xms2G
                  -Xverify:none" (expand-file-name "java-worskpace" my/cache-dir)))
                  (init-options `(:settings
                                  (:java
                                   (:imports
                                    (:gradle
                                     (:wrapper
                                      (:checksums
                                       [
                                        ]
                                       ))))
                                   (:configuration
                                    :format (:settings (:url ,(expand-file-name (locate-user-emacs-file "cache/eclipse-java-google-style.xml"))
                                                             :profile "GoogleStyle"))
                                    :autobuild (:enabled t)
                                    :contentProvider (:preferred "fernflower"))
                                   )
                                  :extendedClientCapabilities (:classFileContentsSupport t)
                                  :bundles ,(let ((bundles-dir (expand-file-name (locate-user-emacs-file "cache/language-server/java/bundles" user-emacs-directory)))
                                                  jdtls-bundles)
                                              (->> (when (file-directory-p bundles-dir)
                                                     (directory-files bundles-dir t "\\.jar$"))
                                                   (append jdtls-bundles)
                                                   (apply #'vector)))
                                  )))
              (setf (alist-get 'java-ts-mode eglot-server-programs) `(,(or (executable-find "jdtls") "jdtls")  :initializationOptions ,init-options))
              (setf (alist-get 'java-mode eglot-server-programs) `(,(or (executable-find "jdtls") "jdtls") :initializationOptions ,init-options))))))
#+end_src
** PDF
#+begin_src emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq pdf-view-use-scaling t)
  (add-hook 'pdf-view-mode-hook #'my/disable-line-numbers)
  (add-to-list 'recentf-exclude "/**/*.pdf")
  (after! undo-tree
          (add-to-list 'undo-tree-incompatible-major-modes 'pdf-view-mode)))
#+end_src
** Shell
#+begin_src emacs-lisp
(use-package sh-script
  :ensure nil
  :mode ("\\.zsh\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.zshrc\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.sh\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :mode ("\\.bashrc\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :config
  (setq sh-basic-offset 4
        sh-indentation 4))
#+end_src
*** Org Babel
#+begin_src emacs-lisp
(use-package ob-shell
  :ensure nil
  :after org
  :custom
  (org-babel-shell-results-defaults-to-output t)
  (org-babel-default-header-args:sh '((:session . nil))))
#+end_src
** Soong mode
#+begin_src emacs-lisp
(use-package soong-mode
  :mode "\\.bp\\'")
#+end_src
** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile.*\\'" . dockerfile-mode))

(use-package docker
  :commands docker
  :init (my/map-Open "!" '("Container" . docker)))
#+end_src
** Latex
Mostly only used for double checking after org export.
#+begin_src emacs-lisp
(use-package auctex
  :after org
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((latex . t))))

(use-package reftex
  :after auctex
  :ensure nil
  :hook (LaTeX-mode . turn-on-reftex))

(use-package cdlatex
  :hook (org-mode . org-cdlatex-mode)
  :hook (LaTeX-mod . turn-on-cdlatex))
#+end_src
** Markdown Mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("README\\.md\\'" . gfm-mode)
  :mode ("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode)
  :init (setq markdown-enable-math t))
#+end_src
*** Poly mode
#+begin_src emacs-lisp
(use-package poly-markdown
  :unless noninteractive
  :commands poly-org-mode
  :after markdown
  :hook (markdown-mode-hook . poly-markdown-mode))
#+end_src
** Yaml
#+begin_src emacs-lisp
(use-package yaml-ts-mode :mode "\\.ya?ml\\'"
  :ensure nil
  :config
  (after! org
   (add-to-list 'org-babel-load-languages '(yaml . t))))

(use-package yaml-pro
  :hook (yaml-ts-mode . yaml-pro-ts-mode)
  :config
  (defun yaml-pro-edit-initialize-buffer-filter-args-advice (args)
    (if-let ((mode (language-detection-detect-mode (buffer-string))))
        (cl-destructuring-bind (parent-buffer buffer initial-text type initialize path) args
          (let ((init-func (lambda ()
                             (funcall mode)
                             (when initialize
                               (call-interactively initialize)))))
            (list parent-buffer buffer initial-text type init-func path)))
      args))
  (advice-add 'yaml-pro-edit-initialize-buffer :filter-args #'yaml-pro-edit-initialize-buffer-filter-args-advice)

  :bind (:map yaml-pro-ts-mode-map
              ("C-c j" . yaml-pro-ts-move-subtree-down)
              ("C-c k" . yaml-pro-ts-move-subtree-up)
              ("C-c f" . yaml-pro-format)))
#+end_src
** CoNLL-U mode
#+begin_src emacs-lisp
(use-package conllu-mode
  :mode "\\.conllu\\'")
  #+end_src emacs-lisp
* Mail
** mu4e
#+begin_src emacs-lisp :lexical t
(defun my/get-mail-dir ()
  (expand-file-name "mail/" (getenv "XDG_DATA_HOME")))

(defconst my/mail-dir (my/get-mail-dir))
;; Only load on personal machines with mail
(defconst my/enable/mu4e (and (not noninteractive) IS-PERSONAL (file-directory-p my/mail-dir)))

(use-package mu4e
  :if my/enable/mu4e
  :commands mu4e
  :init
  (add-to-list 'recentf-exclude my/mail-dir)
  (my/map-Open "m" '("Email" . mu4e))
  :config
  (my/local-leader-def mu4e-headers-mode
      "u" '("Update" . mu4e-update-mail-and-index))
  ;; Context switching for multiple accounts
  (defun my/create-mu4e-context (name address signature server &optional key)
    (unless key (setq key (substring name 0 1)))
    (make-mu4e-context
     :name (format "%s(%s)" key name)
     :enter-func (lambda () (mu4e-message "Entering context %s" name))
     :leave-func (lambda () (mu4e-message "Leaving context %s" name))
     :match-func (lambda (msg)
                   (when msg
                     (string-prefix-p (format "/%s" address)
                                      (mu4e-message-field msg :maildir))))
     :vars `((user-mail-address . ,address)
             (user-full-name . ,user-full-name)
             (mu4e-compose-signature . ,(if (package-installed-p 'org-msg) signature))
             (mu4e-sent-folder . ,(format (if (s-contains? "gmail" address) "/%s/[Gmail]/Sent Mail" "/%s/Sent") name))
             (mu4e-drafts-folder . ,(format "/%s/[Gmail]/Drafts" name))
             (mu4e-trash-folder . ,(format "/%s/[Gmail]/Trash" name))
             (mu4e-refile-folder . ,(format "/%s/Archive" name))
             (smtpmail-smtp-user . ,address)
             (smtpmail-smtp-server . ,server)
             (smtpmail-smtp-service . 587)
             (smtpmail-stream-type . starttls)
             (smtpmail-debug-info . t)
             (smtpmail-debug-verb . t))))
  (defun my/wrap-signature (str)
    (concat
     "#+begin_signature\n"
     str
     "\n#+end_signature"))
  (defun my/gmail-signature (name)
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: " name "@gmail.com\n")))
  (defun my/udmercy-signature ()
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: bakheakm@udmercy.edu")))

  (setq
   mail-user-agent 'mu4e-user-agent
   read-mail-command 'mu4e
   mu4e-maildir my/mail-dir
   mu4e-confirm-quit nil
   ;; This is set to 't' to avoid mail syncing issues when using mbsync
   mu4e-change-filenames-when-moving t

   ;; Refresh mail using isync every 10 minutes
   mu4e-update-interval (* 10 60)
   mu4e-get-mail-command "mbsync -a"

   ;; Context policy
   mu4e-context-policy 'pick-first
   mu4e-compose-context-policy 'ask
   mu4e-contexts (list
                  (my/create-mu4e-context "kbakheat-gmail" "kbakheat@gmail.com" (my/gmail-signature "kbakheat") "smtp.gmail.com")
                  (my/create-mu4e-context "kirolsb5-gmail" "kirolsb5@gmail.com" (my/gmail-signature "kirolsb5") "smtp.gmail.com" "a")
                  (my/create-mu4e-context "bakheakm-udmercy" "bakheakm@udmercy.edu" (my/udmercy-signature) "smtp.office365.com"))))


(use-package mu4e-alert
  :if my/enable/mu4e
  :after mu4e
  :config
  (when IS-LINUX
    (progn (mu4e-alert-set-default-style 'libnotify)
           (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (when IS-MAC
    (progn (mu4e-alert-set-default-style 'notifier)
           (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src
** msmtp
#+begin_src emacs-lisp
(after! mu4e
        (setq message-send-mail-function #'message-send-mail-with-sendmail
              sendmail-program (executable-find "msmtp")
              send-mail-function #'smtpmail-send-it
              message-sendmail-f-is-evil t
              message-sendmail-extra-arguments '("--read-envelope-from")))
#+end_src
** Compose mail with org mode
#+begin_src emacs-lisp
(use-package org-msg
  :if my/enable/mu4e
  :after (org mu4e)
  :config (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
                org-msg-startup "hidestars indent inlineimages"
                org-msg-greeting-fmt "\nHey%s,\n\n"
                org-msg-greeting-name-limit 3
                org-msg-default-alternatives '((new             . (text html))
                                               (reply-to-html   . (text html))
                                               (reply-to-text   . (text)))
                org-msg-convert-citation t
                org-msg-signature "")
  (org-msg-mode))
#+end_src
* Org Mode
#+begin_src emacs-lisp
(use-package org
  :ensure nil ;; included in emacs
  :commands org-mode
  :mode ("\\.org\\'" . org-mode)
  :config
  (require 'org-tempo)
  (dolist (scheme '("ftp" "http" "https" "mailto" "news"))
    (org-link-set-parameters scheme
                             :follow
                             `(lambda (url arg)
                                (browse-url (concat ,scheme ":" url) arg))))
  :init
  (defun my/relative-org (dir)
    "Makes a sting representing a directory relative to my org base directory"
    (setq my-org-base-dir "~/org")
    (concat (file-name-as-directory my-org-base-dir) dir))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        org-directory (my/relative-org "general/")
        org-insert-heading-respect-content t
        org-export-in-background t
        org-export-with-sub-superscripts '{}
        org-pretty-entities t
        org-pretty-entities-include-sub-superscripts t
        org-list-allow-alphabetical t
        org-catch-invisible-edits 'smart
        org-special-ctrl-a/e t
        org-return-follows-link t
        org-export-backends '(latex beamer html ascii)

        browse-url-browser-function (cond
                                     (IS-MAC #'browse-url-default-macosx-browser)
                                     (IS-LINUX #'browse-url-xdg-open))))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(after! (org smartparens)
        (add-hook 'org-mode-hook #'smartparens-mode)
        (sp-local-pair 'org-mode "\\[" "\\]")
        (sp-local-pair 'org-mode "\\(" "\\)")
        (sp-local-pair 'org-mode "$" "$"))
#+end_src
** Org Modern
#+begin_src emacs-lisp
(use-package org-modern
  :hook (org-mode . org-modern-mode)
  :custom
  (org-modern-star 'replace)
  (org-modern-replace-stars "◉○◈◇✳"))
#+end_src
** Keybindings
#+begin_src emacs-lisp
(use-package org
  :config
  (my/local-leader-def org-mode
      "#" #'org-update-statistics-cookies
      "'" #'org-edit-special
      "*" #'org-ctrl-c-star
      "+" #'org-ctrl-c-minus
      "," #'org-switchb
      "@" #'org-cite-insert
      "." #'consult-org-heading
      "/" #'counsel-org-goto-all
      "A" #'org-archive-subtree
      "e" #'org-export-dispatch
      "f" #'org-footnote-action
      "h" #'org-toggle-heading
      "i" #'org-toggle-item
      "I" #'org-id-get-create
      "k" #'org-babel-remove-result
      "n" #'org-store-link
      "o" #'org-set-property
      "q" #'org-set-tags-command
      "t" #'org-todo
      "T" #'org-todo-list
      "x" #'org-toggle-checkbox

      "a" '("attachments" . nil)
      "a a" 'org-attach
      "a d" 'org-attach-delete-one
      "a D" 'org-attach-delete-all
      "a f" '+org/find-file-in-attachments
      "a l" '+org/attach-file-and-insert-link
      "a n" 'org-attach-new
      "a o" 'org-attach-open
      "a O" 'org-attach-open-in-emacs
      "a r" 'org-attach-reveal
      "a R" 'org-attach-reveal-in-emacs
      "a u" 'org-attach-url
      "a s" 'org-attach-set-directory
      "a S" 'org-attach-sync

      "b" '("tabels" . nil)
      "b -" 'org-table-insert-hline
      "b a" 'org-table-align
      "b b" 'org-table-blank-field
      "b c" 'org-table-create-or-convert-from-region
      "b e" 'org-table-edit-field
      "b f" 'org-table-edit-formulas
      "b h" 'org-table-field-info
      "b s" 'org-table-sort-lines
      "b r" 'org-table-recalculate
      "b R" 'org-table-recalculate-buffer-tables

      "b d" '("delete" . nil)
      "b d c" 'org-table-delete-column
      "b d r" 'org-table-kill-row

      "b i" '("insert" . nil)
      "b i c" 'org-table-insert-column
      "b i h" 'org-table-insert-hline
      "b i r" 'org-table-insert-row
      "b i H" 'org-table-hline-and-move

      "l" '("links" . nil)
      "l c" 'org-cliplink
      "l d" '+org/remove-link
      "l i" 'org-id-store-link
      "l l" 'org-insert-link
      "l L" 'org-insert-all-links
      "l s" 'org-store-link
      "l S" 'org-insert-last-stored-link
      "l t" 'org-toggle-link-display
      "l g" '(org-mac-link-get-link :if IS-MAC)


      "s" '("subtree" . nil)
      "s a" 'org-toggle-archive-tag
      "s b" 'org-tree-to-indirect-buffer
      "s c" 'org-clone-subtree-with-time-shift
      "s d" 'org-cut-subtree
      "s h" 'org-promote-subtree
      "s j" 'org-move-subtree-down
      "s k" 'org-move-subtree-up
      "s l" 'org-demote-subtree
      "s n" 'org-narrow-to-subtree
      "s r" 'org-refile
      "s s" 'org-sparse-tree
      "s A" 'org-archive-subtree
      "s N" 'widen
      "s S" 'org-sort))
#+end_src
** Agenda
#+begin_src emacs-lisp
(use-package org-gcal
  :after org-agenda
  :unless noninteractive
  :if (and IS-PERSONAL (executable-find "pass") (file-exists-p (concat (getenv "PASSWORD_STORE_DIR") "/google.com/api/client_secret.gpg")))
  :commands (org-gcal-sync)
  :init (my/map-Open
         "a" '("agenda" . org-gcal-sync))
  :custom
  (org-gcal-client-id (auth-source-pass-get 'secret "google.com/api/client_id"))
  (org-gcal-client-secret (auth-source-pass-get 'secret "google.com/api/client_secret"))
  (org-gcal-fetch-file-alist `(("kbakheat@gmail.com" . ,(my/relative-org "/agenda/google.org"))))
  (org-gcal-notify-p t)
  (org-gcal-recurring-events-mode 'nested)
  (oauth2-auto-plstore (concat my/etc-dir "oauth2-auto.plist"))
  :config
  (cl-loop for (key . value) in org-gcal-file-alist
           do (append! org-agenda-files value))
  (unless (file-exists-p oauth2-auto-plstore) (f-touch oauth2-auto-plstore))
  (use-package plstore
    :ensure nil
    :config (add-to-list 'plstore-encrypt-to "kbakheat@gmail.com")))
#+end_src
** Presenting
#+begin_src emacs-lisp
(use-package visual-fill-column
  :unless noninteractive
  :hook (org-present . visual-fill-column)
  :hook (org-present . visual-fill-line)
  :custom
  (visual-fill-column-width 110)
  (visual-fill-column-center-text t))
(use-package org-present
  :unless noninteractive
  :commands (org-present)
  :config
  ;; enable list of modes in org present then disable on quit
  (add-hook 'org-present-mode-hook
            (lambda ()
              (org-present-big)
              (org-display-inline-images)
              (org-present-hide-cursor)
              (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
            (lambda ()
              (org-present-small)
              (org-remove-inline-images)
              (org-present-show-cursor)
              (org-present-read-write))))
#+end_src
** LilyPond
#+begin_src emacs-lisp
(use-package lilypond-mode
  :ensure nil ;; Comes with lilypond, installed with nix
  :preface (defvar my/lilypond (executable-find "lilypond"))
  :mode ("\\.ly\\'" . LilyPond-mode)
  :commands (LilyPond-mode)
  :if my/lilypond
  :init (defalias 'lilypond-mode 'LilyPond-mode))
(use-package ob-lilypond
  :ensure nil
  :after (org lilypond-mode)
  :commands (org-babel-lilypond-tangle org-babel-execute:lilypond)
  :if my/lilypond
  :config
  ;; org-babel-lilypond-commands is a list of strings. We set just the first one to lilypond
  (setf (car org-babel-lilypond-commands) (executable-find "lilypond"))
  (setopt org-babel-lilypond-commands org-babel-lilypond-commands)
  (add-to-list 'org-babel-load-languages '(lilypond . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Org Previews
#+begin_src emacs-lisp
(after! org
        ;; Latex fragments
        (add-hook 'org-mode-hook #'org-latex-preview)
        (setopt org-preview-latex-image-directory (expand-file-name "org-preview-ltximg/" my/cache-dir)
                org-preview-latex-default-process 'dvisvgm)
        (plist-put org-format-latex-options :scale 2)
        ;; Images
        (add-hook 'org-mode-hook #'org-display-inline-images)
        (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images))
#+end_src
** Notes
#+begin_src emacs-lisp
(my/map-menu! "Notes" "n")
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :unless noninteractive
  :commands (deft)
  :custom
  (deft-directory (my/relative-org "deft"))
  (deft-recursive t)
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t)
  (deft-extensions '("org" "md" "txt"))
  (deft-default-extension "org")
  (deft-file-naming-rules '((noslash . "-")
                            (nospace . "-")
                            (case-fn . downcase)))
  (deft-text-mode 'org-mode)
  :config
  (add-popup! "\\*Deft\\*")
  :init (my/map-Notes
         "d" '("deft" . deft)))
#+end_src
*** Roam
#+begin_src emacs-lisp
(use-package org-roam
  :unless noninteractive
  :after org
  :custom
  (org-roam-v2-ack t)
  (org-roam-directory (my/relative-org "roam"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(
     <<roam-templates>>
     ))
  :init (my/map-Notes
         "r" '("roam" . nil)
         "rf" '("find" . org-roam-node-find)
         "ri" '("insert" . org-roam-node-insert)
         "rg" '("graph" . org-roam-graph)
         "rt" '("today" . org-roam-dailies-find-today)
         "ry" '("yesterday" . org-roam-dailies-find-yesterday)
         "rr" '("tomorrow" . org-roam-dailies-find-tomorrow)
         "rd" '("date" . org-roam-dailies-find-date)
         "rc" '("capture today" . org-roam-dailies-capture-today)
         "rC" '("capture tomorrow" . org-roam-dailies-capture-tomorrow)
         "rD" '("capture date" . org-roam-dailies-capture-date)
         "rl" '("toggle display" . org-roam-buffer-toggle-display)
         "rL" '("display dedicated" . org-roam-buffer-display-dedicated)
         "rs" '("sync" . org-roam-db-sync)
         "rS" '("server" . org-roam-server-mode)))
#+end_src
**** Templates
:PROPERTIES:
:header-args: :tangle no :noweb-ref roam-templates
:END:
***** Religious
#+begin_src emacs-lisp
("r" "Templates for religious meditations")
#+end_src
****** Bible
#+begin_src emacs-lisp
("rb" "Bible Study" plain "#+filetags: \"bible study\" \"Book: ${book}\" \"Topic: ${topic}\"\n\n* Topic\n\n* Related\n** Passages\n\n** Meditations\n\n* Personal Meditation\n\n"
 :if-new (file+head "religious/bible-study/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Saint
#+begin_src emacs-lisp
("rs" "Saint" plain "#+filetags: saint \"Saint Type: ${saint type}\" \"Years: ${birth year}-${death year}\" \"Country: ${country}\" \"City: ${city}\"\n\n* Birth\n%?\n\n* Life\n\n\n* Death\n\n\n* Related saints\n\n"
 :if-new (file+head "religious/saints/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Lesson
#+begin_src emacs-lisp
("rl" "Lesson" plain "#+filetags: lesson \"Topic: ${topic}\"\n* %?"
 :if-new (file+head "religious/lessons/%<%Y%m%d%H%M%S>-${slug}.org"
                    "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
***** Generic
****** Default
#+begin_src emacs-lisp
("d" "Default" plain "#+filetags: \"${mtags}\"\n\n* %?"
 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
****** Project
#+begin_src emacs-lisp
("p" "Project" plain "#+filetags: project\n\n* %?"
 :if-new (file+head "projects/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: project ${field}\n\n")
 :unnarrowed t)
#+end_src
** Babel
#+begin_src emacs-lisp
(use-package org
  :config
  (add-popup! '("^\\*Org-Babel Error Output\\*$" . hide))
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'current-window
        org-src-preserve-indentation t
        org-src-strip-leading-and-trailing-blank-lines t
        org-src-ask-before-returning-to-edit-buffer nil
        org-babel-load-languages '((emacs-lisp . t))
        org-babel-default-header-args '((:session . "default")
                                        (:results . "replace")
                                        (:mkdirp . "yes")
                                        (:exports . "both")
                                        (:cache . "yes")
                                        (:noweb . "yes")
                                        (:hlines . "no")
                                        (:tangle . "no")
                                        (:padnewline . "yes")
                                        (:eval . "never-export")
                                        (:comments . "link")))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Auto Tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :custom (org-auto-tangle-default t)
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Export
*** =ox-latex=
#+begin_src emacs-lisp
(use-package ox-latex
  :ensure nil
  :after org
  :config
  (setq org-latex-compiler "xelatex")
  (add-to-list 'org-latex-logfiles-extensions "tex")
  (add-to-list 'org-latex-packages-alist '("" "siunitx"))
  (add-to-list 'org-latex-packages-alist '("" "amsmath"))
  (add-to-list 'org-latex-packages-alist '("" "fancyhdr"))
  (add-to-list 'org-latex-classes
               '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" .    "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("exam"
                 "\\documentclass{exam}"
                 ("\\begin{questions} %% %s"
                  "\\end{questions}"
                  "\\begin{questions} %% %s"
                  "\\end{questions}")
                 ("\\question %s " . "\\question* %s")
                 ("\\begin{parts} %s"
                  "\\end{parts}"
                  "\\begin{parts} %s"
                  "\\end{parts}"))))
#+end_src
*** =ox-html=
#+begin_src emacs-lisp
(use-package ox-html
  :ensure nil
  :after org)
#+end_src
*** =ox-chameleon=
#+begin_src emacs-lisp
(use-package ox-chameleon
  :ensure nil
  :after org
  :config
  (add-to-list 'org-latex-packages-alist '("" "scrextend" nil))
  (add-to-list 'org-latex-packages-alist '("" "xcolor" nil))
  (after! org-msg
          (setq org-msg-options (concat org-msg-options " html-content-class: chameleon "))))
#+end_src
*** Async patch
#+begin_src emacs-lisp
(when (not noninteractive)
  (after! ox
          (setq org-export-async-init-file (make-temp-file "org-export-async-init-file" nil ".el"))
          (defun my/get-loaded-nix-file (name)
            (car (load-history-filename-element
                  (concat
                   "^/nix/store/.*emacs-packages-deps/share/emacs/site-lisp/"
                   name
                   "\\.elc?\\(\\.gz\\)?$"))))

          (with-temp-file org-export-async-init-file
            (mapc (lambda (s)
                    (insert (format "(load \"%s\")\n" s)))
                  (-select #'identity
                           (list
                            (my/get-loaded-nix-file "site-start")
                            (my/get-loaded-nix-file "subdirs")
                            (my/get-loaded-nix-file "default")
                            (my/get-loaded-nix-file "init"))))
            (insert (format "(setq engrave-faces-preset-styles '%S)\n" engrave-faces-preset-styles))
            (insert (format "(setq engrave-faces-themes '%S)\n" engrave-faces-themes))
            (insert (format "(setq load-path '%S)\n" load-path))
            (insert (format "(setq exec-path '%S)\n" exec-path)))))
#+end_src
*** Syntax Highlighting
#+name: engrave-faces-init
#+begin_src emacs-lisp :tangle no
;;; Definers
(eval-and-compile
  (defmacro defadvice! (symbol arglist &optional docstring &rest body)
    "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
    (declare (doc-string 3) (indent defun))
    (unless (stringp docstring)
      (push docstring body)
      (setq docstring nil))
    (let (where-alist)
      (while (keywordp (car body))
        (push `(cons ,(pop body) (ensure-list ,(pop body)))
              where-alist))
      `(progn
         (defun ,symbol ,arglist ,docstring ,@body)
         (dolist (targets (list ,@(nreverse where-alist)))
           (dolist (target (cdr targets))
             (advice-add target (car targets) #',symbol))))))
  (defvar-local org-export-has-code-p nil)

  (defadvice! org-export-expect-no-code (&rest _)
    :before #'org-export-as
    (setq org-export-has-code-p nil))

  (defadvice! org-export-register-code (&rest _)
    :after #'org-latex-src-block
    :after #'org-latex-inline-src-block-engraved
    (setq org-export-has-code-p t))

  (defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
    "Like `org-latex-example-block', but supporting an engraved backend"
    :around #'org-latex-example-block
    (let ((output-block (funcall orig-fn example-block contents info)))
      (if (eq 'engraved (plist-get info :latex-listings))
          (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
        output-block))))
#+end_src
#+begin_src emacs-lisp
;; both installed by engrave-faces
(use-package engrave-faces-latex
  :ensure engrave-faces
  :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
(use-package engrave-faces-html
  :ensure engrave-faces
  :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
#+end_src
** Nix Shell
#+begin_src emacs-lisp
(use-package org-nix-shell
  :hook (org-mode . org-nix-shell-mode))
#+end_src
** Evil Org
#+begin_src emacs-lisp
(use-package evil-org
  :unless noninteractive
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :config
  (use-package evil-org-agenda :ensure nil)
  (evil-org-agenda-set-keys)
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme)))
  (use-package evil-org-agenda :ensure nil)
  (evil-org-agenda-set-keys))
#+end_src
** Org Src
#+begin_src emacs-lisp
(use-package org-src-context
  :after org
  :init (my/local-leader-def-org-mode
         "S" '("src LSP" . org-src-context-mode)))
#+end_src
** Poly Org
#+begin_src emacs-lisp
(use-package poly-org
  :unless noninteractive
  :commands poly-org-mode
  :after org
  :init
  (my/local-leader-def-org-mode
   "p" '("poly-org-mode" . poly-org-mode)))
#+end_src
* Footer
#+begin_src emacs-lisp
(provide 'default)
#+end_src
# Local Variables:
# org-use-property-inheritance: t
# End:
