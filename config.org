* Setup
#+property: header-args :tangle default.el :results output silent :noweb yes :lexical t :eval never-export
#+startup: fold
#+auto_tangle: t
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
<<variables>>
#+end_src
** Requires
#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src
** Basic variables
:PROPERTIES:
:header-args: :tangle no :noweb-ref variables
:END:
*** System type
#+begin_src emacs-lisp
(eval-and-compile
  (defconst IS-MAC      (eq system-type 'darwin))
  (defconst IS-LINUX    (memq system-type '(gnu gnu/linux gnu/kfreebsd berkeley-unix)))
  (defconst IS-WINDOWS  (memq system-type '(cygwin windows-nt ms-dos)))
  (defconst IS-BSD      (memq system-type '(darwin berkeley-unix gnu/kfreebsd)))
  ;; personal or work
  (defconst IS-PERSONAL t)
  (defconst IS-WORK     (not IS-PERSONAL))
  (defconst my/available-cores
    (string-to-number
     (shell-command-to-string (if (eq system-type 'darwin)
				  "sysctl -n hw.ncpu"
				"nproc --all")))))
#+end_src
*** Directories
#+begin_src emacs-lisp
(eval-and-compile
  (defvar my/local-dir (expand-file-name ".local/" user-emacs-directory)
    "Default local directory.")
  (if-let ((local-dir (getenv "XDG_DATA_HOME")))
      (setq my/local-dir (expand-file-name "emacs/" local-dir)))
  (defvar my/cache-dir (expand-file-name "cache/" my/local-dir)
    "Default cache directory.")
  (if-let ((cache-dir (getenv "XDG_CACHE_HOME")))
      (setq my/cache-dir (expand-file-name "emacs/" cache-dir)))
  (defvar my/etc-dir (expand-file-name "etc/" my/local-dir)
    "Default etc directory.")
  (defvar my/emacs-dir user-emacs-directory
    "Default emacs directory."))

(make-directory my/local-dir t)
(make-directory my/cache-dir t)
#+end_src
*** Personal info
#+begin_src emacs-lisp
(eval-and-compile
  (setq user-full-name "Kirols Bakheat"
	user-mail-address "kbakheat@gmail.com"))
#+end_src

*** Indent Tabs
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src
** Macros
*** ~after!~
#+begin_src emacs-lisp
(cl-defmacro after! (features &rest body)
  "A smart wrapper around `with-eval-after-load'"
  (if (listp features)
      (pcase (length features)
	(0 `(progn ,@body))
	(1 `(with-eval-after-load (quote ,(car features))
	      (progn
		,@body)))
        (_ (if (eq (car features) 'or)
               `(progn
                  ,@(cl-map 'list
                           (lambda (feature)
                             `(after! ,feature ,@body))
                           (cdr features)))
             `(with-eval-after-load (quote ,(car features))
                (after! ,(cdr features) ,@body)))))
    `(with-eval-after-load (quote ,features)
       (progn ,@body))))
#+end_src
*** ~append!~
#+begin_src emacs-lisp
(cl-defmacro append! (var &rest values)
  "Append VALUES to the end of VAR, if they don't already exist in VAR."
  (declare (indent defun))
  `(dolist (value (list ,@values))
     (unless (member value ,var)
       (setf ,var (append ,var (list value))))))
#+end_src
*** ~add-popup!~
#+begin_src emacs-lisp
(eval-and-compile
  (cl-defmacro add-popup! (&rest rules)
    "Add popup rules."
    `(after! popper
	     (append! popper-reference-buffers ,@rules)
	     (popper--set-reference-vars))))
#+end_src
** Startup
#+begin_src emacs-lisp
(defun my/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'my/display-startup-time)
#+end_src
** gcmh
#+begin_src emacs-lisp
(use-package gcmh
  :unless noninteractive
  :demand
  :hook
  (focus-out-hook . gcmh-idle-garbage-collect)
  :config
  (gcmh-mode +1))
#+end_src
** Hooks
#+begin_src emacs-lisp
(defun my/disable-line-numbers ()
  (display-line-numbers-mode -1)
  (setq-local display-line-numbers nil))
#+end_src
** no-littering
#+begin_src emacs-lisp
(use-package no-littering
  :config
  (setq no-littering-etc-directory (expand-file-name "etc/" my/local-dir)
        no-littering-var-directory (expand-file-name "var/" my/local-dir)
        custom-file (no-littering-expand-etc-file-name "custom.el"))
  (load custom-file 'noerror 'nomessage))
#+end_src
** History
*** recentf
#+begin_src emacs-lisp
(use-package recentf
  :unless noninteractive
  :ensure nil
  :config
  (dolist (dir `("/nix/store/.*"
		 "/tmp/.*"
		 "/var/tmp/.*"
		 "/var/folders/.*"
		 "/private/tmp/.*"
		 "/private/var/.*"
		 "~/\\.cache.*"
		 ,(concat my/etc-dir ".*")
		 ,(concat my/local-dir ".*")
		 ,(concat my/cache-dir ".*")))
    (add-to-list 'recentf-exclude dir))
  (when-let ((dir (getenv "XDG_DATA_HOME")))
    (add-to-list 'recentf-exclude (concat dir "/.*")))
  (setq recentf-max-menu-items 100
	recentf-max-saved-items 100
	recentf-save-file (expand-file-name "recentf" my/local-dir))
  (recentf-mode 1))
#+end_src
*** savehist
#+begin_src emacs-lisp
(use-package savehist
  :unless noninteractive
  :ensure nil
  :config
  (setq savehist-file (expand-file-name "savehist" my/local-dir)
	savehist-save-minibuffer-history t
	savehist-autosave-interval 60
	savehist-additional-variables '(kill-ring
					search-ring
					regexp-search-ring))
  (savehist-mode 1))
#+end_src
*** saveplace
#+begin_src emacs-lisp
(use-package saveplace
  :unless noninteractive
  :ensure nil
  :config
  (setq save-place-file (expand-file-name "saveplace" my/local-dir))
  (save-place-mode 1))
#+end_src
** Custom file
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" my/etc-dir))
#+end_src
** Backup files
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" my/local-dir)))
      auto-save-file-name-transforms `((".*" ,(expand-file-name "auto-save/" my/local-dir) t)))
(use-package tramp
  :ensure nil
  :custom
  (tramp-backup-directory-alist nil)
  (tramp-verbose 0)
  (tramp-chunksize 2000)
  (tramp-use-ssh-controlmaster-options nil))
#+end_src
** Lockfiles
#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src
** Autosave
#+begin_src emacs-lisp
(setq auto-save-default nil)
#+end_src
** Auto-revert
#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode
  :config
  (setq auto-revert-verbose nil
        auto-revert-interval 2
        auto-revert-check-vc-info t
        auto-revert-remote-files t)
  (global-auto-revert-mode +1))
#+end_src
** Yes-or-No
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Authsources
#+begin_src emacs-lisp
(setq auth-sources (list (expand-file-name "authinfo.gpg" my/local-dir)))
(use-package auth-source-pass
  :ensure nil
  :unless noninteractive
  :defer t
  :config
  (auth-source-pass-enable))
#+end_src
** Window management
I want windows that start with '*' to be opened in the lower 1/3 of the frame. These windows should close when their buffer dies and should not be reused. If they are not in ~my/special-window-no-cursor-manage-alist~ then they should automatically grab the cursor.
#+begin_src emacs-lisp
(defvar my/special-window-no-cursor-manage-alist '("*Help*" "*Warnings*" "*Backtrace*" "*Messages*"))
#+end_src
** Proxy Settings
#+begin_src emacs-lisp
(defvar my/proxy nil
  "Proxy to use")
(when IS-WORK
  (setq my/proxy  "http://internet.ford.com:83")
  (setq url-using-proxy my/proxy
        url-proxy-services `(("http" . ,my/proxy)
                             ("https" . ,my/proxy)
                             ("ssh" . ,my/proxy)))
  (after! lsp-mode
          (setq lsp-http-proxy my/proxy)))
#+end_src
** Early init
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes :lexical t :eval never-export
:END:
#+begin_src emacs-lisp

<<variables>>

(setq comp-eln-cache-path (expand-file-name "eln-cache/" my/cache-dir)
      native-comp-async-report-warnings-errors 'silent
      native-comp-verbose 0)
#+end_src
*** Disable package.el
#+begin_src emacs-lisp
(setq package-enable-at-startup nil
      package-quickstart nil)
#+end_src
*** Garbage-collection
#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum ;; reset by gcmh
      gc-cons-percentage 0.6)
#+end_src
*** UI
#+begin_src emacs-lisp
(setq inhibit-startup-message t
      frame-inhibit-implied-resize t
      inhibit-splash-screen t
      use-file-dialog nil
      use-dialog-box nil
      display-line-numbers-type 'relative
      ring-bell-function 'ignore)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
(scroll-bar-mode -1)         ; Disable visible scrollbar
(tool-bar-mode -1)           ; Disable the toolbar
(tooltip-mode -1)            ; Disable tooltips
(set-fringe-mode '(20 . 10)) ; Give some breathing room
(menu-bar-mode -1)           ; Disable the menu bar

(column-number-mode)
(global-display-line-numbers-mode t)

(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
* Keybindings
** Basics
#+begin_src emacs-lisp
(cond
 (IS-MAC
  (define-key key-translation-map [S-iso-lefttab] [backtab])
  (setq mac-command-modifier      'meta
        ns-command-modifier       'meta
        mac-option-modifier       'meta
        ns-option-modifier        'meta
        mac-right-option-modifier 'super
        ns-right-option-modifier  'super))
 (IS-WINDOWS
  (setq w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super)))
;; Make ESC quit prompts
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq use-package-always-demand (daemonp)
      use-package-expand-minimally t
      use-package-verbose nil)
#+end_src
** general.el
*** Helpers
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
Macro to define nested keymaps
#+begin_src emacs-lisp
;; copied from https://github.com/progfolio/.emacs.d/blob/master/init.org
(defmacro my/general-global-menu! (name prefix-key &rest body)
  "Create a definer named +general-global-NAME wrapping global-definer.
  Create prefix map: +general-global-NAME-map. Prefix bindings in BODY with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n (concat "my/general-global-" name))
         (prefix-map (intern (concat n "-map"))))
    `(eval-and-compile
       (defvar ,prefix-map (make-sparse-keymap))
       (my/leader-def
	 ,prefix-key (cons ,name ,prefix-map))
       (general-create-definer ,(intern n)
	 :keymaps (quote ,prefix-map))
       (,(intern n)
	,@body))))
#+end_src
Do something in other window
#+begin_src emacs-lisp
(defun my/do-in-other-window (fn &rest args)
    (let ((buf (current-buffer)))
        (other-window 1)
        (apply fn args)
        (switch-to-buffer buf)))
#+end_src
**** Local Bindings
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
#+begin_src emacs-lisp :noweb-ref keybindings :tangle no
(cl-defmacro my/local-leader-def (mode &rest args)
  "Create a definer named +general-global-NAME wrapping global-definer.
Create prefix map: +general-global-NAME-map. Prefix bindings in BODY with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n  (symbol-name mode))
	 (definer (intern (concat "my/local-leader-def-" n)))
	 (prefix-map (intern (concat (symbol-name mode) "-map"))))
    `(eval-and-compile
       (general-create-definer ,definer
	 :states ,'my/prefix-states
	 :prefix ,(concat my/leader-def-prefix " " my/local-leader-def-prefix)
	 :non-normal-prefix ,(concat my/leader-def-prefix-alt " " my/local-leader-def-prefix)
	 :keymaps (quote ,prefix-map))
       (,definer
	,@args))))
#+end_src
*** general.el setup
#+begin_src emacs-lisp :noweb yes
(eval-and-compile
  (defvar my/leader-def-prefix "SPC"
    "Prefix for general.el leader keybindings.")
  (defvar my/leader-def-prefix-alt "M-SPC"
    "Alternative prefix for general.el leader keybindings.")
  (defvar my/local-leader-def-prefix "m"
    "Prefix for general.el local leader keybindings.
   Relative to `my/leader-def-prefix'.")
  (defvar my/prefix-states '(normal visual motion)
    "States in which to bind general.el leader keybindings."))

(eval-and-compile
  (use-package general
    :demand t
    :config
    (general-evil-setup)
    (general-override-mode 1)
    (general-auto-unbind-keys)
    (general-define-key
     :major-modes t
     :keymaps 'override
     :states my/prefix-states
     :prefix-map 'my/prefix-map
     :prefix my/leader-def-prefix
     :global-prefix my/leader-def-prefix-alt)

    (general-create-definer my/leader-def
      :keymaps 'my/prefix-map)

    (my/leader-def
      "SPC"	'("Find file" . project-find-file)
      "h"		(cons "Help" help-map)
      "H"		'("Help at point" . helpful-at-point)
      ";"		'("M-x" . execute-extended-command)
      ":"		'("Eval" . eval-expression)
      "."		'("Repeat" . repeat)
      "r"		'("Run command" . async-shell-command)
      "R"		'("Run command synchronously" . shell-command))
    <<keybindings>>
    (provide 'my/general)))
#+end_src
**** Assorted Keybindings
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
***** Quit
#+begin_src emacs-lisp
(my/general-global-menu! "Quit" "q"
  "q" '("Quit Emacs" . save-buffers-kill-terminal)
  "Q" '("Quit Emacs immediately" . kill-emacs)
  "r" '("Restart Emacs" . restart-emacs)
  "R" '("Restart Emacs daemon" . restart-emacs--daemon)
  "d" '("Restart Emacs with debug init" . restart-emacs-debug-init))
#+end_src
***** Buffer
#+begin_src emacs-lisp
(defun my/kill-buffer (&optional buf)
  (interactive)
  (let ((buf (or buf (current-buffer)))
        (kill-buffer-query-functions '()))
    (kill-buffer buf)))

(defun my/kill-other-window ()
  (interactive)
  (my/do-in-other-window (lambda () (progn (my/kill-buffer) (delete-window)))))
        

(my/general-global-menu! "Buffer" "b"
  "B" '("Switch buffer other window" . switch-to-buffer-other-window)
  "d" '("Kill current buffer" . kill-current-buffer)
  "k" '("Kill buffer" . my/kill-buffer)
  "K" '("Kill buffer other window" . my/kill-other-window)
  "r" '("Revert buffer" . revert-buffer)
  "[" '("Previous buffer" . previous-buffer)
  "]" '("Next buffer" . next-buffer)
  "n" '("Next buffer" . next-buffer)
  "p" '("Previous buffer" . previous-buffer)
  "s" '("Save buffer" . save-buffer)
  "S" '("Save some buffers" . save-some-buffers)
  "u" '("Bury buffer" . bury-buffer)
  "U" '("Unbury buffer" . unbury-buffer)
  "x" '("Open scratch buffer" . scratch-buffer))
(my/leader-def
  "x" '("Open scratch buffer" . scratch-buffer))
#+end_src
***** Code
#+begin_src emacs-lisp
(my/general-global-menu! "Code" "c"
  "c" '("Recompile" . recompile)
  "C" '("Compile" . compile))
#+end_src
***** File
#+begin_src emacs-lisp
(defun my/find-file-other-window ()
  (interactive)
  (my/do-in-other-window #'find-file))
(defun my/find-file-sudo ()
  (interactive)
  (let ((file-name (read-file-name "Find file (as root): ")))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(defun my/this-file-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(my/general-global-menu! "File" "f"

  "f" '("Find file" . find-file)
  "F" '("Find file other window" . find-file-other-window)
  "s" '("Save buffer" . save-buffer)
  "S" '("Save file as" . write-file)
  "r" '("Recent files" . recentf-open-files)
  "R" '("Rename file" . rename-file)
  "d" '("Delete file" . delete-file)
  "u" '("Find file as root" . my/find-file-sudo)
  "U" '("Open this file as root" . my/this-file-sudo))
#+end_src
***** Git
#+begin_src emacs-lisp
(my/general-global-menu! "Git" "g")
#+end_src
***** Open
#+begin_src emacs-lisp
(defvar my/open-proc (cond (IS-MAC "open")
                           (IS-LINUX "xdg-open"))
  "The defualt process to open files with.")
(defun my/default-open (file)
  (interactive)
  (start-process my/open-proc nil my/open-proc file))

(my/general-global-menu! "Open" "o"
                         "o" '("Open file" . (lambda () (interactive) (my/default-open (buffer-file-name))) )
                         "s" '("Shell" . shell))
#+end_src
***** REPL
#+begin_src emacs-lisp
(defvar my/repl-alist '((emacs-lisp-mode . ielm)
                        (fallback . my/repl-fallback))
  "Alist of modes to repls.")
(defvar my/repl-fallback #'shell "The fallback repl to use.")
(defun my/repl--open-or-create ()
  (let* ((mode (buffer-local-value 'major-mode (current-buffer)))
	 (repl (alist-get mode my/repl-alist my/repl-fallback))
	 (repl-buffer-name (concat "*"
				   (symbol-name (if (eq repl my/repl-fallback) mode repl))
				   ":repl*")))
    (if (get-buffer repl-buffer-name)
	(popper--find-buried-popups (get-buffer repl-buffer-name))
      (progn
	(add-popup! repl-buffer-name)
	(funcall repl)
	(rename-buffer repl-buffer-name)))))
(defun my/repl--choose (arg)
  (interactive (list (completing-read "Choose repl: " (mapcar #'symbol-name (mapcar #'car my/repl-alist)) nil t)))
  (let* ((repl (if (string= arg "fallback")
                   my/repl-fallback
                 (alist-get (intern arg) my/repl-alist my/repl-fallback)))
	 (repl-buffer-name (concat "*"
				   (symbol-name repl)
				   ":repl*")))
    (if (get-buffer repl-buffer-name)
        (popper-raise-popup (get-buffer repl-buffer-name))
      (progn
	(add-popup! repl-buffer-name)
	(funcall repl)
	(rename-buffer repl-buffer-name)))))

(defun my/repl (arg)
  (interactive "P")
  (if arg
      (call-interactively #'my/repl--choose)
    (my/repl--open-or-create)))
(my/general-global-Open "r" '("REPL" . my/repl))
#+end_src
***** Toggle
#+begin_src emacs-lisp
(defun my/toggle-comment (beg end)
  "Comment or uncomment current region or line."
  (interactive (if (use-region-p)
		   (list (region-beginning) (region-end))
		 (list (line-beginning-position) (line-end-position))))
  (comment-or-uncomment-region beg end))
(my/general-global-menu! "Toggle" "t"
  "d" '("debug" . toggle-debug-on-error)
  "/" '("comment" . comment-or-uncomment-region))
#+end_src
***** Search
#+begin_src emacs-lisp
(my/general-global-menu! "Search" "s")
#+end_src

** Hydra
#+begin_src emacs-lisp
(use-package hydra
  :demand
  :unless noninteractive
  :after (general evil)
  :config
  (defhydra my/zoom-hydra ()
    ("=" text-scale-increase "zoom in")
    ("k" text-scale-increase "zoom in")
    ("j" text-scale-decrease "zoom out")
    ("-" text-scale-decrease "zoom out"))
  (my/general-global-menu! "Hydras" "H"
    "=" '("Zoom" . my/zoom-hydra/body)
    "-" '("Zoom" . my/zoom-hydra/body)))
#+end_src
** evil
#+begin_src emacs-lisp
(use-package evil
  :unless noninteractive
  :init
  (setq evil-want-integration t
	evil-want-keybinding nil
	evil-want-C-u-scroll t
	evil-want-C-i-jump t
	select-enable-clipboard nil)
  :config
  (evil-mode)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)

  (my/leader-def
    "w" '("Window" . evil-window-map))
  (my/leader-def
    "u" '("Universal argument" . universal-argument)))

(use-package evil-collection
  :after evil
  :unless noninteractive
  :custom
  (evil-collection-setup-minibuffer t)
  :config
  (unless noninteractive
    (evil-collection-init))
  (general-def minibuffer-local-map
    :states 'normal
    [escape] 'abort-recursive-edit))
#+end_src
*** evil-lion
#+begin_src emacs-lisp
(use-package evil-lion
  :after evil
  :unless noninteractive
  :config
  (evil-lion-mode))
#+end_src
*** evil-surround
#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :unless noninteractive
  :config (global-evil-surround-mode 1))
#+end_src
*** evil-commentary
#+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :unless noninteractive
  :config
  (evil-commentary-mode))
#+end_src
*** evil-nerd-commenter
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :unless noninteractive
  :config
  (evilnc-default-hotkeys))
#+end_src
*** evil-goggles
#+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :unless noninteractive
  :init
  (setq evil-goggles-duration 0.05)
  :config
  (push '(evil-operator-eval
          :face evil-goggles-yank-face
          :switch evil-goggles-enable-yank
          :advice evil-goggles--generic-async-advice)
        evil-goggles--commands)
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces))
#+end_src
*** evil-snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :unless noninteractive
  :custom
  (evil-snipe-use-vim-sneak-bindings t)
  (evil-snipe-smart-case t)
  :config
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))
#+end_src
*** evil-exchange
#+begin_src emacs-lisp
(use-package evil-exchange
  :after evil
  :unless noninteractive
  :config
  (evil-exchange-cx-install))
#+end_src
*** evil-mc
#+begin_src emacs-lisp
(use-package evil-mc
  :after evil
  :unless noninteractive
  :hook (after-init . global-evil-mc-mode)
  :init
  (use-package evil-multiedit
    :custom
    (evil-multiedit-dwim-motion-keys t)
    (evil-multiedit-ignore-indent-and-trailing t)
    (evil-multiedit-scope 'buffer)
    (evil-multiedit-store-in-search-history t))
  :config
  (general-nmap
    "gm"  '("Multi-cursor" . evil-mc-cursors-map)
    "M-d" 'evil-mc-make-and-goto-next-match
    "M-S-d" 'evil-mc-make-and-goto-prev-match)
  (general-vmap
    "A" 'evil-mc-make-cursor-in-visual-selection-end
    "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  (my/general-global-menu! "Multi-Cursor" "c m"
    "a" '("Make all cursors" . evil-mc-make-all-cursors)
    "n" '("Make and go to next match" . evil-mc-make-and-goto-next-match)
    "N" '("Make and go to previous match" . evil-mc-make-and-goto-prev-match)
    "q" '("Undo all cursors" . evil-mc-undo-all-cursors))
  (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)
  (global-evil-mc-mode 1))
#+end_src
*** Extra Text Objects
#+begin_src emacs-lisp
(use-package targets
  :after evil
  :unless noninteractive
  :config
  (targets-setup t
		 :next-key "n"
		 :last-key "l"
		 :remote-key "r")
  (targets-define-composite-to pair-delimiter
    (("(" ")" pair)
     ("[" "]" pair)
     ("{" "}" pair)
     ("</" ">" )
     ("<" ">" pair))
    :bind t
    :next-key "n"
    :last-key "l"
    :remote-key "r"
    :keys "b")

  (targets-define-composite-to quote
    (("\"" "\"" quote)
     ("'" "'" quote)
     ("`" "`" quote))
    :bind t
    :next-key "n"
    :last-key "l"
    :remote-key "r"
    :keys "q"))
#+end_src
** which-key
#+begin_src emacs-lisp
(use-package which-key
  :unless noninteractive
  :hook (after-init . which-key-mode)
  :diminish
  :config
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.01
        which-key-max-description-length 32
        which-key-sort-order 'which-key-key-order-alpha
        which-key-allow-evil-operators t
        which-key-prefix-prefix "+"))
#+end_src
* Popper
#+begin_src emacs-lisp
(use-package popper
  :unless noninteractive
  :demand t
  :init
  (setq popper-reference-buffers
	'("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "\\*helpful .*\\*"
          "\\*.*:repl\\*"
          "\\*scratch\\*"
	  special-mode
          help-mode
          compilation-mode))

  (setq popper-group-function #'popper-group-by-directory
	popper-display-function #'popper-select-popup-at-bottom)
  :config
  (after! my/general
	  (my/general-global-menu! "Popper" "`"
	    "`" '("Toggle latest" . popper-toggle)
	    "c" '("Cycle" . popper-cycle)
	    "T" '("Toggle type" . popper-toggle-type)))
  (general-def :keymaps 'popper-mode-map
    "C-`"   'popper-toggle
    "M-`"   'popper-cycle
    "C-M-`" 'popper-toggle-type)
  (general-def :keymaps 'perspective-map
    "TAB" '("Switch" . persp-switch))
  (popper-mode +1))
#+end_src

* UI
** Fancy Compile
#+begin_src emacs-lisp
(use-package ansi-color
  :unless noninteractive
  :ensure nil
  :hook  (compilation-filter . ansi-color-compilation-filter))
#+end_src
** Fonts
#+begin_src emacs-lisp
(defconst my/font/name "JetBrainsMono Nerd Font Mono") ;; ligatures assumes this font
(defvar my/font/size 180)
(defvar my/font/unicode-name "Julia Mono")



(set-face-attribute 'default nil :font my/font/name :height my/font/size)
(set-face-attribute 'fixed-pitch nil :font my/font/name :height my/font/size)
(set-face-attribute 'variable-pitch nil :font my/font/name :height my/font/size :weight 'regular)
#+end_src
*** Ligatures
#+begin_src emacs-lisp :tangle no
(use-package ligature
  :config
  ;; Enable all JetBrains Mono ligatures in programming modes
  (ligature-set-ligatures '(prog-mode text-mode) '("-|" "--" "-~" "---" "-<" "--" "->" "->>" "-->" "///" "/=" "/=="
						   "/>" "//" "/*" "*>" "***" "*/" "<-" "<<-" "<=>" "<=" "<|" "<||"
						   "<|||" "<|>" "<:" "<>" "<-<" "<<<" "<==" "<<=" "<=<" "<==>" "<-|"
						   "<<" "<~>" "<=|" "<~~" "<~" "<$>" "<$" "<+>" "<+" "</>" "</" "<*"
						   "<*>" "<->" "<!--" ":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=" "=>>"
						   "==>" "=/=" "=!=" "=>" "===" "=:=" "==" "!==" "!!" "!=" ">]" ">:"
						   ">>-" ">>=" ">=>" ">>>" ">-" ">=" "&&&" "&&" "|||>" "||>" "|>" "|]"
						   "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||" ".." ".?" ".=" ".-" "..<"
						   "..." "+++" "+>" "++" "[||]" "[<" "[|" "{|" "??" "?." "?=" "?:" "##"
						   "###" "####" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" ";;" "_|_"
						   "__" "~~" "~~>" "~>" "~-" "~@" "$>" "^=" "]#"))
  (global-ligature-mode t))
#+end_src
*** Prettify symbols
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init
  (cl-defmacro my/prettify-symbols-extend (&rest pairs &allow-other-keys)
    "Extend the alist of `prettify-symbols-alist' with PAIRS."
    (declare (indent 0))
    `(setq prettify-symbols-alist
	   (-concat prettify-symbols-alist '(,@pairs))))
  (cl-defmacro my/prettify-symbols-extend-mode (mode &rest pairs &allow-other-keys)
    "Extend the alist of `prettify-symbols-alist' with PAIRS for MODE."
    (declare (indent 1))
    `(add-hook (intern (concat (symbol-name ,mode) "-hook"))
	       (lambda ()
		 (make-local-variable 'prettify-symbols-alist)
		 ,(macroexpand 
		   `(my/prettify-symbols-extend ,@pairs)))))
  :config
  (global-prettify-symbols-mode nil))
#+end_src
*** Emoji
#+begin_src emacs-lisp
(use-package emojify
  ;; :unless noninteractive
  :unless t
  :hook (after-init . global-emojify-mode)
  :config (setq emojify-styles '(unicode)))
#+end_src
*** Unicode
#+begin_src emacs-lisp
(use-package unicode-fonts
  :config
  (unicode-fonts-setup '(my/font/unicode-name))
  :init
  (my/leader-def "U" '("Insert Unicode char (by name)" . insert-char)))
#+end_src
** Dashboard
#+begin_src emacs-lisp
(use-package nerd-icons)
(use-package dashboard
  :unless noninteractive
  :hook (after-init . dashboard-setup-startup-hook)
  :init
  (setq dashboard-banner-logo-title "Welcome to Emacs Dashboard"
        dashboard-startup-banner 'logo
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-display-icons-p t
        dashboard-icon-type 'nerd-icons
        dashboard-projects-backend (if (package-installed-p 'projectile) 'projectile 'project)
        dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)
                          (registers . 5))
        dashboard-set-navigator t
        dashboard-set-init-info t
        inhibit-startup-screen t)

  (add-hook 'dashboard-mode-hook #'my/disable-line-numbers))
#+end_src
** Theme
#+begin_src emacs-lisp
(setq
 modus-themes-italic-constructs t
 modus-themes-bold-constructs t
 modus-themes-subtle-line-numbers nil
 modus-themes-tabs-accented t
 modus-themes-variable-pitch-ui t
 modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

 ;; Options for `modus-themes-prompts' are either nil (the
 ;; default), or a list of properties that may include any of those
 ;; symbols: `background', `bold', `gray', `intense', `italic'
 modus-themes-prompts '(background bold intense italic)

 ;; The `modus-themes-completions' is an alist that reads three
 ;; keys: `matches', `selection', `popup'.  Each accepts a nil
 ;; value (or empty list) or a list of properties that can include
 ;; any of the following (for WEIGHT read further below):
 ;;
 ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
 ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
 ;; `popup' - same as `selected'
 ;; `t' - applies to any key not explicitly referenced (check docs)
 ;;
 ;; WEIGHT is a symbol such as `semibold', `light', or anything
 ;; covered in `modus-themes-weights'.  Bold is used in the absence
 ;; of an explicit WEIGHT.
 modus-themes-completions
 '((matches . (semibold))
   (selection . (extrabold accented))
   (popup . (extrabold accented)))

 modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

 ;; The `modus-themes-headings' is an alist with lots of possible
 ;; combinations, include per-heading-level tweaks: read the
 ;; manual or its doc string
 modus-themes-headings
 '((0 . (variable-pitch light (height 2.2)))
   (1 . (rainbow variable-pitch light (height 1.6)))
   (2 . (rainbow variable-pitch light (height 1.4)))
   (3 . (rainbow variable-pitch regular (height 1.3)))
   (4 . (rainbow regular (height 1.2)))
   (5 . (rainbow (height 1.1)))
   (t . (variable-pitch extrabold))))

(setq modus-themes-italic-constructs t
      modus-themes-bold-constructs t
      modus-themes-mixed-fonts t
      modus-themes-variable-pitch-ui t
      modus-themes-custom-auto-reload nil
      modus-themes-disable-other-themes t

      ;; Options for `modus-themes-prompts' are either nil (the
      ;; default), or a list of properties that may include any of those
      ;; symbols: `italic', `WEIGHT'
      modus-themes-prompts '(italic bold)

      ;; The `modus-themes-completions' is an alist that reads two
      ;; keys: `matches', `selection'.  Each accepts a nil value (or
      ;; empty list) or a list of properties that can include any of
      ;; the following (for WEIGHT read further below):
      ;;
      ;; `matches'   :: `underline', `italic', `WEIGHT'
      ;; `selection' :: `underline', `italic', `WEIGHT'
      modus-themes-completions
      '((matches . (semibold))
        (selection . (extrabold accented)))

      modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

      ;; The `modus-themes-headings' is an alist: read the manual's
      ;; node about it or its doc string.  Basically, it supports
      ;; per-level configurations for the optional use of
      ;; `variable-pitch' typography, a height value as a multiple of
      ;; the base font size (e.g. 1.5), and a `WEIGHT'.
      modus-themes-headings
      '((1 . (variable-pitch 1.5))
        (2 . (1.3))
        (agenda-date . (1.3))
        (agenda-structure . (variable-pitch light 1.8))
        (t . (1.1))))

(load-theme 'modus-operandi t)
(setq modus-themes-to-toggle '(modus-operandi modus-vivendi))
(my/general-global-Toggle
  "t" '("theme" . modus-themes-toggle))
#+end_src

** Indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :unless noninteractive
  :hook (prog-mode . highlight-indent-guides-mode)
  :hook (conf-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-delay 0))
#+end_src
** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :unless noninteractive
  :init
  (unless (equal "Battery status not available"
		 (battery))
    (display-battery-mode 1))
  :config (doom-modeline-mode 1)
  :custom
  (doom-modeline-height 15)
  (doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode)))
  #+end_src
** Word Wrapping
#+begin_src emacs-lisp
(global-visual-line-mode t)
(my/general-global-Toggle
 "w" '("Word wrap" . visual-line-mode))
#+end_src
** Rainbow delimeters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Highlight todos
#+begin_src emacs-lisp
(use-package hl-todo
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode))
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"       warning bold)
          ("FIXME"      error bold)
          ("REVIEW"     font-lock-keyword-face bold)
          ("NOTE"       success bold)
          ("DEPRECATED" font-lock-doc-face bold))))
#+end_src
** evil-owl
#+begin_src emacs-lisp
(use-package evil-owl
  :after evil
  :unless noninteractive
  :config
  (setq evil-owl-max-string-length 500)
  (add-to-list 'display-buffer-alist
               '("*evil-owl*"
                 (display-buffer-in-side-window)
                 (side . bottom)
                 (window-height . 0.3)))
  (evil-owl-mode))
#+end_src
** Whitespace butler
#+begin_src emacs-lisp
(use-package ws-butler
  :hook ((prog-mode text-mode) . ws-butler-mode))
#+end_src
* Bookmarks
** Evil
#+begin_src emacs-lisp
(use-package evil-fringe-mark
  :unless noninteractive
  :requires evil
  :after evil
  :hook (after-init . global-evil-fringe-mark-mode)
  :init
  ;; Persist global marks
  (after! savehist
	  (add-to-list 'savehist-additional-variables 'evil-markers-alist))
  ;; Persist local marks
  (append! desktop-locals-to-save evil-markers-alist)
  ;; Show Marks in buffer
  (my/general-global-Open "`" '("Show marks" . evil-show-marks))
  :config
  (setq evil-fringe-mark-show-special t)
  (my/general-global-Toggle "f" '("Evil Marks" . evil-fringe-mark-mode)))
#+end_src

** Bookmark
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :unless noninteractive
  :after evil
  :config (my/general-global-menu! "Bookmarks" "B"
             "b" '("Jump" . bookmark-jump)
             "l" '("List" . bookmark-bmenu-list)
             "s" '("Set" . bookmark-set)
             "r" '("Rename" . bookmark-rename)
             "d" '("Delete" . bookmark-delete)
             "a" '("Add" . bookmark-set))
  :init
  (setq bookmark-default-file (concat my/cache-dir "bookmarks")
        bookmark-save-flag 1))
#+end_src
* Ripgrep
#+begin_src emacs-lisp
(use-package rg
  :unless noninteractive
  :hook (rg-mode . (lambda ()
                     (wgrep-rg-setup)
                     (define-key rg-mode-map (kbd "n") 'evil-search-next)
                     (define-key rg-mode-map (kbd "N") 'evil-search-previous)))
  :hook (after-init . rg-enable-default-bindings)
  :custom
  (rg-custom-type-aliases nil)
  (rg-default-alias-fallback "everything")
  (rg-group-result t)
  (rg-hide-command t)
  (rg-show-header t)
  (rg-show-columns nil)
  :init
  (use-package wgrep)
  (defvar my/rg-project-funcs (list #'vc-root-dir))
  (defun my/rg-project-func-fallback ()
    default-directory)
  :config
  (setq rg-executable (executable-find "rg"))
  (add-popup! "^\\*eshell.*\\*$" 'rg-mode)
  (rg-define-search my/grep-project
    :query ask
    :format regexp
    :files "everything"
    :dir (or (-first #'identity (-map #'funcall my/rg-project-funcs)) (my/rg-project-func-fallback))
    :confirm prefix
    :flags ("--hidden -g !.git")
    :menu ("Search" "p" "Project"))
  (my/general-global-Search
    "p" '("Project Search" . my/grep-project)
    "S" '("Ripgrep menu" . rg-menu)))
#+end_src
* Project management
** Projectile
#+begin_src emacs-lisp
(defvar my/projectile-ignore-projects '("^/sudo:" "^/docker:" "^/nix/store"))
(use-package projectile
  :diminish
  :unless noninteractive
  :custom
  (projectile-switch-project-action #'projectile-dired)
  (projectile-ignored-project-function #'(defun my/projectile-ignore-projects (project-root)
					   "Ignore matching regexes in `my/projectile-ignore-projects'."
					   (cl-some (lambda (regex) (string-match-p regex project-root))
						    my/projectile-ignore-projects)))
  (projectile-sort-order 'recently-active)
  (projectile-file-exists-remote-cache-expire (* 10 60))
  (projectile-require-project-root t)
  (projectile-per-project-compilation-buffer t)
  :config
  (projectile-mode +1)
  (my/leader-def
    "p" '("projectile" . projectile-command-map))
  (after! rg
	  (add-to-list 'my/rg-project-funcs #'projectile-project-root)))
#+end_src
** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :unless noninteractive
  :custom
  (persp-mode-prefix-key nil)
  (persp-suppress-no-prefix-key-warning t)
  (persp-state-default-file  (concat my/local-dir "perspective"))
  (persp-sort 'created)
  :hook (after-init . persp-mode)
  :hook (ibuffer . (lambda ()
		     (persp-ibuffer-set-filter-groups)
		     (unless (eq ibuffer-sorting-mode 'alphabetic)
		       (ibuffer-do-sort-by-alphabetic))))
  :hook (kill-emacs . persp-state-save)
  :config
  (my/leader-def
    "TAB" '("Workspaces" . perspective-map))
  (general-def :keymaps 'perspective-map
    "TAB" '("Switch" . persp-switch))
  (after! projectile
          (use-package persp-projectile
            :bind ([remap projectile-switch-project] . projectile-persp-switch-project))))
#+end_src
* Buffer management
#+begin_src emacs-lisp
(use-package ibuffer
  :unless noninteractive
  :ensure nil
  :commands ibuffer
  :init (my/general-global-Buffer
	  "i" '("ibuffer" . ibuffer))
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-saved-filters nil)
  (define-ibuffer-column size
    (:name "Size" :inline t)
    (file-size-human-readable (buffer-size))))
; next/prev buffer skip special buffers
(setq switch-to-prev-buffer-skip-regexp '("^\\*.*\\*$"))
#+end_src
* Dired
#+begin_src emacs-lisp
(use-package dired
  :unless noninteractive
  :ensure nil
  :commands (dired dired-jump dired-jump-other-window)
  :bind
  (:map my/general-global-Open-map
	("/" . dired)
	("d". dired-jump)
	("D". dired-jump-other-window))
  :config
  (require 'dired-aux)
  (require 'dired-x)
  (use-package dired-single)
  (setq dired-listing-switches "-lahFLHvZD --group-directories-first"
	dired-dwim-target t
	dired-recursive-copies 'always
	dired-recursive-deletes 'always
	dired-hide-details-hide-symlink-targets nil
	dired-hide-details-hide-information-lines nil
	insert-directory-program (if IS-MAC (executable-find "gls") insert-directory-program)
	dired-use-ls-dired t
	dired-auto-revert-buffer t
	dired-kill-when-opening-new-dired-buffer t)
  (evil-collection-define-key 'normal 'dired-mode-map
    "h" 'dired-single-up-directory
    "l" 'dired-single-buffer)
  (add-hook 'dired-mode-hook #'hl-line-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode))
#+end_src
** Writable file tree
#+begin_src emacs-lisp
(use-package wdired
    :ensure nil
    :after dired
    :custom
    (wdired-allow-to-change-permissions 'advanced)
    (wdired-allow-to-redirect-links t)
    (wdired-confirm-overwrite t)
    :config
    (my/local-leader-def dired-mode-map
        "w" '("wdired" . wdired-change-to-wdired-mode))
    (after! evil-collection
	    (evil-collection-wdired-setup)))
#+end_src
** Preview
#+begin_src emacs-lisp
(use-package dired-preview
  :hook  (dired-mode . dired-preview-mode)
  :custom
  (dired-preview-delay 0.7)
  (dired-preview-max-size (* 1024 1024 1024))
  ;; Default values for demo purposes
  (dired-preview-ignored-extensions-regexp
   (concat "\\."
	   "\\(mkv\\|webm\\|mp4\\|mp3\\|ogg\\|m4a"
	   "\\|gz\\|zst\\|tar\\|xz\\|rar\\|zip"
	   "\\|iso\\|epub\\|pdf\\)"))
  :config
  (defun dired-preview--find-file-no-select (file)
    (let ((inhibit-message t)
	  (enable-local-variables :safe)
	  (non-essential t)
	  (delay-mode-hooks t))
      (cl-letf (((symbol-function 'recentf-push) #'ignore))
	(find-file-noselect file :nowarn)))))
#+end_src
** Icons
#+begin_src emacs-lisp
(use-package nerd-icons-dired
  :hook
  (dired-mode . nerd-icons-dired-mode))
#+end_src
** Colors
#+begin_src emacs-lisp
(use-package diredfl
  :after dired
  :config (diredfl-global-mode))
#+end_src
** Copy
#+begin_src emacs-lisp
(use-package dired-rsync
  :bind ([remap dired-do-copy] . dired-rsync))
#+end_src
* Tree Sitter
#+begin_src emacs-lisp
(use-package treesit-auto
  :unless noninteractive
  :custom
  (treesit-auto-install nil)
  :config
  (if-let ((path (getenv "MY_TREESIT_PATH")))
      (add-to-list 'treesit-extra-load-path path))
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src
** expreg
#+begin_src emacs-lisp
  (use-package expreg
    :bind (("C-<tab>" . expreg-expand)
	   :repeat-map expreg-repeat-map
	   ("<tab>" . expreg-expand)
	   ("<backtab>" . expreg-contract)))
#+end_src
** evil text obj
#+begin_src emacs-lisp
(use-package evil-textobj-tree-sitter
  :after (evil treesit)
  :unless noninteractive
  :config
  (defun meain/fancy-narrow-to-thing (thing)
    (interactive)
    (if (buffer-narrowed-p) (fancy-widen))
    (let ((range (evil-textobj-tree-sitter--range 1 (list (intern thing)))))
      (fancy-narrow-to-region (car range) (cdr range))))
  (my/general-global-menu! "Narrow" "N"
    "n" `("widen" . ,(lambda () (interactive) (fancy-widen)))
    "f" `("function" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "function.outer")))
    "c" `("class" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "class.outer")))
    "C" `("comment" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "comment.outer")))
    "o" `("loop" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "loop.outer")))
    "i" `("conditional" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "conditional.outer")))
    "a" `("parameter" . ,(lambda () (interactive) (meain/fancy-narrow-to-thing "parameter.outer"))))
  ;; copied from doomemacs
  (defvar +tree-sitter-inner-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-outer-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-previous-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-next-map (make-sparse-keymap))

  (define-minor-mode my/treesit-mode "My treesit mode. For easily binding keys"
    :interactive nil)

  (evil-define-key '(visual operator) 'my/treesit-mode
    "i" +tree-sitter-inner-text-objects-map
    "a" +tree-sitter-outer-text-objects-map)
  (evil-define-key 'normal 'my/treesit-mode
    "[g" +tree-sitter-goto-previous-map
    "]g" +tree-sitter-goto-next-map)
  (general-def :keymaps '+tree-sitter-inner-text-objects-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.inner" "call.inner")))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.inner"))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.inner"))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.inner"))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.inner"))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.inner"))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.inner")))
  (general-def :keymaps '+tree-sitter-outer-text-objects-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.outer"))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.outer"))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.outer"))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.outer"))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.outer"))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.outer")))
  (general-def :keymaps '+tree-sitter-goto-previous-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer") t))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.outer" t))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.outer" t))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.outer" t))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.outer" t))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.outer" t))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.outer" t)))
  (general-def :keymaps '+tree-sitter-goto-next-map
    "A" `("call" . ,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")))
    "f" `("function" . ,(evil-textobj-tree-sitter-get-textobj "function.outer"))
    "F" `("call" . ,(evil-textobj-tree-sitter-get-textobj "call.outer"))
    "C" `("class" . ,(evil-textobj-tree-sitter-get-textobj "class.outer"))
    "c" `("comment" . ,(evil-textobj-tree-sitter-get-textobj "comment.outer"))
    "v" `("conditional" . ,(evil-textobj-tree-sitter-get-textobj "conditional.outer"))
    "l" `("loop" . ,(evil-textobj-tree-sitter-get-textobj "loop.outer"))))
#+end_src
* Eval region
#+begin_src emacs-lisp
(after! evil
	(defun my/elisp-eval-region (beg end)
	  (interactive "r")
	  (eval-region beg end t))
	(defvar my/evil-extra-operator-eval-modes-alist
	  '((emacs-lisp-mode my/elisp-eval-region)))

	(evil-define-operator my/evil-operator-eval (beg end)
	  :move-point nil
	  (interactive "<r>")
	  (let* ((mode (if (org-in-src-block-p) (intern (car (org-babel-get-src-block-info))) major-mode))
		 (ele (assoc mode my/evil-extra-operator-eval-modes-alist))
		 (f-a (cdr-safe ele))
		 (func (car-safe f-a))
		 (args (cdr-safe f-a)))
	    (if (fboundp func)
		(apply func beg end args)
	      (eval-region beg end t))))
	(define-key evil-motion-state-map "gr" 'my/evil-operator-eval))
#+end_src
* Calc
#+begin_src emacs-lisp
(use-package calc
  :unless noninteractive
  :ensure nil ;; built-in
  :commands (calc full-calc)
  :init (my/general-global-Open
	     "c" '("calc" . calc)
	     "C" '("full-calc" . full-calc))
  :config
  (setq calc-angle-mode 'rad
	calc-algebraic-mode t
        calc-display-trail t
        calc-group-digits t
        calc-line-numbering t
        calc-multiplication-has-precedence t
        calc-number-radix 10
        calc-symbolic-mode t
        calc-undo-length 1000
        calc-window-height 15)
  (add-hook 'calc-mode-hook #'my/disable-line-numbers))
#+end_src
* String Inflection
#+begin_src emacs-lisp
(use-package string-inflection
  :unless noninteractive
  :after evil
  :config
  (my/general-global-menu! "naming convention" "c ~"
    "~" '("cycle" . string-inflection-all-cycle)
    "t" '("toggle" . string-inflection-toggle)
    "c" '("CamelCase" . string-inflection-camelcase)
    "d" '("downCase" . string-inflection-lower-camelcase)
    "k" '("kebab-case" . string-inflection-kebab-case)
    "_" '("under_score" . string-inflection-underscore)
    "u" '("Upper_Score" . string-inflection-capital-underscore)
    "U" '("UP_CASE" . string-inflection-upcase))
  (evil-define-operator evil-operator-string-inflection (beg end _type)
    "Define a new evil operator that cycles symbol casing."
    :move-point nil
    (interactive "<R>")
    (string-inflection-all-cycle)
    (setq evil-repeat-info '([?g ?~])))
  (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection))
    #+end_src
* Smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :unless noninteractive
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  (sp-show-pair-from-inside t)
  (sp-cancel-autoskip-on-backward-movement nil)
  (sp-pair-overlay-keymap (make-sparse-keymap))
  (sp-max-prefix-length 25)
  (sp-max-pair-length 4)
  :hook (prog-mode . smartparens-mode)
  :hook (prog-mode . show-smartparens-mode)
  :config
  (my/general-global-Toggle "p" #'smartparens-mode)
  (use-package smartparens-config :ensure nil)
  (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode emacs-lisp-mode) "'" nil :actions nil)
  (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode emacs-lisp-mode) "`" nil :actions nil)
  (show-smartparens-global-mode t))
(use-package evil-smartparens
  :unless noninteractive
  :after (evil smartparens)
  :hook (smartparens-mode . evil-smartparens-mode)
  :hook (smartparens-strict-mode . evil-smartparens-mode))
#+end_src
* Help
** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :unless noninteractive
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-command] . helpful-command)
  :config
  (general-nmap
    "K" #'helpful-at-point)
  (after! undo-tree
	  (append! undo-tree-incompatible-major-modes #'helpful-mode)))
#+end_src
** Man & TLDR
#+begin_src emacs-lisp
(use-package tldr
  :unless noninteractive
  :commands (tldr tldr-update-docs)
  :bind (:map help-map
	      ("t" . tldr)
	      ("h" . man)
	      ("w" . woman))
  :config
  (setq tldr-directory-path (concat my/cache-dir "tldr/")))
#+end_src
** Devdocs
#+begin_src emacs-lisp
(use-package devdocs
  :commands devdocs-lookup
  :init (general-def 'help-map
	  "d" '("Devdocs" . devdocs-lookup)))
#+end_src
* Undo
** Undo Fu
#+begin_src emacs-lisp
(unless noninteractive
  (use-package undo-fu
    :demand t
    :custom
    (undo-limit         (* 512 1024 1024))
    (undo-strong-limit  (* 1024 1024 1024))
    (undo-outer-limit   (* 2 1024 1024 1024))
    (evil-undo-system 'undo-redo)
    :bind
    ([remap undo] . undo-fu-only-undo)
    ([remap redo] . undo-fu-only-redo)
    ("C-_"        . undo-fu-only-undo)
    ("M-_"        . undo-fu-only-redo)
    ("C-M-_"      . undo-fu-only-redo-all))
  (use-package undo-fu-session
    :after undo-fu
    :demand t
    :hook (after-init . global-undo-fu-session-mode)
    :bind
    ("C-x r u"    . undo-fu-session-save)
    ("C-x r U"    . undo-fu-session-recover)
    :custom
    (undo-fu-session-directory (concat my/cache-dir "undo-fu-session/"))
    (undo-fu-session-compression 'zst)))
#+end_src

** Vundo
#+begin_src emacs-lisp
(use-package vundo
  :unless noninteractive
  :custom
  (vundo-compact-display nil)
  (vundo-glyph-alist vundo-unicode-symbols))
#+end_src
* Completion
** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :unless noninteractive
  :demand
  :custom
  (corfu-cycle t)
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-auto-prefix 2)
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  (corfu-preselect 'prompt)      ;; Preselect the prompt
  (corfu-on-exact-match nil)     ;; Configure handling of exact matches
  (corfu-scroll-margin 5)        ;; Use scroll margin
  (corfu-quit-at-boundary t)
  :bind
  (:map corfu-map ("RET" . nil))
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous))
  :config
  (global-corfu-mode)

  (add-to-list 'completion-styles-alist
               '(tab completion-basic-try-completion ignore
		     "Completion style which provides TAB completion only."))
  (setq completion-styles '(tab orderless basic)))

(use-package emacs
  :ensure nil
  :init
  (setq completion-cycle-threshold t)

  ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  (setq read-extended-command-predicate #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
;; Use Dabbrev with Corfu!
(use-package dabbrev
  :unless noninteractive
  :ensure nil
  ;; Swap M-/ and C-M-/
  :bind (("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand))
  ;; Other useful Dabbrev configurations.
  :custom
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src
*** Corfu Popup Info
#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-hide nil)
  (corfu-popupinfo-delay '(0.25 . 0)))
#+end_src
*** Corfu History
#+begin_src emacs-lisp
(use-package corfu-history
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-history-mode)
  :config
  (after! savehist
	  (append! savehist-additional-variables 'corfu-history)))
#+end_src
** Icons
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :requires corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
** Cape
#+begin_src emacs-lisp
(use-package cape
  :unless noninteractive
  :config
  (require 'cape-keyword)
  (my/general-global-menu! "Completions" "c p"
    "p" '("Complete at point" . completion-at-point)
    "t" '("Complete tag" . complete-tag)
    "d" '("Dabbrev" . cape-dabbrev)
    "f" '("File" . cape-file)
    "k" '("Keyword" . cape-keyword)
    "s" '("Symbol" . cape-elisp-symbol)
    "a" '("Abbrev" . cape-abbrev)
    "l" '("Line" . cape-line)
    "w" '("Dict" . cape-dict)
    "\\" '("Tex" . cape-tex))
  (setopt cape-dict-file (concat (nth 1 (split-string (getenv "ASPELL_CONF") " ")) "/en_US.multi"))
  (append! completion-at-point-functions
    #'cape-abbrev
    #'cape-file
    #'cape-elisp-block
    #'cape-history
    #'cape-keyword
    #'cape-dict))
#+end_src
** Tempel
#+begin_src emacs-lisp
(use-package tempel
  :unless noninteractive
  :custom
  (tempel-trigger-prefix "<")
  :config
  (general-def :keymaps 'tempel-map "TAB" 'tempel-next) ;; progress through fields via `TAB'
  :init
  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
    ;; only triggers on exact matches. Alternatively use `tempel-complete' if
    ;; you want to see all matches, but then Tempel will probably trigger too
    ;; often when you don't expect it.
    ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
    ;; such that it will be tried first.
    (unless (member #'tempel-expand completion-at-point-functions)
	(make-local-variable 'completion-at-point-functions)
      (push #'tempel-expand completion-at-point-functions)))
  :hook (prog-mode . tempel-setup-capf)
  :hook (text-mode . tempel-setup-capf)
  :defer 1)
(use-package tempel-collection
  :after tempel
  :config
  (tempel-collection))
#+end_src
** Marginalia
#+begin_src emacs-lisp
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  :unless noninteractive
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))
  ;; load after completion-at-point
  :config (marginalia-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp
;; Enable orderless matching style.  See `+orderless-dispatch' in
;; `consult-config.el' for an advanced Orderless style dispatcher.
(use-package orderless
  :unless noninteractive
  :after vertico
  :custom
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles . (partial-completion)))))
  :config
  (append! completion-styles
    'orderless
    'partial-completion
    'basic))
#+end_src
** Vertico
#+begin_src emacs-lisp
;; Enable vertico
(use-package vertico
  :unless noninteractive
  :custom
  ;; Enable cycling for `vertico-next' and `vertico-previous'.
  (vertico-cycle t)
  ;; Grow and shrink the Vertico minibuffer
  (resize-mini-windows 'grow-only)
  (vertico-count 20)
  :config
  (vertico-mode)
  (after! embark
	  (general-def
	    :keymaps 'vertico-map
	    "C-c C-o" #'embark-export
	    "C-c C-c" #'embark-act
	    "C-c C-f" #'embark-become))
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src
** Consult
#+begin_src emacs-lisp
(use-package consult
  :unless noninteractive
  :commands (consult-ripgrep
	     consult-line
	     consult-buffer
	     consult-recent-file
	     consult-man)
  :init
  (my/leader-def
    "/" '("Search project" . consult-ripgrep))
  (my/general-global-Search
    "s" '("Search line" . consult-line))
  (my/general-global-Buffer
    "b" '("Buffer selection" . consult-buffer))
  (my/general-global-File
    "r" '("Recent File" . consult-recent-file))
  (general-def :keymaps 'help-map
    "h m" '("Manpage" . consult-man)))
(use-package consult-flymake
  :ensure consult
  :commands consult-flymake
  :init
  (after! flycheck
	  (my/general-global-menu! "Errors" "c e"
	    "f" '("Consult Flymake" . consult-flymake))))
#+end_src
** Embark
#+begin_src emacs-lisp
(use-package embark
  :unless noninteractive
  :commands (embark-act
	     embark-bindings
	     embark-collect
	     embark-export)
  :config
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  (setq which-key-use-C-h-commands nil
        prefix-help-command #'embark-prefix-help-command)
  (general-define-key [remap describe-bindings] #'embark-bindings)
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (setq embark-prompter 'embark-completing-read-prompter)
  (add-popup! #'embark-collect-mode)
  :init
  (my/general-global-menu! "Embark" "e"
    "o" '("export" . embark-export)
    "e" '("act" . embark-act)
    "b" '("bindings" . embark-bindings)
    "c" '("collect" . embark-collect))
  (general-def
    :prefix "C-c e"
    "o" '("export" . embark-export)
    "e" '("act" . embark-act)
    "b" '("bindings" . embark-bindings)
    "c" '("collect" . embark-collect)))
(use-package embark-consult
  :if (and (featurep 'embark)
	   (featurep 'consult))
  :after (embark consult)
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src
* Terminal
** EAT
#+begin_src emacs-lisp
(use-package eat
  :unless noninteractive
  :hook (eshell-load . eat-eshell-mode)
  :config
  (add-popup!
   "^\\*eat.*\\*$"  'eat-mode)
  (eat-eshell-mode))
#+end_src
** Vterm
#+begin_src emacs-lisp
(use-package vterm
  :unless noninteractive
  :commands vterm
  :custom
  (vterm-shell (or (getenv "SHELL") (executable-find "fish") (executable-find "bash")))
  :init (my/general-global-Open "t" '("vterm" . vterm))
  :config
  (defun my/vterm--auto-close-window (buf event)
    (when (y-or-n-p (concat event " - kill buffer: " (buffer-name buf) "?"))
      (kill-buffer-and-window)))
  (add-hook 'vterm-exit-functions #'my/vterm--auto-close-window)
  (add-popup!
   "^\\*vterm.*\\*$"  'vterm-mode)
  (add-hook 'vterm-mode-hook #'my/disable-line-numbers))
#+end_src
** Eshell
#+begin_src emacs-lisp
(use-package eshell
  :unless noninteractive
  :ensure nil
  :commands eshell
  :init
  (setq my/repl-fallback #'eshell)
  (my/general-global-Open
    "e" '("eshell" . eshell))
  (setq eshell-aliases-file (concat my/cache-dir "eshell/alias")
	eshell-history-file-name (concat my/cache-dir "eshell/history")
	eshell-buffer-maximum-lines 10000
	eshell-hist-ignoredups t
	eshell-scroll-to-bottom-on-input 'all
	eshell-error-if-no-glob t
	eshell-glob-case-insensitive t
	eshell-scroll-show-maximum-output nil)
  (make-directory (concat my/cache-dir "eshell") t)
  :config
  (add-popup! "^\\*eshell.*\\*$" 'eshell-mode)
  (add-hook 'eshell-mode-hook #'my/disable-line-numbers)
  (after! corfu (add-hook 'eshell-mode-hook #'corfu-mode)))
(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+end_src
* Formatting and linting/checking
** Format on save
#+begin_src emacs-lisp
(use-package apheleia
  :unless noninteractive
  :custom
  (apheleia-remote-algorithm 'local)
  :config (apheleia-global-mode +1))
#+end_src
** Linting
#+begin_src emacs-lisp
(use-package flycheck
  :unless noninteractive
  :config
  (my/general-global-Errors
    "e" '("List errors" . flycheck-list-errors)
    "n" '("Next error" . flycheck-next-error)
    "p" '("Previous error" . flycheck-previous-error)
    "d" '("Describe checker" . flycheck-describe-checker)
    "v" '("Verify setup" . flycheck-verify-setup))
  (global-flycheck-mode)
  (add-popup! "^\\*Flycheck.*\\*$" #'flycheck-error-list-mode)
  :custom
  (flycheck-emacs-lisp-load-path 'inherit)
  (flycheck-display-errors-delay 0.25)
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-indication-mode 'right-fringe))
#+end_src
** Jinx
#+begin_src emacs-lisp
(use-package jinx
  :unless noninteractive
  :hook (emacs-startup . global-jinx-mode)
  :config
  (general-nmap
    "]s" '("Spelling error" . jinx-next)
    "[s" '("Spelling error" . jinx-previous)
    "z=" 'jinx-correct)
  (after! vertico
	  (use-package vertico-grid :ensure nil)
	  (use-package vertico-multiform :ensure nil)
	  (add-to-list 'vertico-multiform-categories
		       '(jinx grid (vertico-grid-annotate . 20)))
	  (vertico-multiform-mode 1)))
#+end_src
* Env
** Inherit ENV
#+begin_src emacs-lisp
(use-package inheritenv)
#+end_src
** direnv
#+begin_src emacs-lisp
(use-package envrc
  :hook (after-init . envrc-global-mode))
#+end_src
* Git
** Magit
#+begin_src emacs-lisp
(use-package magit
  :unless noninteractive
  :init
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-log-arguments '("--graph" "--decorate" "--color"))
  (setq git-commit-fill-column 72)
  :config
  (my/general-global-Git
    "g" '("Status" . magit-status)
    "b" '("Blame" . magit-blame)
    "l" '("Log" . magit-log)
    "G" '("Status here" . magit-status-here)
    "S" '("Stage file" . magit-stage-buffer-file)
    "U" '("Unstage file" . magit-unstage-file))
  (add-popup! "\\*\\*magit-process:.*\\*\\*")
  (setq magit-buffer-name-format (concat "*" magit-buffer-name-format "*"))
  (append! magit-status-sections-hook #'magit-insert-modules)
  (evil-define-key* '(normal visual) magit-mode-map
    "zz" #'evil-scroll-line-to-center))
#+end_src
** ediff
#+begin_src emacs-lisp
(after! ediff
	(setq ediff-diff-options ""
	      ediff-custom-diff-options "-u"
	      ediff-window-setup-function 'ediff-setup-windows-plain
	      ediff-split-window-function 'split-window-vertically))
#+end_src
** Time Machine
#+begin_src emacs-lisp
(use-package git-timemachine
  :unless noninteractive
  :commands (git-timemachine)
  :init
  (setq git-timemachine-show-minibuffer-details t)
  (my/general-global-Git
    "t" '("Time machine" . git-timemachine))
  :config
  (add-hook 'git-timemachine-mode-hook 'evil-normalize-keymaps)
  (general-def :keymaps 'git-timemachine-mode-map
    "C-k" 'git-timemachine-show-previous-revision
    "C-j" 'git-timemachine-show-next-revision
    "q" 'git-timemachine-quit))
#+end_src
** Git Gutter
#+begin_src emacs-lisp
(use-package git-gutter
  :unless noninteractive
  :config
  (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
					:hint nil)
    "
Git gutter:
  _j_: next hunk        _s_tage hunk     _q_uit
  _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
  ^ ^                   _p_opup hunk
  _h_: first hunk
  _l_: last hunk        _c_ommit staged hunks
"
    ("j" git-gutter:next-hunk)
    ("k" git-gutter:previous-hunk)
    ("h" (progn (goto-char (point-min))
		(git-gutter:next-hunk 1)))
    ("l" (progn (goto-char (point-min))
		(git-gutter:previous-hunk 1)))
    ("s" git-gutter:stage-hunk)
    ("r" git-gutter:revert-hunk)
    ("p" git-gutter:popup-hunk)
    ;; ("R" git-gutter-set-start-revision)
    ("c" magit-commit)
    ("q" nil :color blue)
    ("Q" (progn (git-gutter-mode -1)
		;; git-gutter-fringe doesn't seem to
		;; clear the markup right away
		(sit-for 0.1)
		(git-gutter:clear))
     :color blue))
  (my/general-global-Hydras
    "g" '("Git" . hydra-git-gutter/body))
  (global-git-gutter-mode t)
  (my/general-global-Git
    "n" '("next hunk" . git-gutter:next-hunk)
    "p" '("previous hunk" . git-gutter:previous-hunk)
    "s" '("stage hunk" . git-gutter:stage-hunks)
    "r" '("revert hunk" . git-gutter:revert-hunk)))
#+end_src
** Forge
#+begin_src emacs-lisp
(use-package forge
  :unless noninteractive
  :custom
  (forge-add-default-bindings nil)
  :after magit)
#+end_src
* Eglot
#+begin_src emacs-lisp
(use-package eglot
  :unless noninteractive
  :ensure nil ;; included in emacs29+
  :commands (eglot eglot-ensure)
  :init
  (use-package markdown-mode) ;; Better formatting eldoc
  (setq eglot-events-buffer-size 0) ;; don't log events
  :config
  (my/general-global-menu! "LSP" "cl"
    "a" #'eglot-code-actions
    "d" #'eglot-help-at-point
    "f" #'eglot-format-buffer)
  (when (featurep 'tempel)
    (use-package eglot-tempel))
  (after! cape
	  (add-hook
	   'eglot-managed-mode-hook
	   (lambda ()
	     (append! completion-category-overrides '((eglot (styles orderless))))
	     (setq completion-category-defaults nil)
	     (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
             (make-local-variable 'completion-at-point-functions)
	     (append! completion-at-point-functions #'eglot-completion-at-point)))))
#+end_src
** Eglot Tempel
#+begin_src emacs-lisp
(use-package eglot-tempel
  :unless noninteractive
  :after (eglot tempel))
#+end_src
** Booster
#+begin_src emacs-lisp
(use-package eglot-booster
  :after eglot
  :config (eglot-booster-mode))
#+end_src
** Flycheck Eglot
#+begin_src emacs-lisp
(use-package flycheck-eglot
  :unless noninteractive
  :after (flycheck eglot)
  :config (global-flycheck-eglot-mode 1))
#+end_src
** Sideline
#+begin_src emacs-lisp
(use-package sideline
  :unless noninteractive
  :commands sideline-mode
  :init
  (setq
   sideline-backends-right (list)
   sideline-backends-left-skip-current-line t   ; don't display on current line (left)
   sideline-backends-right-skip-current-line t  ; don't display on current line (right)
   sideline-order-left 'down                    ; or 'up
   sideline-order-right 'up                     ; or 'down
   sideline-format-left "%s   "                 ; format for left aligment
   sideline-format-right "   %s"                ; format for right aligment
   sideline-priority 100                        ; overlays' priority
   sideline-display-backend-name t)             ; display the backend name
  )
(use-package sideline-flycheck
  :unless noninteractive
  :hook (flycheck-mode . sideline-flycheck-setup)
  :hook (flycheck-mode . sideline-mode)
  :commands sideline-flycheck
  :custom (sideline-flycheck-max-lines 5)
  :init (append! sideline-backends-right #'sideline-flycheck))


(use-package sideline-flymake
  :unless noninteractive
  :hook (flymake-mode . sideline-mode)
  :commands sideline-flymake
  :custom (sideline-flymake-max-lines 5)
  :init (append! sideline-backends-right #'sideline-flymake))

#+end_src
** eldoc
#+begin_src emacs-lisp
(use-package eldoc
  :ensure nil
  :unless noninteractive
  :hook
  (eglot-mode . eldoc-mode)
  (emacs-lisp-mode . eldoc-mode)
  :config
  (add-popup! "\\*eldoc\\*")
  :custom
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t))
#+end_src
*** eldoc-box
#+begin_src emacs-lisp
(use-package eldoc-box
  :hook (emacs-lisp-mode . eldoc-box-hover-at-point-mode)
  :hook (eglot--managed-mode . eldoc-box-hover-at-point-mode))
#+end_src

** dape
#+begin_src emacs-lisp
(use-package dape
  ;; To use window configuration like gud (gdb-mi)
  :custom
  (dape-buffer-window-arrangment 'gud)
  (dape-buffer-window-arrangment 'right)
  (dape-adapter-dir (concat my/local-dir "dape-adapters/"))
  :config

  (my/leader-def
    "d" '("Debug" . dape-global-map))
  ;; By default dape uses gdb keybinding prefix
  (setq dape-key-prefix "\C-x\C-a")

  ;; Kill compile buffer on build success
  ;; (add-hook 'dape-compile-compile-hooks 'kill-buffer)

  ;; Save buffers on startup, useful for interpreted languages
  (add-hook 'dape-on-start-hooks
            (defun dape--save-on-start ()
              (save-some-buffers t t))))
#+end_src
* Languages
** Nix
#+begin_src emacs-lisp
(use-package nix-ts-mode
  :mode "\\.nix\\'"
  :config
  (define-minor-mode nix-mode "Fake `nix-mode'. Used with `nix-ts-mode'")
  (add-hook 'nix-ts-mode-hook #'nix-mode)
  (add-hook 'nix-ts-mode-hook #'my/treesit-mode) 
  (after! apheleia
	  (setf (alist-get 'nixfmt apheleia-formatters)
		'("nixfmt"))
	  (setf (alist-get 'nix-ts-mode apheleia-mode-alist)
		'(nixfmt)))
  (after! eglot
	  (setf (alist-get 'nix-ts-mode eglot-server-programs) (alist-get 'nix-mode eglot-server-programs))
	  (add-hook 'nix-mode-hook #'eglot-ensure))
  (provide 'nix-mode))

(use-package nix-drv-mode
  :ensure nix-mode
  :mode "\\.drv\\'")
(use-package nix-shell
  :ensure nix-mode
  :commands (nix-shell-unpack nix-shell-configure nix-shell-build))
(use-package nix-repl
  :ensure nix-mode
  :after nix-mode
  :config
  (my/general-global-Open
    :definer 'minor-mode
    :keymaps 'nix-mode-map
    "r" 'nix-repl))
#+end_src
** Python
#+begin_src emacs-lisp
(use-package python
  :ensure nil
  :mode ("\\.py\\'" . python-mode)
  :mode ("[./]flake8\\'" . conf-mode)
  :mode ("/Pipfile\\'" . conf-mode)
  :interpreter ("python" . python-mode)
  :init
  (setq python-check-command "pyflakes")
  :config
  (after! apheleia
	  (add-hook 'python-mode-hook (lambda ()
					(setq-local apheleia-formatter '(ruff ruff-isort)))))
  (after! treesit-auto
	  (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode)))

  (add-hook 'python-ts-mode-hook (defun my/python-ts-base-hook () (run-hooks 'python-mode-hook))) 
  (add-hook 'python-ts-mode-hook #'my/treesit-mode) 

  (my/local-leader-def python-mode
      "r" '("repl/python" . run-python)
      "b" '("send buffer to repl" . python-shell-send-buffer))
  (after! dape
	  ;; for some reason "python" doesn't find the module "debugpy". It seems that dape
	  ;; uses a strange way to lookup in path. This lets it find the installed debugger
	  ;; when I'm using my global python env and can be reset in dir locals or direnv
	  ;; otherwise
	  (plist-put (alist-get 'debugpy dape-configs) 'command (executable-find "python3")))
  (add-hook 'python-mode-hook 'eglot-ensure))

(use-package flymake-ruff
  :unless noninteractive
  :hook (eglot-managed-mode . flymake-ruff-load))

(use-package ob-python
  :ensure nil
  :after org
  :commands org-babel-execute:python
  :init
  (add-to-list 'org-babel-load-languages '(python . t))
  (setq org-babel-python-command "python3"))
#+end_src
*** Virtual Environments
#+begin_src emacs-lisp
(use-package pyvenv
  :defer t
  :config
  ;; Display virtual envs in the menu bar
  (setq pyvenv-menu t)
  ;; Restart the python process when switching environments
  (add-hook 'pyvenv-post-activate-hooks (lambda ()
					  (pyvenv-restart-python)))
  (my/local-leader-def-python-mode
   "v" '("workon" . pyvenv-workon))
  :after python
  :hook (python-mode . pyvenv-mode))

(use-package poetry
  :after python
  :hook (python-mode . poetry-tracking-mode)
  :config (my/local-leader-def-python-mode
	     "p" '("poetry" . poetry)))

#+end_src
*** Numpy Docstring
#+begin_src emacs-lisp
(use-package numpydoc
  :after python-mode
  :init
  (after! yasnippet
          (setq numpydoc-insertion-style 'numpydoc))
  :config (my/local-leader-def-python-mode
           "d" '("generate docstring" . numpydoc-generate)))
#+end_src
** Jupyter
#+begin_src emacs-lisp
(use-package code-cells
  :mode ("\\.ipynb\\'" . code-cells-convert-ipynb)
  :bind (:map code-cells-mode-map
	      ("M-k"   . code-cells-backward-cell)
	      ("M-j"   . code-cells-forward-cell)
	      ("C-M-`" . code-cells-eval))
  :hook (python-mode . code-cells-mode-maybe)
  :config
  (use-package ob-ipython)
  (use-package simple-httpd)
  (use-package websocket)
  ;; pandoc ipynb seems to be broken on my linux machines
  (if IS-MAC
      (setq code-cells-convert-ipynb-style '(("pandoc" "--to" "ipynb" "--from" "org")
					     ("pandoc" "--to" "org" "--from" "ipynb")
					     (lambda () #'org-mode))))
  (use-package jupyter
    :config
    (append! org-babel-load-languages
      '(python . t)
      '(jupyter . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
  (let ((map code-cells-mode-map))
    (define-key map [remap evil-search-next] (code-cells-speed-key 'code-cells-forward-cell)) ;; n
    (define-key map [remap evil-paste-after] (code-cells-speed-key 'code-cells-backward-cell)) ;; p
    (define-key map [remap evil-backward-word-begin] (code-cells-speed-key 'code-cells-eval-above)) ;; b
    (define-key map [remap evil-forward-word-end] (code-cells-speed-key 'code-cells-eval)) ;; e
    (define-key map [remap evil-jump-forward] (code-cells-speed-key 'outline-cycle))) ;; TAB
  (add-to-list 'code-cells-eval-region-commands
	       '(python-ts-mode . python-shell-send-region) t))

#+end_src
** Rust
#+begin_src emacs-lisp
(use-package rustic
  :mode ("\\.rs$" . rustic-mode)
  :init
  (defun my/startup-rust ()
    (setq-local compile-command "cargo run")
    (when (boundp 'flycheck-checkers)
      (make-local-variable 'flycheck-checkers)
      (push 'rustic-clippy flycheck-checkers)))
  (add-hook 'rustic-mode-hook #'my/startup-rust)
  :config
  (setq rustic-lsp-client 'eglot)
  (add-hook 'rustic-mode-hook 'eglot-ensure)
  (setq rustic-indent-method-chain t)
  (my/local-leader-def rustic-mode
		       "b" '("build" . nil)
		       "bb" '("build" . rustic-cargo-build)
		       "br" '("run" . rustic-cargo-run)
		       "ba" '("audit" . rustic-cargo-audit)
		       "bt" '("test" . rustic-cargo-test)
		       "bc" '("check" . rustic-cargo-check)
		       "bd" '("doc" . rustic-cargo-build-doc)
		       "bD" '("doc open" . rustic-cargo-doc)
		       "bn" '("new" . rustic-cargo-new)
		       "c" '("cargo" . nil)
		       "co" '("outdated" . rustic-cargo-outdated)
		       "ca" '("add" . rustic-cargo-add)
		       "cd" '("rm" . rustic-cargo-rm)
		       "cA" '("add missing" . rustic-cargo-add-missing-dependencies)
		       "m" '("macro expand" . rustic-cargo-expand)))
(use-package rustic-babel
  :ensure nil
  :after org
  :commands (org-babel-execute:rustic)
  :init
  (add-to-list 'org-src-lang-modes '("rust" . rustic))
  (add-to-list 'org-babel-tangle-lang-exts '("rustic" . "rs"))
  (defalias 'org-babel-execute:rust #'org-babel-execute:rustic))
#+end_src
** Lua
#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua$")
#+end_src
** Haskell
#+begin_src emacs-lisp
(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :mode ("\\.cabal\\'" . haskell-cabal-mode)
  :config
  (use-package haskell :ensure nil)
  (add-hook 'haskell-mode-hook 'eglot-ensure)
  (my/local-leader-def haskell-mode
      "b" 'haskell-process-cabal-build
      "c" 'haskell-cabal-visit-file
      "h" 'haskell-hide-toggle
      "H" 'haskell-hide-toggle-all))
(use-package ob-haskell
  :ensure nil
  :after org
  :commands org-babel-execute:haskell
  :init
  (add-to-list 'org-babel-load-languages '(haskell . t)))
#+end_src
** Julia
#+begin_src emacs-lisp
(use-package julia-mode
  :mode ("\\.jl\\'" . julia-mode)
  :config
  (add-hook 'julia-mode-hook #'eglot-ensure)
  (my/local-leader-def julia-mode
		       "b" 'julia-repl-send-buffer
		       "r" 'julia-repl-send-region-or-line
		       "R" 'julia-repl
		       "f" 'julia-repl-send-defun
		       "l" 'julia-repl-send-line
		       "s" 'julia-repl
		       "S" 'julia-repl-switch)
  (defun my/julia-def ()
    (my/general-global-Open :keymaps 'local
      "r" 'julia-repl-send-region-or-line
      "f" 'julia-repl-send-defun
      "l" 'julia-repl-send-line))
  (add-hook 'julia-mode-hook #'my/julia-def))
;; First use requires running 'import Pkg; Pkg.add("LanguageServer")' in the Julia REPL
#+end_src
*** REPL
#+begin_src emacs-lisp
(use-package julia-vterm
  :hook (julia-mode . julia-vterm-mode)
  :init (setq julia-vterm-repl-program (concat (executable-find "julia") " --color=yes --startup-file=no -t " (number-to-string my/available-cores)))
  :config
  (add-popup! "\\*julia:main\\*")
  (add-hook 'julia-mode-hook (lambda () (setf (alist-get 'julia-mode my/repl-alist) #'julia-vterm-repl))))
#+end_src
*** Babel
#+begin_src emacs-lisp
(use-package ob-julia-vterm
  :after org
  :commands org-babel-execute:julia-vterm
  :init
  (add-to-list 'org-babel-load-languages '(julia-vterm . t)))
#+end_src
** Kotlin
#+begin_src emacs-lisp
(use-package kotlin-ts-mode
  :hook (kotlin-ts-mode . eglot-ensure)
  :mode "\\.kts?\\'"
  :config
  (setenv "JAVA_OPTS" "-Xmx8g")
  (add-hook 'kotlin-ts-mode-hook
  	    (defun my/kotlin-ts-setup ()
  	      (setq-local
  	       read-process-output-max (* 16 1024 1024)
  	       eglot-autoshutdown t
  	       eglot-connect-timeout 300
  	       eglot-ignored-server-capabilities '(:documentFormattingProvider
  						   :documentRangeFormattingProvider
  						   :documentOnTypeFormattingProvider
  						   :documentHighlightProvider))))
  (after! eglot
  	  (add-to-list 'eglot-server-programs '(kotlin-ts-mode "kotlin-language-server")))
  (defun my/gradlew-command (command)
    "Run gradlew in this project."
    (interactive "Command: ")
    (let ((default-directory (locate-dominating-file buffer-file-name "gradlew"))
  	  (compilation-read-command nil)
  	  (compile-command (format "sh gradlew %s" command)))
      (call-interactively #'compile)))
  (my/local-leader-def kotlin-ts-mode
      "tt"  '("go to test" . kotlin-ts-mode-goto-test-file)
      "tr"  '("run test function" . kotlin-ts-mode-run-current-test-function)
      "tR"  '("run test class" . kotlin-ts-mode-run-current-test-class)
      "ta" '("gradlew test" . (lambda () (interactive) (my/gradlew-command "test")))

      "a" '("gradlew assemble" . (lambda () (interactive) (my/gradlew-command "assemble")))
      "b" '("gradlew build" . (lambda () (interactive) (my/gradlew-command "build")))
      "r" '("gradlew run" . (lambda () (interactive) (my/gradlew-command "run")))))

(use-package flycheck-kotlin
  :hook (kotlin-ts-mode . flycheck-kotlin-setup))

(use-package java-imports
  :hook (kotlin-ts-mode . java-imports-scan-file)
  :custom
  (java-imports-find-block-function 'java-imports-find-place-sorted-block))
(use-package flymake-ktlint
  :after kotlin-ts-mode
  :custom
  (ktlint-flymake-args '("--android")))
#+end_src
** PDF
#+begin_src emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq pdf-view-use-scaling t)
  (add-hook 'pdf-view-mode-hook #'my/disable-line-numbers)
  (add-to-list 'recentf-exclude "/**/*.pdf")
  (after! undo-tree
	  (add-to-list 'undo-tree-incompatible-major-modes 'pdf-view-mode)))
#+end_src
** Shell
#+begin_src emacs-lisp
(use-package sh-script
  :ensure nil
  :mode ("\\.zsh\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.zshrc\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.sh\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :mode ("\\.bashrc\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :config 
  (setq sh-basic-offset 4
        sh-indentation 4))
#+end_src
*** Org Babel
#+begin_src emacs-lisp
(use-package ob-shell
  :ensure nil
  :after org
  :custom
  (org-babel-shell-results-defaults-to-output t)
  (org-babel-default-header-args:sh '((:session . nil))))
#+end_src
** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile.*\\'" . dockerfile-mode))

(use-package docker
  :commands docker
  :init (my/general-global-Open "!" '("Container" . docker)))
#+end_src
** Latex
Mostly only used for double checking after org export.
#+begin_src emacs-lisp
(use-package auctex
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((latex . t))))

(use-package reftex
  :after auctex
  :ensure nil
  :hook (LaTeX-mode , turn-on-reftex))

(use-package cdlatex
  :hook (org-mode . org-cdlatex-mode)
  :hook (LaTeX-mod . turn-on-cdlatex))
#+end_src
** Markdown Mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("README\\.md\\'" . gfm-mode)
  :mode ("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode)
  :init (setq markdown-enable-math t))
#+end_src
*** Poly mode
#+begin_src emacs-lisp
(use-package poly-markdown
  :unless noninteractive
  :commands poly-org-mode
  :after markdown
  :hook (markdown-mode-hook . poly-markdown-mode))
#+end_src
* Mail
** mu4e
#+begin_src emacs-lisp :lexical t
(defun my/get-mail-dir ()
  (expand-file-name "mail/" (getenv "XDG_DATA_HOME")))

(defconst my/mail-dir (my/get-mail-dir))
;; Only load on personal machines with mail
(defconst my/enable/mu4e (and (not noninteractive) IS-PERSONAL (file-directory-p my/mail-dir)))

(use-package mu4e
  :if my/enable/mu4e
  :commands mu4e
  :init
  (add-to-list 'recentf-exclude my/mail-dir)
  (my/general-global-Open "m" '("Email" . mu4e))
  :config
  (my/local-leader-def mu4e-headers-mode
      "u" '("Update" . mu4e-update-mail-and-index))
  ;; Context switching for multiple accounts
  (defun my/create-mu4e-context (name address signature server &optional key)
    (unless key (setq key (substring name 0 1)))
    (make-mu4e-context
     :name (format "%s(%s)" key name)
     :enter-func (lambda () (mu4e-message "Entering context %s" name))
     :leave-func (lambda () (mu4e-message "Leaving context %s" name))
     :match-func (lambda (msg)
		   (when msg
		     (string-prefix-p (format "/%s" address)
				      (mu4e-message-field msg :maildir))))
     :vars `((user-mail-address . ,address)
	     (user-full-name . ,user-full-name)
	     (mu4e-compose-signature . ,(if (package-installed-p 'org-msg) signature))
	     (mu4e-sent-folder . ,(format "/%s/Sent" name))
	     (mu4e-drafts-folder . ,(format "/%s/Drafts" name))
	     (mu4e-trash-folder . ,(format "/%s/Trash" name))
	     (mu4e-refile-folder . ,(format "/%s/Archive" name))
	     (smtpmail-smtp-user . ,address)
	     (smtpmail-smtp-server . ,server)
	     (smtpmail-smtp-service . 587)
	     (smtpmail-stream-type . starttls)
	     (smtpmail-debug-info . t)
	     (smtpmail-debug-verb . t))))
  (defun my/wrap-signature (str)
    (concat
     "#+begin_signature\n"
     str
     "\n#+end_signature"))
  (defun my/gmail-signature (name)
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: " name "@gmail.com\n")))
  (defun my/udmercy-signature ()
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: bakheakm@udmercy.edu")))

  (setq
   mail-user-agent 'mu4e-user-agent
   read-mail-command 'mu4e
   mu4e-maildir my/mail-dir
   mu4e-confirm-quit nil
   ;; This is set to 't' to avoid mail syncing issues when using mbsync
   mu4e-change-filenames-when-moving t

   ;; Refresh mail using isync every 10 minutes
   mu4e-update-interval (* 10 60)
   mu4e-get-mail-command "mbsync -a"

   ;; Context policy
   mu4e-context-policy 'pick-first
   mu4e-compose-context-policy 'ask
   mu4e-contexts (list
                  (my/create-mu4e-context "kbakheat-gmail" "kbakheat@gmail.com" (my/gmail-signature "kbakheat") "smtp.gmail.com")
                  (my/create-mu4e-context "kirolsb5-gmail" "kirolsb5@gmail.com" (my/gmail-signature "kirolsb5") "smtp.gmail.com" "a")
                  (my/create-mu4e-context "bakheakm-udmercy" "bakheakm@udmercy.edu" (my/udmercy-signature) "smtp.office365.com"))))


(use-package mu4e-alert
  :if my/enable/mu4e
  :after mu4e
  :config
  (when IS-LINUX
    (progn (mu4e-alert-set-default-style 'libnotify)
	   (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (when IS-MAC
    (progn (mu4e-alert-set-default-style 'notifier)
	   (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src
** msmtp
#+begin_src emacs-lisp
(after! mu4e
        (setq message-send-mail-function #'message-send-mail-with-sendmail
              sendmail-program (executable-find "msmtp")
              send-mail-function #'smtpmail-send-it
              message-sendmail-f-is-evil t
              message-sendmail-extra-arguments '("--read-envelope-from")))
#+end_src
** Compose mail with org mode
#+begin_src emacs-lisp
(use-package org-msg
  :if my/enable/mu4e
  :after (org mu4e)
  :config (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
                org-msg-startup "hidestars indent inlineimages"
                org-msg-greeting-fmt "\nHey%s,\n\n"
                org-msg-greeting-name-limit 3
                org-msg-default-alternatives '((new		. (text html))
                                               (reply-to-html	. (text html))
                                               (reply-to-text	. (text)))
                org-msg-convert-citation t
                org-msg-signature "")
  (org-msg-mode))
#+end_src
* Org Mode
#+begin_src emacs-lisp
(use-package org
  :defer 1
  :ensure nil ;; included in emacs
  :config
  (require 'org-tempo)
  (dolist (scheme '("ftp" "http" "https" "mailto" "news"))
    (org-link-set-parameters scheme
			     :follow
			     `(lambda (url arg)
				(browse-url (concat ,scheme ":" url) arg))))
  :init
  (defun my/relative-org (dir)
    "Makes a sting representing a directory relative to my org base directory"
    (setq my-org-base-dir "~/org")
    (concat (file-name-as-directory my-org-base-dir) dir))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        org-directory (my/relative-org "general/")
        org-insert-heading-respect-content t
        org-export-in-background t
        org-export-with-sub-superscripts '{}
	org-pretty-entities t
	org-pretty-entities-include-sub-superscripts t
        org-list-allow-alphabetical t
        org-catch-invisible-edits 'smart
        org-special-ctrl-a/e t
	org-return-follows-link t
        org-export-backends '(latex beamer html ascii)

	browse-url-browser-function (cond
				     (IS-MAC #'browse-url-default-macosx-browser)
				     (IS-LINUX #'browse-url-xdg-open))))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(after! (org smartparens)
	(add-hook 'org-mode-hook #'smartparens-mode)
	(sp-local-pair 'org-mode "\\[" "\\]")
	(sp-local-pair 'org-mode "\\(" "\\)")
	(sp-local-pair 'org-mode "$" "$"))
#+end_src
** Org Modern
#+begin_src emacs-lisp
(use-package org-modern
  :hook (org-mode . org-modern-mode)
  :custom
  (org-modern-star 'replace)
  (org-modern-replace-stars "◉○◈◇✳"))
#+end_src
** Keybindings
#+begin_src emacs-lisp
(use-package org
  :config
  (my/local-leader-def org-mode
    "#" #'org-update-statistics-cookies
    "'" #'org-edit-special
    "*" #'org-ctrl-c-star
    "+" #'org-ctrl-c-minus
    "," #'org-switchb
    "@" #'org-cite-insert
    "." #'consult-org-heading
    "/" #'counsel-org-goto-all
    "A" #'org-archive-subtree
    "e" #'org-export-dispatch
    "f" #'org-footnote-action
    "h" #'org-toggle-heading
    "i" #'org-toggle-item
    "I" #'org-id-get-create
    "k" #'org-babel-remove-result
    "n" #'org-store-link
    "o" #'org-set-property
    "q" #'org-set-tags-command
    "t" #'org-todo
    "T" #'org-todo-list
    "x" #'org-toggle-checkbox

    "a" '("attachments" . nil)
    "aa" 'org-attach
    "ad" 'org-attach-delete-one
    "aD" 'org-attach-delete-all
    "af" '+org/find-file-in-attachments
    "al" '+org/attach-file-and-insert-link
    "an" 'org-attach-new
    "ao" 'org-attach-open
    "aO" 'org-attach-open-in-emacs
    "ar" 'org-attach-reveal
    "aR" 'org-attach-reveal-in-emacs
    "au" 'org-attach-url
    "as" 'org-attach-set-directory
    "aS" 'org-attach-sync

    "b" '("tabels" . nil)
    "b-" 'org-table-insert-hline
    "ba" 'org-table-align
    "bb" 'org-table-blank-field
    "bc" 'org-table-create-or-convert-from-region
    "be" 'org-table-edit-field
    "bf" 'org-table-edit-formulas
    "bh" 'org-table-field-info
    "bs" 'org-table-sort-lines
    "br" 'org-table-recalculate
    "bR" 'org-table-recalculate-buffer-tables

    "bd" '("delete" . nil)
    "bdc" 'org-table-delete-column
    "bdr" 'org-table-kill-row

    "bi" '("insert" . nil)
    "bic" 'org-table-insert-column
    "bih" 'org-table-insert-hline
    "bir" 'org-table-insert-row
    "biH" 'org-table-hline-and-move

    "l" '("links" . nil)
    "lc" 'org-cliplink
    "ld" '+org/remove-link
    "li" 'org-id-store-link
    "ll" 'org-insert-link
    "lL" 'org-insert-all-links
    "ls" 'org-store-link
    "lS" 'org-insert-last-stored-link
    "lt" 'org-toggle-link-display
    "lg" '(org-mac-link-get-link :if IS-MAC)


    "s" '("subtree" . nil)
    "sa" 'org-toggle-archive-tag
    "sb" 'org-tree-to-indirect-buffer
    "sc" 'org-clone-subtree-with-time-shift
    "sd" 'org-cut-subtree
    "sh" 'org-promote-subtree
    "sj" 'org-move-subtree-down
    "sk" 'org-move-subtree-up
    "sl" 'org-demote-subtree
    "sn" 'org-narrow-to-subtree
    "sr" 'org-refile
    "ss" 'org-sparse-tree
    "sA" 'org-archive-subtree
    "sN" 'widen
    "sS" 'org-sort))
#+end_src
** Agenda
#+begin_src emacs-lisp
(use-package org-gcal
  :after org-agenda
  :unless noninteractive
  :if (and IS-PERSONAL (executable-find "pass") (file-exists-p (concat (getenv "PASSWORD_STORE_DIR") "/google.com/api/client_secret.gpg")))
  :commands (org-gcal-sync)
  :init (my/general-global-Open
	     "a" '("agenda" . org-gcal-sync))
  :custom
  (org-gcal-client-id (auth-source-pass-get 'secret "google.com/api/client_id"))
  (org-gcal-client-secret (auth-source-pass-get 'secret "google.com/api/client_secret"))
  (org-gcal-fetch-file-alist `(("kbakheat@gmail.com" . ,(my/relative-org "/agenda/google.org"))))
  (org-gcal-notify-p t)
  (org-gcal-recurring-events-mode 'nested)
  (oauth2-auto-plstore (concat my/etc-dir "oauth2-auto.plist"))
  :config
  (cl-loop for (key . value) in org-gcal-file-alist
	   do (append! org-agenda-files value))
  (unless (file-exists-p oauth2-auto-plstore) (f-touch oauth2-auto-plstore))
  (use-package plstore
    :ensure nil
    :config (add-to-list 'plstore-encrypt-to "kbakheat@gmail.com")))
#+end_src
** Presenting
#+begin_src emacs-lisp
(use-package visual-fill-column
  :unless noninteractive
  :hook (org-present . visual-fill-column)
  :hook (org-present . visual-fill-line)
  :custom
  (visual-fill-column-width 110)
  (visual-fill-column-center-text t))
(use-package org-present
  :unless noninteractive
  :commands (org-present)
  :config
  ;; enable list of modes in org present then disable on quit
  (add-hook 'org-present-mode-hook
	    (lambda ()
	      (org-present-big)
	      (org-display-inline-images)
	      (org-present-hide-cursor)
	      (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
	    (lambda ()
	      (org-present-small)
	      (org-remove-inline-images)
	      (org-present-show-cursor)
	      (org-present-read-write))))
#+end_src
** LilyPond
#+begin_src emacs-lisp
(use-package lilypond-mode
  :ensure nil ;; Comes with lilypond, installed with nix
  :preface (defvar my/lilypond (executable-find "lilypond"))
  :mode ("\\.ly\\'" . LilyPond-mode)
  :commands (LilyPond-mode)
  :if my/lilypond
  :init (defalias 'lilypond-mode 'LilyPond-mode))
(use-package ob-lilypond
  :ensure nil
  :after (org lilypond-mode)
  :commands (org-babel-lilypond-tangle org-babel-execute:lilypond)
  :if my/lilypond
  :config
  ;; org-babel-lilypond-commands is a list of strings. We set just the first one to lilypond
  (setf (car org-babel-lilypond-commands) (executable-find "lilypond"))
  (setopt org-babel-lilypond-commands org-babel-lilypond-commands)
  (add-to-list 'org-babel-load-languages '(lilypond . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Org Previews
#+begin_src emacs-lisp
(after! org
	;; Latex fragments
	(add-hook 'org-mode-hook #'org-latex-preview)

	;; Images
	(add-hook 'org-mode-hook #'org-display-inline-images)
	(add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images))
#+end_src
** Notes
#+begin_src emacs-lisp
(my/general-global-menu! "Notes" "n")
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :unless noninteractive
  :commands (deft)
  :custom
  (deft-directory (my/relative-org "deft"))
  (deft-recursive t)
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t)
  (deft-extensions '("org" "md" "txt"))
  (deft-default-extension "org")
  (deft-file-naming-rules '((noslash . "-")
                            (nospace . "-")
                            (case-fn . downcase)))
  (deft-text-mode 'org-mode)
  :config
  (add-popup! "\\*Deft\\*")
  :init (my/general-global-Notes
             "d" '("deft" . deft)))
#+end_src
*** Roam
#+begin_src emacs-lisp
(use-package org-roam
  :unless noninteractive
  :after org
  :custom
  (org-roam-v2-ack t)
  (org-roam-directory (my/relative-org "roam"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(
     <<roam-templates>>
     ))
  :init (my/general-global-Notes
	  "r" '("roam" . nil)
	  "rf" '("find" . org-roam-node-find)
	  "ri" '("insert" . org-roam-node-insert)
	  "rg" '("graph" . org-roam-graph)
	  "rt" '("today" . org-roam-dailies-find-today)
	  "ry" '("yesterday" . org-roam-dailies-find-yesterday)
	  "rr" '("tomorrow" . org-roam-dailies-find-tomorrow)
	  "rd" '("date" . org-roam-dailies-find-date)
	  "rc" '("capture today" . org-roam-dailies-capture-today)
	  "rC" '("capture tomorrow" . org-roam-dailies-capture-tomorrow)
	  "rD" '("capture date" . org-roam-dailies-capture-date)
	  "rl" '("toggle display" . org-roam-buffer-toggle-display)
	  "rL" '("display dedicated" . org-roam-buffer-display-dedicated)
	  "rs" '("sync" . org-roam-db-sync)
	  "rS" '("server" . org-roam-server-mode)))
#+end_src
**** Templates
:PROPERTIES:
:header-args: :tangle no :noweb-ref roam-templates
:END:
***** Religious
#+begin_src emacs-lisp
("r" "Templates for religious meditations")
#+end_src
****** Bible
#+begin_src emacs-lisp
("rb" "Bible Study" plain "#+filetags: \"bible study\" \"Book: ${book}\" \"Topic: ${topic}\"\n\n* Topic\n\n* Related\n** Passages\n\n** Meditations\n\n* Personal Meditation\n\n"
 :if-new (file+head "religious/bible-study/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Saint
#+begin_src emacs-lisp
("rs" "Saint" plain "#+filetags: saint \"Saint Type: ${saint type}\" \"Years: ${birth year}-${death year}\" \"Country: ${country}\" \"City: ${city}\"\n\n* Birth\n%?\n\n* Life\n\n\n* Death\n\n\n* Related saints\n\n"
 :if-new (file+head "religious/saints/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Lesson
#+begin_src emacs-lisp
("rl" "Lesson" plain "#+filetags: lesson \"Topic: ${topic}\"\n* %?"
 :if-new (file+head "religious/lessons/%<%Y%m%d%H%M%S>-${slug}.org"
		    "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
***** Generic
****** Default
#+begin_src emacs-lisp
("d" "Default" plain "#+filetags: \"${tags}\"\n\n* %?"
 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
****** Note
#+begin_src emacs-lisp
("n" "Note" plain "#+filetags: note\n\n* %?"
 :if-new (file+head "notes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: note ${field}\n\n")
 :unnarrowed t)
#+end_src

****** Project
#+begin_src emacs-lisp
("p" "Project" plain "#+filetags: project\n\n* %?"
 :if-new (file+head "projects/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: project ${field}\n\n")
 :unnarrowed t)
#+end_src
** Babel
#+begin_src emacs-lisp
(use-package org
  :config
  (add-popup! '("^\\*Org-Babel Error Output\\*$" . hide))
  (setq org-confirm-babel-evaluate nil
	org-src-fontify-natively t
	org-src-tab-acts-natively t
	org-src-window-setup 'current-window
	org-src-preserve-indentation t
	org-src-strip-leading-and-trailing-blank-lines t
	org-src-ask-before-returning-to-edit-buffer nil
        org-babel-load-languages '((emacs-lisp . t))
	org-babel-default-header-args '((:session . "default")
					(:results . "replace")
					(:mkdirp . "yes")
					(:exports . "both")
					(:cache . "yes")
					(:noweb . "yes")
					(:hlines . "no")
					(:tangle . "no")
					(:padnewline . "yes")
					(:eval . "never-export")
					(:comments . "link")))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Auto Tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :custom (org-auto-tangle-default t)
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Export
*** =ox-latex=
#+begin_src emacs-lisp
(use-package ox-latex
  :ensure nil
  :after org
  :config
  (setq org-latex-compiler "xelatex")
  (add-to-list 'org-latex-logfiles-extensions "tex")
  (add-to-list 'org-latex-packages-alist '("" "siunitx"))
  (add-to-list 'org-latex-packages-alist '("" "amsmath"))
  (add-to-list 'org-latex-packages-alist '("" "fancyhdr"))
  (add-to-list 'org-latex-classes
               '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" .    "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("exam"
                 "\\documentclass{exam}"
                 ("\\begin{questions} %% %s"
                  "\\end{questions}"
                  "\\begin{questions} %% %s"
                  "\\end{questions}")
                 ("\\question %s " . "\\question* %s")
		 ("\\begin{parts} %s"
		  "\\end{parts}"
                  "\\begin{parts} %s"
                  "\\end{parts}"))))
#+end_src
*** =ox-html=
#+begin_src emacs-lisp
(use-package ox-html
:ensure nil
:after org)
#+end_src
*** =ox-chameleon=
#+begin_src emacs-lisp
(use-package ox-chameleon
  :ensure nil
  :after org
  :config
  (add-to-list 'org-latex-packages-alist '("" "scrextend" nil))
  (add-to-list 'org-latex-packages-alist '("" "xcolor" nil))
  (after! org-msg
	  (setq org-msg-options (concat org-msg-options " html-content-class: chameleon "))))
#+end_src
*** Async patch
#+begin_src emacs-lisp
(when (not noninteractive) 
  (after! ox
	  (setq org-export-async-init-file (make-temp-file "org-export-async-init-file" nil ".el"))
	  (defun my/get-loaded-nix-file (name)
	    (car (load-history-filename-element
		  (concat
		   "^/nix/store/.*emacs-packages-deps/share/emacs/site-lisp/"
		   name
		   "\\.elc?\\(\\.gz\\)?$"))))

	  (with-temp-file org-export-async-init-file
	    (mapc (lambda (s)
		    (insert (format "(load \"%s\")\n" s)))
		  (-select #'identity
			   (list
			    (my/get-loaded-nix-file "site-start")
			    (my/get-loaded-nix-file "subdirs")
			    (my/get-loaded-nix-file "default")
			    (my/get-loaded-nix-file "init"))))
	    (insert (format "(setq engrave-faces-preset-styles '%S)\n" engrave-faces-preset-styles))
	    (insert (format "(setq engrave-faces-themes '%S)\n" engrave-faces-themes))
	    (insert (format "(setq load-path '%S)\n" load-path))
	    (insert (format "(setq exec-path '%S)\n" exec-path)))))
#+end_src
*** Syntax Highlighting
#+name: engrave-faces-init
#+begin_src emacs-lisp :tangle no
;;; Definers
(eval-and-compile
  (defmacro defadvice! (symbol arglist &optional docstring &rest body)
    "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
    (declare (doc-string 3) (indent defun))
    (unless (stringp docstring)
      (push docstring body)
      (setq docstring nil))
    (let (where-alist)
      (while (keywordp (car body))
	(push `(cons ,(pop body) (ensure-list ,(pop body)))
              where-alist))
      `(progn
	 (defun ,symbol ,arglist ,docstring ,@body)
	 (dolist (targets (list ,@(nreverse where-alist)))
	   (dolist (target (cdr targets))
	     (advice-add target (car targets) #',symbol))))))
  (defvar-local org-export-has-code-p nil)

  (defadvice! org-export-expect-no-code (&rest _)
    :before #'org-export-as
    (setq org-export-has-code-p nil))

  (defadvice! org-export-register-code (&rest _)
    :after #'org-latex-src-block
    :after #'org-latex-inline-src-block-engraved
    (setq org-export-has-code-p t))

  (defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
    "Like `org-latex-example-block', but supporting an engraved backend"
    :around #'org-latex-example-block
    (let ((output-block (funcall orig-fn example-block contents info)))
      (if (eq 'engraved (plist-get info :latex-listings))
	  (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
	output-block))))
#+end_src
#+begin_src emacs-lisp
;; both installed by engrave-faces
(use-package engrave-faces-latex
  :ensure engrave-faces
  :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
(use-package engrave-faces-html
  :ensure engrave-faces
  :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
#+end_src
** Nix Shell
#+begin_src emacs-lisp
(use-package org-nix-shell
  :hook (org-mode . org-nix-shell-mode))
#+end_src
** Evil Org
#+begin_src emacs-lisp
(use-package evil-org
  :unless noninteractive
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :config
  (use-package evil-org-agenda :ensure nil)
  (evil-org-agenda-set-keys)
  (add-hook 'evil-org-mode-hook
	    (lambda ()
	      (evil-org-set-key-theme)))
  (use-package evil-org-agenda :ensure nil)
  (evil-org-agenda-set-keys))
#+end_src
** Org Src
#+begin_src emacs-lisp
(use-package org-src-context
  :after org
  :init (my/local-leader-def-org-mode
	  "S" '("src LSP" . org-src-context-mode)))
#+end_src
** Poly Org
#+begin_src emacs-lisp
(use-package poly-org
  :unless noninteractive
  :commands poly-org-mode
  :after org
  :init
  (my/local-leader-def-org-mode
    "p" '("poly-org-mode" . poly-org-mode)))
#+end_src
* Footer
#+begin_src emacs-lisp
(provide 'default)
#+end_src
# Local Variables:
# org-use-property-inheritance: t
# End:
