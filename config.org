* Setup
#+property: header-args :tangle init.el :results output silent :noweb yes :lexical t :eval never-export
#+startup: fold
#+auto_tangle: t
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src
** Requires
#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src
** Basic variables
*** System type
#+begin_src emacs-lisp
(defconst IS-MAC      (eq system-type 'darwin))
(defconst IS-LINUX    (memq system-type '(gnu gnu/linux gnu/kfreebsd berkeley-unix)))
(defconst IS-WINDOWS  (memq system-type '(cygwin windows-nt ms-dos)))
(defconst IS-BSD      (memq system-type '(darwin berkeley-unix gnu/kfreebsd)))
;; personal or work
(defconst IS-PERSONAL t)
(defconst IS-WORK     (not IS-PERSONAL))
(defconst my/available-cores
  (string-to-number
   (shell-command-to-string (if (eq system-type 'darwin)
                                "sysctl -n hw.ncpu"
                              "nproc --all"))))
#+end_src
*** Directories
#+begin_src emacs-lisp
(defvar my/local-dir (expand-file-name ".local/" user-emacs-directory)
  "Default local directory.")
(if-let ((local-dir (getenv "XDG_DATA_HOME")))
    (setq my/local-dir (expand-file-name "emacs/" local-dir)))
(make-directory my/local-dir t)
(defvar my/cache-dir (expand-file-name "cache/" my/local-dir)
  "Default cache directory.")
(if-let ((cache-dir (getenv "XDG_CACHE_HOME")))
    (setq my/cache-dir (expand-file-name "emacs/" cache-dir)))
(make-directory my/cache-dir t)
(defvar my/etc-dir (expand-file-name "etc/" my/local-dir)
  "Default etc directory.")
(defvar my/emacs-dir user-emacs-directory
  "Default emacs directory.")
#+end_src
*** Personal info
#+begin_src emacs-lisp
(setq user-full-name "Kirols Bakheat"
      user-mail-address "kbakheat@gmail.com")
#+end_src

** Macros
*** ~after!~
#+begin_src emacs-lisp
(cl-defmacro after! (features &rest body)
  "A smart wrapper around `with-eval-after-load'"
  (if (listp features)
      (pcase (length features)
	(0 `(progn ,@body))
	(1 `(with-eval-after-load (quote ,(car features))
	      (progn
		,@body)))
        (_ (if (eq (car features) 'or)
               `(progn
                  ,@(cl-map 'list
                           (lambda (feature)
                             `(after! ,feature ,@body))
                           (cdr features)))
             `(with-eval-after-load (quote ,(car features))
                (after! ,(cdr features) ,@body)))))
    `(with-eval-after-load (quote ,features)
       (progn ,@body))))
#+end_src
*** ~append!~
#+begin_src emacs-lisp
(cl-defmacro append! (var &rest values)
  "Append VALUES to the end of VAR, if they don't already exist in VAR."
  (declare (indent defun))
  `(dolist (value (list ,@values))
     (unless (member value ,var)
       (setf ,var (append ,var (list value))))))
#+end_src
** Startup
#+begin_src emacs-lisp
(defun my/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'my/display-startup-time)
#+end_src
** gcmh
#+begin_src emacs-lisp
(use-package gcmh
  :unless noninteractive
  :demand
  :hook
  (focus-out-hook . gcmh-idle-garbage-collect)
  :config
  (gcmh-mode +1))
#+end_src
** Hooks
#+begin_src emacs-lisp
(defun my/disable-line-numbers ()
  (display-line-numbers-mode -1)
  (setq-local display-line-numbers nil))
#+end_src
** no-littering
#+begin_src emacs-lisp
(use-package no-littering
  :config
  (setq no-littering-etc-directory (expand-file-name "etc/" my/local-dir)
        no-littering-var-directory (expand-file-name "var/" my/local-dir)
        custom-file (no-littering-expand-etc-file-name "custom.el"))
  (load custom-file 'noerror 'nomessage))
#+end_src
** History
*** recentf
#+begin_src emacs-lisp
(use-package recentf
  :unless noninteractive
  :ensure nil
  :config
  (dolist (dir `("/nix/store/.*"
		 "/tmp/.*"
		 "/var/tmp/.*"
		 "/var/folders/.*"
		 "/private/tmp/.*"
		 "/private/var/.*"
		 "~/\\.cache.*"
		 ,(concat my/etc-dir ".*")
		 ,(concat my/local-dir ".*")
		 ,(concat my/cache-dir ".*")))
    (add-to-list 'recentf-exclude dir))
  (when-let ((dir (getenv "XDG_DATA_HOME")))
    (add-to-list 'recentf-exclude (concat dir "/.*")))
  (setq recentf-max-menu-items 100
	recentf-max-saved-items 100
	recentf-save-file (expand-file-name "recentf" my/local-dir))
  (recentf-mode 1))
#+end_src
*** savehist
#+begin_src emacs-lisp
(use-package savehist
  :unless noninteractive
  :ensure nil
  :config
  (setq savehist-file (expand-file-name "savehist" my/local-dir)
	savehist-save-minibuffer-history t
	savehist-autosave-interval 60
	savehist-additional-variables '(kill-ring
					search-ring
					regexp-search-ring))
  (savehist-mode 1))
#+end_src
*** saveplace
#+begin_src emacs-lisp
(use-package saveplace
  :unless noninteractive
  :ensure nil
  :config
  (setq save-place-file (expand-file-name "saveplace" my/local-dir))
  (save-place-mode 1))
#+end_src
** Custom file
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" my/etc-dir))
#+end_src
** Backup files
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" my/local-dir)))
      auto-save-file-name-transforms `((".*" ,(expand-file-name "auto-save/" my/local-dir) t)))
(use-package tramp
  :ensure nil
  :custom (tramp-backup-directory-alist nil))
#+end_src
** Lockfiles
#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src
** Autosave
#+begin_src emacs-lisp
(setq auto-save-default nil)
#+end_src
** Auto-revert
#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode
  :config
  (setq auto-revert-verbose nil
        auto-revert-interval 2
        auto-revert-check-vc-info t
        auto-revert-remote-files t)
  (global-auto-revert-mode +1))
#+end_src
** Yes-or-No
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Authsources
#+begin_src emacs-lisp
(setq auth-sources (list (expand-file-name "authinfo.gpg" my/local-dir)))
#+end_src
** Native Comp
#+begin_src emacs-lisp :early-init.el
(setq comp-eln-cache-path (expand-file-name "eln-cache/" my/cache-dir)
      native-comp-async-report-warnings-errors 'silent
      native-comp-verbose 0)
#+end_src
** Window management
I want windows that start with '*' to be opened in the lower 1/3 of the frame. These windows should close when their buffer dies and should not be reused. If they are not in ~my/special-window-no-cursor-manage-alist~ then they should automatically grab the cursor.
#+begin_src emacs-lisp
(defvar my/special-window-no-cursor-manage-alist '("*Help*" "*Warnings*" "*Backtrace*" "*Messages*"))
#+end_src
** Proxy Settings
#+begin_src emacs-lisp
(defvar my/proxy nil
  "Proxy to use")
(when IS-WORK
  (setq my/proxy  "http://internet.ford.com:83")
  (setq url-using-proxy my/proxy
        url-proxy-services `(("http" . ,my/proxy)
                             ("https" . ,my/proxy)
                             ("ssh" . ,my/proxy)))
  (after! lsp-mode
          (setq lsp-http-proxy my/proxy)))
#+end_src
** Early init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:
*** Disable package.el
#+begin_src emacs-lisp
(setq package-enable-at-startup nil
      package-quickstart nil)
#+end_src
*** Garbage-collection
#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum ;; reset by gcmh
      gc-cons-percentage 0.6)
#+end_src
*** UI
#+begin_src emacs-lisp
(setq inhibit-startup-message t
      frame-inhibit-implied-resize t
      inhibit-splash-screen t
      use-file-dialog nil
      use-dialog-box nil
      display-line-numbers-type 'relative
      ring-bell-function 'ignore)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
(scroll-bar-mode -1)         ; Disable visible scrollbar
(tool-bar-mode -1)           ; Disable the toolbar
(tooltip-mode -1)            ; Disable tooltips
(set-fringe-mode '(20 . 10)) ; Give some breathing room
(menu-bar-mode -1)           ; Disable the menu bar

(column-number-mode)
(global-display-line-numbers-mode t)

(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
* Keybindings
** Basics
#+begin_src emacs-lisp
(cond
 (IS-MAC
  (define-key key-translation-map [S-iso-lefttab] [backtab])
  (setq mac-command-modifier      'meta
        ns-command-modifier       'meta
        mac-option-modifier       'meta
        ns-option-modifier        'meta
        mac-right-option-modifier 'super
        ns-right-option-modifier  'super))
 (IS-WINDOWS
  (setq w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super)))
;; Make ESC quit prompts
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq use-package-always-demand (daemonp)
      use-package-expand-minimally t
      use-package-verbose nil)
#+end_src
** general.el
*** Helpers
Macro to define nested keymaps
#+begin_src emacs-lisp
;; copied from https://github.com/progfolio/.emacs.d/blob/master/init.org
(defmacro my/general-global-menu! (name prefix-key &rest body)
  "Create a definer named +general-global-NAME wrapping global-definer.
  Create prefix map: +general-global-NAME-map. Prefix bindings in BODY with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n (concat "my/general-global-" name))
         (prefix-map (intern (concat n "-map"))))
    `(progn
       ;; (defvar ,prefix-map (make-sparse-keymap))
       (general-create-definer ,(intern n)
         :wrapping my/leader-def
         :prefix-map (quote ,prefix-map)
         :infix ,prefix-key
         :wk-full-keys nil
         "" '(:ignore t :which-key ,name)
	 )
       (,(intern n)
        "" '(:ignore t :which-key ,name)
	,@body))))
#+end_src
Do something in other window
#+begin_src emacs-lisp
(defun my/do-in-other-window (fn &rest args)
    (let ((buf (current-buffer)))
        (other-window 1)
        (apply fn args)
        (switch-to-buffer buf)))
#+end_src
**** Local Bindings
#+begin_src emacs-lisp :noweb-ref keybindings :tangle no
(cl-defmacro my/local-leader-def (mode &rest args)
  "Create a definer named +general-global-NAME wrapping global-definer.
    Create prefix map: +general-global-NAME-map. Prefix bindings in BODY with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n  (symbol-name mode))
         (definer (intern (concat "my/local-leader-def-" n)))
	 (prefix-map (intern (concat n "-map"))))
    `(progn
       (general-create-definer ,definer
	 :wrapping global-leader
	 :major-modes '(,mode)
	 :keymaps '(,prefix-map)
	 )
       (,definer
	"" '(:ignore t :which-key "<localleader>")
	,@args))))
#+end_src
*** general.el setup
#+begin_src emacs-lisp :noweb yes
(defvar my/leader-def-prefix "SPC"
  "Prefix for general.el leader keybindings.")
(defvar my/leader-def-prefix-alt "M-SPC"
  "Alternative prefix for general.el leader keybindings.")
(defvar my/local-leader-def-prefix "m"
  "Prefix for general.el local leader keybindings.
   Relative to `my/leader-def-prefix'.")
(defvar my/prefix-states '(normal visual motion)
  "States in which to bind general.el leader keybindings.")

(use-package general
  :demand t
  :config
  (general-evil-setup)
  (general-override-mode 1)
  (general-auto-unbind-keys)
  (general-define-key
   :major-modes t
   :keymaps 'override
   :states my/prefix-states
   :prefix-map 'my/prefix-map
   :prefix my/leader-def-prefix
   :global-prefix my/leader-def-prefix-alt)

  (general-define-key
   :keymaps 'override
   :states '(insert normal hybrid motion visual operator emacs)
   :prefix-map 'my/prefix-map
   :prefix my/leader-def-prefix
   :global-prefix my/leader-def-prefix-alt)

  (general-create-definer my/leader-def
    :wk-full-keys nil
    :keymaps 'my/prefix-map)
  (general-create-definer global-leader
    :keymaps 'override
    :states '(insert normal hybrid motion visual operator)
    :prefix (concat my/leader-def-prefix " " my/local-leader-def-prefix)
    :non-normal-prefix (concat my/leader-def-prefix-alt " " my/local-leader-def-prefix)
    "" '(:ignore t :which-key "<localleader>"))
  (my/leader-def
    "SPC" '(project-find-file :which-key "Find file")
    "h"   '(:keymap help-map :which-key "Help")
    "H"   '(helpful-at-point :which-key "Help at point")
    ";"   '(execute-extended-command :which-key "M-x")
    ":"   '(eval-expression :which-key "Eval")
    "."   '(repeat :which-key "Repeat")
    "r"   '(async-shell-command :which-key "Run command")
    "R"   '(shell-command :which-key "Run command synchronously"))
  <<keybindings>>
  )
#+end_src
**** Assorted Keybindings
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
***** Quit
#+begin_src emacs-lisp
(my/general-global-menu! "Quit" "q"
  "q" '(save-buffers-kill-terminal :which-key "Quit Emacs")
  "Q" '(kill-emacs :which-key "Quit Emacs immediately")
  "r" '(restart-emacs :which-key "Restart Emacs")
  "R" '(restart-emacs--daemon :which-key "Restart Emacs daemon")
  "d" '(restart-emacs-debug-init :which-key "Restart Emacs with debug init"))


(message "Loading general-global-menu... Done")
#+end_src
***** Buffer
#+begin_src emacs-lisp
(defun my/kill-buffer (&optional buf)
  (interactive)
  (let ((buf (or buf (current-buffer)))
        (kill-buffer-query-functions '()))
    (kill-buffer buf)))

(defun my/kill-other-window ()
  (interactive)
  (my/do-in-other-window (lambda () (progn (my/kill-buffer) (delete-window)))))
        

(my/general-global-menu! "Buffer" "b"
  "B" '(switch-to-buffer-other-window :which-key "Switch buffer other window")
  "d" '(kill-current-buffer :which-key "Kill current buffer")
  "k" '(my/kill-buffer :which-key "Kill buffer")
  "K" '(my/kill-other-window :which-key "Kill buffer other window")
  "r" '(revert-buffer :which-key "Revert buffer")
  "[" '(previous-buffer :which-key "Previous buffer")
  "]" '(next-buffer :which-key "Next buffer")
  "n" '(next-buffer :which-key "Next buffer")
  "p" '(previous-buffer :which-key "Previous buffer")
  "s" '(save-buffer :which-key "Save buffer")
  "S" '(save-some-buffers :which-key "Save some buffers")
  "u" '(bury-buffer :which-key "Bury buffer")
  "U" '(unbury-buffer :which-key "Unbury buffer")
  "x" '(scratch-buffer :which-key "Open scratch buffer"))
(my/leader-def
  "x" '(scratch-buffer :which-key "Open scratch buffer"))
#+end_src
***** Code
#+begin_src emacs-lisp
(my/general-global-menu! "Code" "c"
  "c" '(recompile :which-key "Recompile")
  "C" '(compile :which-key "Compile"))
#+end_src
***** File
#+begin_src emacs-lisp
(defun my/find-file-other-window ()
  (interactive)
  (my/do-in-other-window #'find-file))
(defun my/find-file-sudo ()
  (interactive)
  (let ((file-name (read-file-name "Find file (as root): ")))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(defun my/this-file-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(my/general-global-menu! "File" "f"

  "f" '(find-file :which-key "Find file")
  "F" '(find-file-other-window :which-key "Find file other window")
  "s" '(save-buffer :which-key "Save buffer")
  "S" '(write-file :which-key "Save file as")
  "r" '(recentf-open-files :which-key "Recent files")
  "R" '(rename-file :which-key "Rename file")
  "d" '(delete-file :which-key "Delete file")
  "u" '(my/find-file-sudo :which-key "Find file as root")
  "U" '(my/this-file-sudo :which-key "Open this file as root"))
#+end_src
***** Git
#+begin_src emacs-lisp
(my/general-global-menu! "Git" "g")
#+end_src
***** Open
#+begin_src emacs-lisp
(defvar my/open-proc (cond (IS-MAC "open")
                           (IS-LINUX "xdg-open"))
  "The defualt process to open files with.")
(defun my/default-open (file)
  (interactive)
  (start-process my/open-proc nil my/open-proc file))

(my/general-global-menu! "Open" "o"
                         "o" '((lambda () (interactive) (my/default-open (buffer-file-name))) :which-key "Open file")
                         "s" '(shell :which-key "Shell"))
#+end_src
***** REPL
#+begin_src emacs-lisp
(defvar my/repl-alist '((emacs-lisp-mode . ielm)
                        (fallback . my/repl-fallback))
  "Alist of modes to repls.")
(defvar my/repl-fallback #'shell "The fallback repl to use.")
(defun my/repl--open-or-create ()
  (let* ((mode (buffer-local-value 'major-mode (current-buffer)))
	 (repl (alist-get mode my/repl-alist my/repl-fallback))
	 (repl-buffer-name (concat "*"
				   (symbol-name (if (eq repl my/repl-fallback) mode repl))
				   ":repl*")))
    (if (get-buffer repl-buffer-name)
	(popper--find-buried-popups (get-buffer repl-buffer-name))
      (progn
	(add-popup! repl-buffer-name)
	(funcall repl)
	(rename-buffer repl-buffer-name)))))
(defun my/repl--choose (arg)
  (interactive (list (completing-read "Choose repl: " (mapcar #'symbol-name (mapcar #'car my/repl-alist)) nil t)))
  (let* ((repl (if (string= arg "fallback")
                   my/repl-fallback
                 (alist-get (intern arg) my/repl-alist my/repl-fallback)))
	 (repl-buffer-name (concat "*"
				   (symbol-name repl)
				   ":repl*")))
    (if (get-buffer repl-buffer-name)
        (popper-raise-popup (get-buffer repl-buffer-name))
      (progn
	(add-popup! repl-buffer-name)
	(funcall repl)
	(rename-buffer repl-buffer-name)))))

(defun my/repl (arg)
  (interactive "P")
  (if arg
      (call-interactively #'my/repl--choose)
    (my/repl--open-or-create)))
(my/general-global-Open "r" '(my/repl :which-key "REPL"))
#+end_src
***** Toggle
#+begin_src emacs-lisp
(defun my/toggle-comment (beg end)
  "Comment or uncomment current region or line."
  (interactive (if (use-region-p)
		   (list (region-beginning) (region-end))
		 (list (line-beginning-position) (line-end-position))))
  (comment-or-uncomment-region beg end))
(my/general-global-menu! "Toggle" "t"
  "d" '(toggle-debug-on-error :which-key "debug")
  "/" '(comment-or-uncomment-region :which-key "comment"))
#+end_src
***** Search
#+begin_src emacs-lisp
(my/general-global-menu! "Search" "s")
#+end_src

** Hydra
#+begin_src emacs-lisp
(use-package hydra
  :demand
  :unless noninteractive
  :after (general evil)
  :config
  (defhydra my/zoom-hydra ()
    ("=" text-scale-increase "zoom in")
    ("k" text-scale-increase "zoom in")
    ("j" text-scale-decrease "zoom out")
    ("-" text-scale-decrease "zoom out"))
  (my/general-global-menu! "Hydras" "H"
    "=" '(my/zoom-hydra/body :which-key "Zoom")
    "-" '(my/zoom-hydra/body :which-key "Zoom")))
#+end_src
** evil
#+begin_src emacs-lisp
(use-package evil
  :unless noninteractive
  :init
  (setq evil-want-integration t
	evil-want-keybinding nil
	evil-want-C-u-scroll t
	evil-want-C-i-jump t
	select-enable-clipboard nil)
  :config
  (evil-mode)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)

  (my/leader-def
    "w" '(:keymap evil-window-map :which-key "Window"))
  (my/leader-def
    "u"  '(universal-argument :which-key "Universal argument")))

(use-package evil-collection
  :after evil
  :unless noninteractive
  :custom
  (evil-collection-setup-minibuffer t)
  :config
  (unless noninteractive
    (evil-collection-init))
  (general-def minibuffer-local-map
    :states 'normal
    [escape] 'abort-recursive-edit))
#+end_src
*** evil-surround
#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :unless noninteractive
  :general
  (:states 'operator
	   "s" 'evil-surround-edit
	   "S" 'evil-Surround-edit)
  (:states 'visual
	   "S" 'evil-surround-region
	   "gS" 'evil-Surround-region)
  :config (global-evil-surround-mode 1))
#+end_src
*** evil-commentary
#+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :unless noninteractive
  :config
  (evil-commentary-mode))
#+end_src
*** evil-nerd-commenter
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :unless noninteractive
  :config
  (evilnc-default-hotkeys))
#+end_src
*** evil-goggles
#+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :unless noninteractive
  :init
  (setq evil-goggles-duration 0.05)
  :config
  (push '(evil-operator-eval
          :face evil-goggles-yank-face
          :switch evil-goggles-enable-yank
          :advice evil-goggles--generic-async-advice)
        evil-goggles--commands)
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces)
  )
#+end_src
*** evil-snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :unless noninteractive
  :config
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))
#+end_src
*** evil-mc
#+begin_src emacs-lisp
(use-package evil-mc
  :after evil
  :unless noninteractive
  :init
  (use-package evil-multiedit)
  (use-package evil-iedit-state)
  :config
  (general-nmap "g>" 'my/mc-hydra/body)
  (general-vmap "g>" 'my/mc-hydra/body)
  (general-nmap
    "gm"  '(:keymap evil-mc-cursors-map :which-key "Multi-cursor") 
    "M-d" 'evil-mc-make-and-goto-next-match
    "M-S-d" 'evil-mc-make-and-goto-prev-match)
  (general-vmap
    "A" 'evil-mc-make-cursor-in-visual-selection-end
    "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  (my/general-global-menu! "Multi-Cursor" "c m"
    "a" '(evil-mc-make-all-cursors :which-key "Make all cursors")
    "n" '(evil-mc-make-and-goto-next-match :which-key "Make and go to next match")
    "N" '(evil-mc-make-and-goto-prev-match :which-key "Make and go to previous match")
    "q" '(evil-mc-undo-all-cursors :which-key "Undo all cursors"))
  (defhydra my/mc-hydra
    (:color pink :hint nil :pre (evil-mc-pause-cursors))
    "
^Match^            ^Line-wise^           ^Manual^
^^^^^^----------------------------------------------------
_Z_: match all     _J_: make & go down   
_m_: make & next   _K_: make & go up     
_M_: make & prev   ^ ^                   _R_: remove all
_n_: skip & next   ^ ^                   
_N_: skip & prev

Current pattern: %`evil-mc-pattern

"
    ("Z" #'evil-mc-make-all-cursors)
    ("n" #'evil-mc-make-and-goto-next-match)
    ("N" #'evil-mc-make-and-goto-prev-match)
    ("m" #'evil-mc-skip-and-goto-next-match)
    ("M" #'evil-mc-skip-and-goto-prev-match)
    ("J" #'evil-mc-make-cursor-move-next-line)
    ("K" #'evil-mc-make-cursor-move-prev-line)
    ("R" #'evil-mc-undo-all-cursors)
    ("q" #'evil-mc-resume-cursors "quit" :color blue)
    ("<escape>" #'evil-mc-resume-cursors "quit" :color blue))
  (my/general-global-Hydras
    "m" '(my/mc-hydra/body :which-key "Multi Cursor"))
  (global-evil-mc-mode 1))
#+end_src
*** Extra Text Objects
#+begin_src emacs-lisp
(use-package targets
  :config
  (setq targets-composite-text-objects
	'((all-quotes
	   (("\"" "\"" quote)
	    ("'" "'" quote)
	    ("`" "`" quote)
	    ("‘" "’" quote)
	    ("“" "”" quote))
	   :bind t
	   :keys "q")
	  (all-brackets
	   (("[" "]" pair)
	    ("{" "}" pair)
	    ("<" ">" pair)
	    ("</" ">" )
	    ("(" ")" pair))
	   :bind t
	   :keys "b")))
  (targets-setup t))
#+end_src
** which-key
#+begin_src emacs-lisp
(use-package which-key
  :unless noninteractive
  :hook (after-init . which-key-mode)
  :diminish
  :config
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.01
        which-key-max-description-length 32
        which-key-sort-order 'which-key-key-order-alpha
        which-key-allow-evil-operators t
        which-key-prefix-prefix "+"))
#+end_src
* UI
** Fancy Compile
#+begin_src emacs-lisp
(use-package ansi-color
  :unless noninteractive
  :ensure nil
  :hook  (compilation-filter . ansi-color-compilation-filter))
#+end_src
** Fonts
#+begin_src emacs-lisp
(defconst my/font/name "JetBrainsMono Nerd Font Mono") ;; ligatures assumes this font
(defvar my/font/size 180)
(defvar my/font/unicode-name "Julia Mono")



(set-face-attribute 'default nil :font my/font/name :height my/font/size)
(set-face-attribute 'fixed-pitch nil :font my/font/name :height my/font/size)
(set-face-attribute 'variable-pitch nil :font my/font/name :height my/font/size :weight 'regular)
#+end_src
*** Ligatures
#+begin_src emacs-lisp
(defun my/font/enable-ligatures ()
  "Enable ligatures for Jetbrains"
  (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
		 (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
		 (36 . ".\\(?:>\\)")
		 (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
		 (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
		 (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
		 (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
		 (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
		 (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
		 (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
		 (48 . ".\\(?:x[a-zA-Z]\\)")
		 (58 . ".\\(?:::\\|[:=]\\)")
		 (59 . ".\\(?:;;\\|;\\)")
		 (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
		 (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
		 (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
		 (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
		 (91 . ".\\(?:]\\)")
		 (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
		 (94 . ".\\(?:=\\)")
		 (119 . ".\\(?:ww\\)")
		 (123 . ".\\(?:-\\)")
		 (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
		 (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
		 )))
    (dolist (char-regexp alist)
      (set-char-table-range composition-function-table (car char-regexp)
                            `([,(cdr char-regexp) 0 font-shape-gstring])))))
(add-hook 'after-init-hook #'my/font/enable-ligatures)
#+end_src
*** Prettify symbols
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init
  (cl-defmacro my/prettify-symbols-extend (&rest pairs &allow-other-keys)
    "Extend the alist of `prettify-symbols-alist' with PAIRS."
    (declare (indent 0))
    `(setq prettify-symbols-alist
	   (-concat prettify-symbols-alist '(,@pairs))))
  (cl-defmacro my/prettify-symbols-extend-mode (mode &rest pairs &allow-other-keys)
    "Extend the alist of `prettify-symbols-alist' with PAIRS for MODE."
    (declare (indent 1))
    `(add-hook (intern (concat (symbol-name ,mode) "-hook"))
	       (lambda ()
		 (make-local-variable 'prettify-symbols-alist)
		 ,(macroexpand 
		   `(my/prettify-symbols-extend ,@pairs)))))
  :config
  (global-prettify-symbols-mode nil))
#+end_src
*** Emoji
#+begin_src emacs-lisp
(use-package emojify
  ;; :unless noninteractive
  :unless t
  :hook (after-init . global-emojify-mode)
  :config (setq emojify-styles '(unicode)))
#+end_src
*** Unicode
#+begin_src emacs-lisp
(use-package unicode-fonts
  :config
  (unicode-fonts-setup '(my/font/unicode-name))
  :init
  (my/leader-def
    "U" '(unicode-fonts-insert 'interactive "Insert Unicode char (by name)")))
#+end_src
** Dashboard
#+begin_src emacs-lisp
(use-package nerd-icons)
(use-package dashboard
  :unless noninteractive
  :hook (after-init . dashboard-setup-startup-hook)
  :init
  (setq dashboard-banner-logo-title "Welcome to Emacs Dashboard"
        dashboard-startup-banner 'logo
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-display-icons-p t
        dashboard-icon-type 'nerd-icons
        dashboard-projects-backend (if (package-installed-p 'projectile) 'projectile 'project)
        dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)
                          (registers . 5))
        dashboard-set-navigator t
        dashboard-set-init-info t
        inhibit-startup-screen t)

  (add-hook 'dashboard-mode-hook #'my/disable-line-numbers))
#+end_src
** Theme
#+begin_src emacs-lisp
(setq
 modus-themes-italic-constructs t
 modus-themes-bold-constructs t
 modus-themes-subtle-line-numbers nil
 modus-themes-tabs-accented t
 modus-themes-variable-pitch-ui t
 modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

 ;; Options for `modus-themes-prompts' are either nil (the
 ;; default), or a list of properties that may include any of those
 ;; symbols: `background', `bold', `gray', `intense', `italic'
 modus-themes-prompts '(background bold intense italic)

 ;; The `modus-themes-completions' is an alist that reads three
 ;; keys: `matches', `selection', `popup'.  Each accepts a nil
 ;; value (or empty list) or a list of properties that can include
 ;; any of the following (for WEIGHT read further below):
 ;;
 ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
 ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
 ;; `popup' - same as `selected'
 ;; `t' - applies to any key not explicitly referenced (check docs)
 ;;
 ;; WEIGHT is a symbol such as `semibold', `light', or anything
 ;; covered in `modus-themes-weights'.  Bold is used in the absence
 ;; of an explicit WEIGHT.
 modus-themes-completions
 '((matches . (semibold))
   (selection . (extrabold accented))
   (popup . (extrabold accented)))

 modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

 ;; The `modus-themes-headings' is an alist with lots of possible
 ;; combinations, include per-heading-level tweaks: read the
 ;; manual or its doc string
 modus-themes-headings
 '((0 . (variable-pitch light (height 2.2)))
   (1 . (rainbow variable-pitch light (height 1.6)))
   (2 . (rainbow variable-pitch light (height 1.4)))
   (3 . (rainbow variable-pitch regular (height 1.3)))
   (4 . (rainbow regular (height 1.2)))
   (5 . (rainbow (height 1.1)))
   (t . (variable-pitch extrabold))))

(setq modus-themes-italic-constructs t
      modus-themes-bold-constructs t
      modus-themes-mixed-fonts t
      modus-themes-variable-pitch-ui t
      modus-themes-custom-auto-reload nil
      modus-themes-disable-other-themes t

      ;; Options for `modus-themes-prompts' are either nil (the
      ;; default), or a list of properties that may include any of those
      ;; symbols: `italic', `WEIGHT'
      modus-themes-prompts '(italic bold)

      ;; The `modus-themes-completions' is an alist that reads two
      ;; keys: `matches', `selection'.  Each accepts a nil value (or
      ;; empty list) or a list of properties that can include any of
      ;; the following (for WEIGHT read further below):
      ;;
      ;; `matches'   :: `underline', `italic', `WEIGHT'
      ;; `selection' :: `underline', `italic', `WEIGHT'
      modus-themes-completions
      '((matches . (semibold))
        (selection . (extrabold accented)))

      modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

      ;; The `modus-themes-headings' is an alist: read the manual's
      ;; node about it or its doc string.  Basically, it supports
      ;; per-level configurations for the optional use of
      ;; `variable-pitch' typography, a height value as a multiple of
      ;; the base font size (e.g. 1.5), and a `WEIGHT'.
      modus-themes-headings
      '((1 . (variable-pitch 1.5))
        (2 . (1.3))
        (agenda-date . (1.3))
        (agenda-structure . (variable-pitch light 1.8))
        (t . (1.1))))

(load-theme 'modus-operandi t)
(setq modus-themes-to-toggle '(modus-operandi modus-vivendi))
(my/general-global-Toggle
  "t" '(modus-themes-toggle :which-key "theme"))
#+end_src

** Indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :unless noninteractive
  :hook (prog-mode . highlight-indent-guides-mode)
  :hook (conf-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-delay 0))
#+end_src
** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :unless noninteractive
  :init
  (unless (equal "Battery status not available"
		 (battery))
    (display-battery-mode 1))
  :config (doom-modeline-mode 1)
  :custom
  (doom-modeline-height 15)
  (doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode)))
  #+end_src
** Word Wrapping
#+begin_src emacs-lisp
(global-visual-line-mode t)
(my/general-global-Toggle
 "w" '(visual-line-mode :which-key "Word wrap"))
#+end_src
** Rainbow delimeters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Highlight todos
#+begin_src emacs-lisp
(use-package hl-todo
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode))
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"       warning bold)
          ("FIXME"      error bold)
          ("REVIEW"     font-lock-keyword-face bold)
          ("NOTE"       success bold)
          ("DEPRECATED" font-lock-doc-face bold))))
#+end_src
** Popper
#+begin_src emacs-lisp
(use-package popper
  :unless noninteractive
  :demand t
  :bind (:map popper-mode-map
              ("C-`"   . popper-toggle)
              ("M-`"   . popper-cycle)
              ("C-M-`" . popper-toggle-type))
  :general (my/general-global-menu! "Popper" "`"
            "`" '(popper-toggle :which-key "Toggle latest")
             "c" '(popper-cycle :which-key "Cycle")
             "T" '(popper-toggle-type :which-key "Toggle type"))
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "\\*helpful .*\\*"
          "\\*.*:repl\\*"
          "\\*scratch\\*"
          help-mode
          compilation-mode))

  (setq popper-group-function #'popper-group-by-directory
	popper-display-function #'display-buffer-at-bottom)
  (cl-defmacro add-popup! (&rest rules)
    "Add popup rules."
    `(after! popper
	     (append! popper-reference-buffers ,@rules)
	     (popper--set-reference-vars)))
  :config
  (popper-mode +1)
  ;;(popper-echo-mode +1)
  ;; Hook to auto close a window when a popup buffer in that window is killed
  (defun my/kill-buffer-advice (orig-fn &rest args)
    "Advice function to close the window after killing the buffer."
    (let ((buf (current-buffer)))
      (when (popper-popup-p buf)
        (delete-window (get-buffer-window buf)))
      (apply orig-fn args)))
  (add-hook 'after-hook-hook (lambda () (advice-add 'kill-buffer :around #'my/kill-buffer-advice))))
(when noninteractive
  (defmacro add-popup! (&rest _)))
#+end_src
* Bookmarks
** Evil
#+begin_src emacs-lisp
(use-package evil-fringe-mark
  :unless noninteractive
  :requires evil
  :after evil
  :hook (after-init . global-evil-fringe-mark-mode)
  :general (my/general-global-Toggle "f" '(evil-fringe-mark-mode :which-key "Evil Marks"))
  :init
  ;; Persist global marks
  (after! savehist
	  (add-to-list 'savehist-additional-variables 'evil-markers-alist))
  ;; Persist local marks
  (append! desktop-locals-to-save evil-markers-alist)
  ;; Show Marks in buffer
  (my/general-global-Open "`" '(evil-show-marks :which-key "Show marks"))
  :config (setq evil-fringe-mark-show-special t))
#+end_src

** Bookmark
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :unless noninteractive
  :after evil
  :config (my/general-global-menu! "Bookmarks" "B"
             "b" '(bookmark-jump :which-key "Jump")
             "l" '(bookmark-bmenu-list :which-key "List")
             "s" '(bookmark-set :which-key "Set")
             "r" '(bookmark-rename :which-key "Rename")
             "d" '(bookmark-delete :which-key "Delete")
             "a" '(bookmark-set :which-key "Add"))
  :init
  (setq bookmark-default-file (concat my/cache-dir "bookmarks")
        bookmark-save-flag 1))
#+end_src
* Project management
** Projectile
#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :unless noninteractive
  :config
  (projectile-mode +1)
  (my/leader-def
    "p" '(:keymap projectile-command-map :which-key "projectile"))
  (setq projectile-switch-project-action #'projectile-dired)
  (defvar my/projectile-ignore-projects '("^/sudo:" "^/docker:" "^/nix/store"))
  (defun my/projectile-ignore-projects (project-root)
    "Ignore matching regexes in `my/projectile-ignore-projects'."
    (cl-some (lambda (regex) (string-match-p regex project-root))
	     my/projectile-ignore-projects))
  (setq projectile-ignored-project-function #'my/projectile-ignore-projects))
#+end_src
** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :custom
  (persp-mode-prefix-key nil)
  (persp-suppress-no-prefix-key-warning t)
  (persp-state-default-file  (concat my/local-dir "perspective"))
  (persp-sort 'created)
  :hook (after-init . persp-mode)
  :config
  (my/leader-def
    "TAB" '(:keymap perspective-map :which-key "Workspaces"))
  (general-def :keymaps 'perspective-map
    "TAB" '(persp-switch :which-key "Switch"))
  :hook (ibuffer . (lambda ()
		     (persp-ibuffer-set-filter-groups)
		     (unless (eq ibuffer-sorting-mode 'alphabetic)
		       (ibuffer-do-sort-by-alphabetic))))
  :hook (kill-emacs . persp-state-save))
#+end_src
** Tabs
#+begin_src emacs-lisp :tangle no
(use-package tabspaces
  ;; use this next line only if you also use straight, otherwise ignore it. 
  :hook (after-init . tabspaces-mode) ;; use this only if you want the minor-mode loaded at startup. 
  ;; :commands (tabspaces-switch-or-create-workspace
  ;;            tabspaces-open-or-create-project-and-workspace)
  :custom
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "Default")
  (tabspaces-remove-to-default t)
  (tabspaces-include-buffers '("*scratch*"))
  (tabspaces-initialize-project-with-todo t)
  (tabspaces-todo-file-name "project-todo.org")
  ;; sessions
  (tabspaces-session t)
  (tabspaces-session-auto-restore t)
  (tabspaces-session-file (concat my/cache-dir "tabspaces.el"))
  (tabspaces-keymap-prefix nil)
  :config
  (my/general-global-menu! "Workspaces" "TAB"
    "C" '(tabspaces-clear-buffers :which-key "Clear buffers")
    "r" '(tabspaces-remove-current-buffer :which-key "Remove current buffer")
    "R" '(tabspaces-remove-selected-buffer :which-key "Remove selected buffer")
    "d" '(tabspaces-close-workspace :which-key "Delete workspace")
    "D" '(tabspaces-kill-buffers-close-workspace :which-key "Delete workspace and kill buffers")
    "o" '(tabspaces-open-or-create-project-and-workspace :which-key "Open/Create project ws")
    "s" '(tabspaces-switch-or-create-workspace :which-key "Switch/Create ws")
    "TAB" '(tabspaces-switch-or-create-workspace :which-key "Switch/Create ws")
    "t" '(tabspaces-switch-buffer-and-tab :which-key "Switch buffer and tab")
    "b" '(tabspaces-switch-to-buffer :which-key "Switch buffer"))
  (setopt tab-bar-show nil))
  #+end_src
* Buffer management
#+begin_src emacs-lisp
(use-package ibuffer
  :unless noninteractive
  :ensure nil
  :general (my/general-global-Buffer
	     "i" '(ibuffer :which-key "ibuffer"))
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-saved-filters nil)
  (define-ibuffer-column size
    (:name "Size" :inline t)
    (file-size-human-readable (buffer-size))))
; next/prev buffer skip special buffers
(setq switch-to-prev-buffer-skip-regexp '("^\\*.*\\*$"))
#+end_src
* Dired
#+begin_src emacs-lisp
(use-package dired
  :unless noninteractive
  :ensure nil
  :general (my/general-global-Open "d" '(dired :which-key "dired"))
  :config
  (setq dired-listing-switches "-alh --group-directories-first"
	dired-dwim-target t
	dired-recursive-copies 'always
	dired-recursive-deletes 'always
	dired-hide-details-hide-symlink-targets nil
	dired-hide-details-hide-information-lines nil
	insert-directory-program (if IS-MAC (executable-find "gls") insert-directory-program)
	dired-use-ls-dired t
	dired-auto-revert-buffer t
      dired-kill-when-opening-new-dired-buffer t)
  (add-hook 'dired-mode-hook #'hl-line-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode))
#+end_src
* Tree Sitter
#+begin_src emacs-lisp
(use-package treesit-auto
  :unless noninteractive
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src
**** Tree Sitter
#+begin_src emacs-lisp
(use-package evil-textobj-tree-sitter
  :after (evil treesit)
  :unless noninteractive
  :config
  (defun meain/fancy-narrow-to-thing (thing)
    (interactive)
    (if (buffer-narrowed-p) (fancy-widen))
    (let ((range (evil-textobj-tree-sitter--range 1 (list (intern thing)))))
      (fancy-narrow-to-region (car range) (cdr range))))
  (my/general-global-menu! "Narrow" "N"
    "n" `(,(lambda () (interactive) (fancy-widen)) :which-key "widen")
    "f" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "function.outer")) :which-key "function")
    "c" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "class.outer")) :which-key "class")
    "C" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "comment.outer")) :which-key "comment")
    "o" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "loop.outer")) :which-key "loop")
    "i" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "conditional.outer")) :which-key "conditional")
    "a" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "parameter.outer")) :which-key "parameter"))
  ;; copied from doomemacs
  (defvar +tree-sitter-inner-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-outer-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-previous-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-next-map (make-sparse-keymap))

  (define-minor-mode my/treesit-mode "My treesit mode. For easily binding keys"
    :interactive nil)

  (evil-define-key '(visual operator) 'my/treesit-mode
    "i" +tree-sitter-inner-text-objects-map
    "a" +tree-sitter-outer-text-objects-map)
  (evil-define-key 'normal 'my/treesit-mode
    "[g" +tree-sitter-goto-previous-map
    "]g" +tree-sitter-goto-next-map)
  (general-def :keymaps '+tree-sitter-inner-text-objects-map
    "A" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.inner" "call.inner")) :which-key "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.inner") :which-key "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.inner") :which-key "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.inner") :which-key "class")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.inner") :which-key "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.inner") :which-key "loop")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.inner") :which-key "comment"))
  (general-def :keymaps '+tree-sitter-outer-text-objects-map
    "A" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")) :which-key "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.outer") :which-key "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.outer") :which-key "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.outer") :which-key "class")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.outer") :which-key "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.outer") :which-key "loop")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.outer") :which-key "comment"))
  (general-def :keymaps '+tree-sitter-goto-previous-map
    "A" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer") t) :which-key "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.outer" t) :which-key "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.outer" t) :which-key "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.outer" t) :which-key "class")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.outer" t) :which-key "comment")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.outer" t) :which-key "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.outer" t) :which-key "loop"))
  (general-def :keymaps '+tree-sitter-goto-next-map
    "A" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")) :which-key "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.outer") :which-key "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.outer") :which-key "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.outer") :which-key "class")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.outer") :which-key "comment")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.outer") :which-key "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.outer") :which-key "loop")))
#+end_src
* Eval region
#+begin_src emacs-lisp
(after! evil
	(defun my/elisp-eval-region (beg end)
	  (interactive "r")
	  (eval-region beg end t))
	(defvar my/evil-extra-operator-eval-modes-alist
	  '((emacs-lisp-mode my/elisp-eval-region)))

	(evil-define-operator my/evil-operator-eval (beg end)
	  :move-point nil
	  (interactive "<r>")
	  (let* ((mode (if (org-in-src-block-p) (intern (car (org-babel-get-src-block-info))) major-mode))
		 (ele (assoc mode my/evil-extra-operator-eval-modes-alist))
		 (f-a (cdr-safe ele))
		 (func (car-safe f-a))
		 (args (cdr-safe f-a)))
	    (if (fboundp func)
		(apply func beg end args)
	      (eval-region beg end t))))
	(define-key evil-motion-state-map "gr" 'my/evil-operator-eval))
#+end_src
* Aggressive Indent Mode
#+begin_src emacs-lisp
(use-package aggressive-indent
  :unless noninteractive
  :config
  (global-aggressive-indent-mode 1))
#+end_src
* Calc
#+begin_src emacs-lisp
(use-package calc
  :unless noninteractive
  :ensure nil ;; built-in
  :general (my/general-global-Open
	     "c" '(calc :which-key "calc")
	     "C" '(full-calc :which-key "full-calc"))
  :config
  (setq calc-angle-mode 'rad
	calc-algebraic-mode t
        calc-display-trail t
        calc-group-digits t
        calc-line-numbering t
        calc-multiplication-has-precedence t
        calc-number-radix 10
        calc-symbolic-mode t
        calc-undo-length 1000
        calc-window-height 15)
  (add-hook 'calc-mode-hook #'my/disable-line-numbers))
#+end_src
* String Inflection
#+begin_src emacs-lisp
(use-package string-inflection
  :unless noninteractive
  :after evil
  :general (my/general-global-menu! "naming convention" "c ~"

             "~" '(string-inflection-all-cycle :which-key "cycle")
	     "t" '(string-inflection-toggle :which-key "toggle")
	     "c" '(string-inflection-camelcase :which-key "CamelCase")
	     "d" '(string-inflection-lower-camelcase :which-key "downCase")
	     "k" '(string-inflection-kebab-case :which-key "kebab-case")
	     "_" '(string-inflection-underscore :which-key "under_score")
	     "u" '(string-inflection-capital-underscore :which-key "Upper_Score")
	     "U" '(string-inflection-upcase :which-key "UP_CASE"))
  :init
  
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection))
    #+end_src
* Smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :unless noninteractive
  :general (my/general-global-Toggle "p" #'smartparens-mode)
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  (sp-show-pair-from-inside t)
  (sp-cancel-autoskip-on-backward-movement nil)
  (sp-pair-overlay-keymap (make-sparse-keymap))
  (sp-max-prefix-length 25)
  (sp-max-pair-length 4)
  :hook (prog-mode . smartparens-mode)
  :hook (prog-mode . show-smartparens-mode)
  :config
  (require 'smartparens-config)
  (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode emacs-lisp-mode) "'" nil :actions nil)
  (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode emacs-lisp-mode) "`" nil :actions nil)
  (show-smartparens-global-mode t))
(use-package evil-smartparens
  :unless noninteractive
  :after (evil smartparens)
  :hook (smartparens-mode . evil-smartparens-mode)
  :hook (smartparens-strict-mode . evil-smartparens-mode))
#+end_src
* Help
** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :unless noninteractive
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-command] . helpful-command)
  :config
  (general-nmap
    "K" #'helpful-at-point)
  (after! undo-tree
	  (append! undo-tree-incompatible-major-modes #'helpful-mode)))
#+end_src
** Man & TLDR
#+begin_src emacs-lisp
(use-package tldr
  :unless noninteractive
  :commands (tldr tldr-update-docs)
  :init
  (my/general-global-menu! "Command line help" "h h"
                           "t" '(tldr :which-key "tldr")
                           "h" '(man :which-key "man")
                           "w" '(woman :which-key "Woman"))
  :config
  (setq tldr-directory-path (concat my/cache-dir "tldr/")))
#+end_src
** Devdocs
#+begin_src emacs-lisp
(use-package devdocs
  :general (:keymaps 'help-map
		     "d" '(devdocs-lookup :which-key "Devdocs")))
#+end_src
* Undo
** Undo Fu
#+begin_src emacs-lisp
(unless noninteractive
  (use-package undo-fu
    :demand t
    :custom
    (undo-limit         (* 512 1024 1024))
    (undo-strong-limit  (* 1024 1024 1024))
    (undo-outer-limit   (* 2 1024 1024 1024))
    (evil-undo-system 'undo-redo)
    :bind
    ([remap undo] . undo-fu-only-undo)
    ([remap redo] . undo-fu-only-redo)
    ("C-_"        . undo-fu-only-undo)
    ("M-_"        . undo-fu-only-redo)
    ("C-M-_"      . undo-fu-only-redo-all))
  (use-package undo-fu-session
    :after undo-fu
    :demand t
    :hook (after-init . global-undo-fu-session-mode)
    :bind
    ("C-x r u"    . undo-fu-session-save)
    ("C-x r U"    . undo-fu-session-recover)
    :custom
    (undo-fu-session-directory (concat my/cache-dir "undo-fu-session/"))
    (undo-fu-session-compression 'zst)))
#+end_src

** Vundo
#+begin_src emacs-lisp
(use-package vundo
  :unless noninteractive
  :custom
  (vundo-compact-display nil)
  (vundo-glyph-alist vundo-unicode-symbols))
#+end_src
* Completion
** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :unless noninteractive
  :demand
  :bind (:map corfu-map
              ("TAB" . corfu-next)
              ([tab] . corfu-next)
              ("S-TAB" . corfu-previous)
              ([backtab] . corfu-previous))
  :custom
  (corfu-cycle t)
  (corfu-auto t)                 ;; Enable auto completion
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  (corfu-preselect 'prompt)      ;; Preselect the prompt
  (corfu-on-exact-match nil)     ;; Configure handling of exact matches
  (corfu-scroll-margin 5)        ;; Use scroll margin
  :config
  (global-corfu-mode)
  (defun corfu-move-to-minibuffer ()
    (interactive)
    ;; close corfu popup then move to minibuffer
    (when completion-in-region--data
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
	(apply #'consult-completion-in-region completion-in-region--data))))
  (general-def 'insert corfu-map "C-j" #'corfu-move-to-minibuffer)
  (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)
  (add-hook 'corfu-mode #'corfu-popupinfo-mode)
  (setq corfu-popupinfo-delay '(0.25 . 0.25)))
(use-package emacs
  :ensure nil
  :init
  (setq completion-cycle-threshold t)

  ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  (setq read-extended-command-predicate #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
;; Use Dabbrev with Corfu!
(use-package dabbrev
  :unless noninteractive
  :ensure nil
  ;; Swap M-/ and C-M-/
  :bind (("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand))
  ;; Other useful Dabbrev configurations.
  :custom
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src
*** Corfu Popup Info
#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-hide nil)
  (corfu-popupinfo-delay '(0.25 . 0)))
#+end_src
*** Corfu History
#+begin_src emacs-lisp
(use-package corfu-history
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-history-mode)
  :config)
  ;; (after! savehist
  ;; 	  (append! savehist-additional-variables corfu-history)))
#+end_src
** Icons
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :requires corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
** Cape
#+begin_src emacs-lisp
(use-package cape
  :unless noninteractive
  :general (my/general-global-menu! "Completions" "c p"
             "p" '(completion-at-point :which-key "Complete at point")
             "t" '(complete-tag :which-key "Complete tag")
             "d" '(cape-dabbrev :which-key "Dabbrev")
             "f" '(cape-file :which-key "File")
             "k" '(cape-keyword :which-key "Keyword")
             "s" '(cape-symbol :which-key "Symbol")
             "a" '(cape-abbrev :which-key "Abbrev")
             "i" '(cape-ispell :which-key "Ispell")
             "l" '(cape-line :which-key "Line")
             "w" '(cape-dict :which-key "Dict")
             "\\" '(cape-tex :which-key "Tex")
             "_" '(cape-tex :which-key "Tex")
             "^" '(cape-tex :which-key "Tex")
             "&" '(cape-sgml :which-key "Sgml")
             "r" '(cape-rfc1345 :which-key "Rfc1345"))
  :config
  (append! completion-at-point-functions
    #'cape-abbrev
    #'cape-file
    #'cape-elisp-block
    #'cape-history
    ;;#'cape-tex
    #'cape-keyword
    ;;#'cape-sgml
    ;;#'cape-rfc1345
    #'cape-symbol
    ;;#'cape-line
    #'cape-dict
    #'cape-ispell
    ))
#+end_src
** Fussy
#+begin_src emacs-lisp
(use-package fussy
  :unless noninteractive
  :config
  (push 'fussy completion-styles)
  (setq
   ;; For example, project-find-file uses 'project-files which uses
   ;; substring completion by default. Set to nil to make sure it's using
   ;; flx.
   completion-category-defaults nil
   completion-category-overrides nil))
#+end_src
** Tempel
#+begin_src emacs-lisp
(use-package tempel
  :unless noninteractive
  :custom
  (tempel-trigger-prefix "<")
  :general
  (:keymaps 'tempel-map "TAB" 'tempel-next) ;; progress through fields via `TAB'
  :init
  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
    ;; only triggers on exact matches. Alternatively use `tempel-complete' if
    ;; you want to see all matches, but then Tempel will probably trigger too
    ;; often when you don't expect it.
    ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
    ;; such that it will be tried first.
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))
  :hook (prog-mode . tempel-setup-capf)
  :hook (text-mode . tempel-setup-capf)
  :defer 1)
(use-package tempel-collection
  :after tempel
  :config
  (tempel-collection))
#+end_src
** Marginalia
#+begin_src emacs-lisp
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  :unless noninteractive
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))
  ;; load after completion-at-point
  :config (marginalia-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp
;; Enable orderless matching style.  See `+orderless-dispatch' in
;; `consult-config.el' for an advanced Orderless style dispatcher.
(use-package orderless
  :unless noninteractive
  :after vertico
  :custom
  (completion-styles '(orderless partial-completion basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src
** Vertico
#+begin_src emacs-lisp
;; Enable vertico
(use-package vertico
  :unless noninteractive
  :custom
  ;; Enable cycling for `vertico-next' and `vertico-previous'.
  (vertico-cycle t)
  ;; Grow and shrink the Vertico minibuffer
  (resize-mini-windows 'grow-only)
  (vertico-count 20)
  :config
  (vertico-mode)
  (after! embark
	  (general-def
	    :keymaps 'vertico-map
	    "C-c C-o" #'embark-export
	    "C-c C-c" #'embark-act
	    "C-c C-f" #'embark-become))
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src
** Consult
#+begin_src emacs-lisp
(use-package consult
  :unless noninteractive
  :general (my/leader-def
             "/" '(consult-ripgrep :which-key "Search project"))
  :general (my/general-global-Search
	     "s" '(consult-line :which-key "Search line"))
  :general (my/general-global-Buffer
	     "b" '(consult-buffer :which-key "Buffer selection"))
  :general (my/general-global-File
	     "r" '(consult-recent-file :which-key "Recent File"))
  :general (:keymaps 'help-map
		     "h m" '(consult-man :which-key "Manpage")))
(use-package consult-flymake
  :ensure consult
  :general (my/general-global-Errors
	     "f" '(consult-flymake :which-key "Consult Flymake")))
#+end_src
** Embark
#+begin_src emacs-lisp
(use-package embark
  :unless noninteractive
  :config
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  (setq which-key-use-C-h-commands nil
        prefix-help-command #'embark-prefix-help-command)
  (general-define-key [remap describe-bindings] #'embark-bindings)
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (setq embark-prompter 'embark-completing-read-prompter)
  (add-popup! #'embark-collect-mode)
  :general (my/general-global-menu! "Embark" "e"
	     "o" '(embark-export :which-key "export")
	     "e" '(embark-act :which-key "act")
	     "b" '(embark-bindings :which-key "bindings")
	     "c" '(embark-collect :which-key "collect"))
  :general (general-define-key
	    :prefix "C-c e"
	    "o" '(embark-export :which-key "export")
	    "e" '(embark-act :which-key "act")
	    "b" '(embark-bindings :which-key "bindings")
	    "c" '(embark-collect :which-key "collect")))
(use-package embark-consult
  :if (and (featurep 'embark)
	   (featurep 'consult))
  :after (embark consult)
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src
* Terminal
** EAT
#+begin_src emacs-lisp
(use-package eat
  :unless noninteractive
  :hook (eshell-load . eat-eshell-mode)
  :config
  (add-popup!
   "^\\*eat.*\\*$"  'eat-mode)
  (eat-eshell-mode))
#+end_src
** Vterm
#+begin_src emacs-lisp
(use-package vterm
  :unless noninteractive
  :commands vterm
  :custom
  (vterm-shell (or (getenv "SHELL") (executable-find "fish") (executable-find "bash")))
  :general (my/general-global-Open "t" '(vterm :which-key "vterm"))
  :config
  (defun my/vterm--auto-close-window (buf event)
    (when (y-or-n-p (concat event " - kill buffer: " (buffer-name buf) "?"))
      (kill-buffer-and-window)))
  (add-hook 'vterm-exit-functions #'my/vterm--auto-close-window)
  (add-popup!
   "^\\*vterm.*\\*$"  'vterm-mode)
  (add-hook 'vterm-mode-hook #'my/disable-line-numbers))
#+end_src
** Eshell
#+begin_src emacs-lisp
(use-package eshell
  :unless noninteractive
  :ensure nil
  :commands eshell
  :init
  (setq my/repl-fallback #'eshell)
  (my/general-global-Open
    "e" '(eshell :which-key "eshell"))
  (setq eshell-aliases-file (concat my/cache-dir "eshell/alias")
	eshell-history-file-name (concat my/cache-dir "eshell/history")
	eshell-buffer-maximum-lines 10000
	eshell-hist-ignoredups t
	eshell-scroll-to-bottom-on-input 'all
	eshell-error-if-no-glob t
	eshell-glob-case-insensitive t
	eshell-scroll-show-maximum-output nil)
  (make-directory (concat my/cache-dir "eshell") t)
  :config
  (add-popup! "^\\*eshell.*\\*$" 'eshell-mode)
  (add-hook 'eshell-mode-hook #'my/disable-line-numbers)
  (after! corfu (add-hook 'eshell-mode-hook #'corfu-mode)))
(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+end_src
* Formatting and linting/checking
** Format on save
#+begin_src emacs-lisp
(use-package apheleia
  :unless noninteractive
  :config (apheleia-global-mode +1))
#+end_src
** Linting
#+begin_src emacs-lisp
(use-package flycheck
  :unless noninteractive
  :general (my/general-global-menu! "Errors" "c e"
             "e" '(flycheck-list-errors :which-key "List errors")
             "n" '(flycheck-next-error :which-key "Next error")
             "p" '(flycheck-previous-error :which-key "Previous error")
             "d" '(flycheck-describe-checker :which-key "Describe checker")
             "v" '(flycheck-verify-setup :which-key "Verify setup"))
  :config
  (global-flycheck-mode)
  (add-popup! "^\\*Flycheck.*\\*$" #'flycheck-error-list-mode)
  :custom
  (flycheck-emacs-lisp-load-path 'inherit)
  (flycheck-display-errors-delay 0.25)
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-indication-mode 'right-fringe))
#+end_src
** Jinx
#+begin_src emacs-lisp
(use-package jinx
  :unless noninteractive
  :hook (emacs-startup . global-jinx-mode)
  :config
  (general-nmap
    "]s" '("Spelling error" . jinx-next)
    "[s" '("Spelling error" . jinx-previous)
    "z=" 'jinx-correct)
  (after! vertico
	  (require 'vertico-grid)
	  (require 'vertico-multiform)
	  (add-to-list 'vertico-multiform-categories
		       '(jinx grid (vertico-grid-annotate . 20)))
	  (vertico-multiform-mode 1)))
#+end_src
* Env
** Inherit ENV
#+begin_src emacs-lisp
(use-package inheritenv)
#+end_src
** direnv
#+begin_src emacs-lisp
(use-package envrc
  :hook (after-init . envrc-global-mode))
#+end_src
* Git
** Magit
#+begin_src emacs-lisp
(use-package magit
  :unless noninteractive
  :general (my/general-global-Git
             "g" '(magit-status :which-key "Status")
             "b" '(magit-blame :which-key "Blame")
             "l" '(magit-log :which-key "Log")
             "G" '(magit-status-here :which-key "Status here")
             "B" '(magit-blame-here :which-key "Blame here")
             "S" '(magit-stage-file :which-key "Stage file"))
  :init
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-log-arguments '("--graph" "--decorate" "--color"))
  (setq git-commit-fill-column 72)
  :config
  (add-popup! "\\*\\*magit-process:.*\\*\\*")
  (setq magit-buffer-name-format (concat "*" magit-buffer-name-format "*"))
  (append! magit-status-sections-hook #'magit-insert-modules)
  (evil-define-key* '(normal visual) magit-mode-map
    "zz" #'evil-scroll-line-to-center))
#+end_src
** Time Machine
#+begin_src emacs-lisp
(use-package git-timemachine
  :unless noninteractive
  :init (setq git-timemachine-show-minibuffer-details t)
  :config (add-hook 'git-timemachine-mode-hook 'evil-normalize-keymaps)
  :general
  (my/general-global-Git
    "t" '(git-timemachine :which-key "Time machine"))
  (:keymaps 'git-timemachine-mode-map
	    "C-k" 'git-timemachine-show-previous-revision
	    "C-j" 'git-timemachine-show-next-revision
	    "q" 'git-timemachine-quit))
#+end_src
** Git Gutter
#+begin_src emacs-lisp
(use-package git-gutter+
  :unless noninteractive
  :config
  (defhydra hydra-git-gutter (:body-pre (git-gutter+-mode 1)
					:hint nil)
    "
Git gutter:
  _j_: next hunk        _s_tage hunk     _q_uit
  _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
  ^ ^                   _p_opup hunk
  _h_: first hunk
  _l_: last hunk        _c_ommit staged hunks
"
    ("j" git-gutter+-next-hunk)
    ("k" git-gutter+-previous-hunk)
    ("h" (progn (goto-char (point-min))
		(git-gutter+-next-hunk 1)))
    ("l" (progn (goto-char (point-min))
		(git-gutter+-previous-hunk 1)))
    ("s" git-gutter+-stage-hunks)
    ("r" git-gutter+-revert-hunk)
    ("p" git-gutter+-popup-hunk)
    ;; ("R" git-gutter+-set-start-revision)
    ("c" git-gutter+-commit)
    ("q" nil :color blue)
    ("Q" (progn (git-gutter-mode -1)
		;; git-gutter-fringe doesn't seem to
		;; clear the markup right away
		(sit-for 0.1)
		(git-gutter+-clear))
     :color blue))
  (my/general-global-Hydras
    "g" '(hydra-git-gutter/body :which-key "Git"))
  (global-git-gutter+-mode t)
  (my/general-global-Git
    "n" '(git-gutter+-next-hunk :which-key "next hunk")
    "p" '(git-gutter+-previous-hunk :which-key "previous hunk")
    "s" '(git-gutter+-stage-hunks :which-key "stage hunk")
    "r" '(git-gutter+-revert-hunk :which-key "revert hunk")))
#+end_src
** Forge
#+begin_src emacs-lisp
(use-package forge
  :unless noninteractive
  :after magit
  :commands (forge-insert-assigned-pullreqs
	     forge-insert-authored-pullreqs
	     forge-insert-requested-reviews
	     forge-insert-assigned-issues
	     forge-insert-pullreqs
	     forge-insert-issues)
  :init
  (append! magit-status-sections-hook
    #'forge-insert-assigned-pullreqs
    #'forge-insert-authored-pullreqs
    #'forge-insert-requested-reviews
    #'forge-insert-assigned-issues
    #'forge-insert-pullreqs
    #'forge-insert-issues))
#+end_src
* Eglot
#+begin_src emacs-lisp
(use-package eglot
  :unless noninteractive
  :ensure nil ;; included in emacs29+
  :commands (eglot eglot-ensure)
  :init
  (use-package markdown-mode) ;; Better formatting eldoc
  (setq eglot-events-buffer-size 0) ;; don't log events
  :config
  (my/general-global-menu! "LSP" "cl"
    "a" #'eglot-code-actions
    "d" #'eglot-help-at-point
    "f" #'eglot-format-buffer)
  (when (featurep 'tempel)
    (use-package eglot-tempel))
  (after! cape
	  (add-hook
	   'eglot-managed-mode-hook
	   (lambda ()
	     (append! completion-category-overrides '((eglot (styles orderless))))
	     (setq completion-category-defaults nil)
	     (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
             (make-local-variable completion-at-point-functions)
	     (append! completion-at-point-functions #'eglot-completion-at-point)))))
#+end_src
** Eglot Tempel
#+begin_src emacs-lisp
(use-package eglot-tempel
  :unless noninteractive
  :after (eglot tempel))
#+end_src
** Booster
#+begin_src emacs-lisp
(use-package eglot-booster
  :after eglot
  :config (eglot-booster-mode))
#+end_src
** Flycheck Eglot
#+begin_src emacs-lisp
(use-package flycheck-eglot
  :unless noninteractive
  :after (flycheck eglot)
  :config (global-flycheck-eglot-mode 1))
#+end_src
** Sideline
#+begin_src emacs-lisp
(use-package sideline
  :unless noninteractive
  :commands sideline-mode
  :init
  (setq
   sideline-backends-right (list)
   sideline-backends-left-skip-current-line t   ; don't display on current line (left)
   sideline-backends-right-skip-current-line t  ; don't display on current line (right)
   sideline-order-left 'down                    ; or 'up
   sideline-order-right 'up                     ; or 'down
   sideline-format-left "%s   "                 ; format for left aligment
   sideline-format-right "   %s"                ; format for right aligment
   sideline-priority 100                        ; overlays' priority
   sideline-display-backend-name t)             ; display the backend name
  )
(use-package sideline-flycheck
  :unless noninteractive
  :hook (flycheck-mode . sideline-flycheck-setup)
  :hook (flycheck-mode . sideline-mode)
  :commands sideline-flycheck
  :custom (sideline-flycheck-max-lines 5)
  :init (append! sideline-backends-right #'sideline-flycheck))


(use-package sideline-flymake
  :unless noninteractive
  :hook (flymake-mode . sideline-mode)
  :commands sideline-flymake
  :custom (sideline-flymake-max-lines 5)
  :init (append! sideline-backends-right #'sideline-flymake))
  
#+end_src
** eldoc
#+begin_src emacs-lisp
(use-package eldoc
  :ensure nil
  :unless noninteractive
  :diminish
  :config
  (add-popup! "\\*eldoc\\*")
  :custom
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t))
#+end_src
*** eldoc-box
#+begin_src emacs-lisp
(use-package eldoc-box
  :hook (emacs-lisp-mode . eldoc-box-hover-at-point-mode)
  :hook (eglot--managed-mode . eldoc-box-hover-at-point-mode))
#+end_src

** dape
#+begin_src emacs-lisp
(use-package dape
  ;; To use window configuration like gud (gdb-mi)
  :custom
  (dape-buffer-window-arrangment 'gud)
  (dape-buffer-window-arrangment 'right)
  (dape-adapter-dir (concat my/local-dir "dape-adapters/"))
  :config

  (my/leader-def
    "d" '(:keymap dape-global-map :which-key "Debug"))
  ;; By default dape uses gdb keybinding prefix
  (setq dape-key-prefix "\C-x\C-a")

  ;; Kill compile buffer on build success
  ;; (add-hook 'dape-compile-compile-hooks 'kill-buffer)

  ;; Save buffers on startup, useful for interpreted languages
  (add-hook 'dape-on-start-hooks
            (defun dape--save-on-start ()
              (save-some-buffers t t))))
#+end_src
* Languages
** Nix
#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'"
  :config
  (add-hook 'nix-mode-hook #'eglot-ensure))

(use-package nix-drv-mode
  :ensure nix-mode
  :mode "\\.drv\\'")
(use-package nix-shell
  :ensure nix-mode
  :commands (nix-shell-unpack nix-shell-configure nix-shell-build))
(use-package nix-repl
  :ensure nix-mode
  :general (my/general-global-Open
	     :definer 'minor-mode
	     :keymaps 'nix-mode-map
	     "r" 'nix-repl))
#+end_src
** Python
#+begin_src emacs-lisp
(use-package python
  :ensure nil
  :mode ("\\.py\\'" . python-mode)
  :mode ("[./]flake8\\'" . conf-mode)
  :mode ("/Pipfile\\'" . conf-mode)
  :interpreter ("python" . python-mode)
  :init
  (setq python-check-command "pyflakes")
  :config
  (after! apheleia
	  (add-hook 'python-mode-hook (lambda ()
					(setq-local apheleia-formatter '(ruff ruff-isort)))))
  (after! treesit-auto
	  (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode)))

  (add-hook 'python-ts-mode-hook (defun my/python-ts-base-hook () (run-hooks 'python-mode-hook))) 
  (add-hook 'python-ts-mode-hook #'my/treesit-mode) 

  (my/local-leader-def python-mode
      "r" '(run-python :which-key "repl/python")
      "b" '(python-shell-send-buffer :which-key "send buffer to repl"))
  (after! dape
	  ;; for some reason "python" doesn't find the module "debugpy". It seems that dape
	  ;; uses a strange way to lookup in path. This lets it find the installed debugger
	  ;; when I'm using my global python env and can be reset in dir locals or direnv
	  ;; otherwise
	  (plist-put (alist-get 'debugpy dape-configs) 'command (executable-find "python3")))
  (add-hook 'python-mode-hook 'eglot-ensure))

(use-package flymake-ruff
  :ensure t
  :unless noninteractive
  :hook (eglot-managed-mode . flymake-ruff-load))

(use-package ob-python
  :ensure nil
  :after org
  :commands org-babel-execute:python
  :init
  (add-to-list 'org-babel-load-languages '(python . t))
  (setq org-babel-python-command "python3"))
#+end_src
*** Virtual Environments
#+begin_src emacs-lisp
(use-package pyvenv
  :defer t
  :config
  ;; Display virtual envs in the menu bar
  (setq pyvenv-menu t)
  ;; Restart the python process when switching environments
  (add-hook 'pyvenv-post-activate-hooks (lambda ()
					  (pyvenv-restart-python)))
  :after python
  :hook (python-mode . pyvenv-mode)
  :general (my/local-leader-def-python-mode
             "v" '(pyvenv-workon :wk "workon")))

(use-package poetry
  :after python
  :hook (python-mode . poetry-tracking-mode)
  :general (my/local-leader-def-python-mode
	     "p" '(poetry :wk "poetry")))

#+end_src
*** Numpy Docstring
#+begin_src emacs-lisp
(use-package numpydoc
  :init
  (after! yasnippet
          (setq numpydoc-insertion-style 'numpydoc))
  :general (my/local-leader-def-python-mode
                                "d" '(numpydoc-generate :which-key "generate docstring")))
#+end_src
** Rust
#+begin_src emacs-lisp
(use-package rustic
  :mode ("\\.rs$" . rustic-mode)
  :init
  (defun my/startup-rust ()
    (setq-local compile-command "cargo run")
    (when (boundp 'flycheck-checkers)
      (make-local-variable 'flycheck-checkers)
      (push 'rustic-clippy flycheck-checkers)))
  (add-hook 'rustic-mode-hook #'my/startup-rust)
  :config
  (add-hook 'rustic-mode-hook 'eglot-ensure)
  (setq rustic-indent-method-chain t)
  (my/local-leader-def rustic-mode
		       "b" '(nil :which-key "build")
		       "bb" '(rustic-cargo-build :which-key "build")
		       "br" '(rustic-cargo-run :which-key "run")
		       "ba" '(rustic-cargo-audit :which-key "audit")
		       "bt" '(rustic-cargo-test :which-key "test")
		       "bc" '(rustic-cargo-check :which-key "check")
		       "bd" '(rustic-cargo-build-doc :which-key "doc")
		       "bD" '(rustic-cargo-doc :which-key "doc open")
		       "bn" '(rustic-cargo-new :which-key "new")
		       "c" '(nil :which-key "cargo")
		       "co" '(rustic-cargo-outdated :which-key "outdated")
		       "ca" '(rustic-cargo-add :which-key "add")
		       "cd" '(rustic-cargo-rm :which-key "rm")
		       "cA" '(rustic-cargo-add-missing-dependencies :which-key "add missing")
		       "m" '(rustic-cargo-expand :which-key "macro expand")))
(use-package rustic-babel
  :ensure nil
  :after org
  :commands (org-babel-execute:rustic)
  :init
  (add-to-list 'org-src-lang-modes '("rust" . rustic))
  (add-to-list 'org-babel-tangle-lang-exts '("rustic" . "rs"))
  (defalias 'org-babel-execute:rust #'org-babel-execute:rustic))
#+end_src
** Lua
#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua$")
#+end_src
** Haskell
#+begin_src emacs-lisp
(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :config
  (require 'haskell)
  (add-hook 'haskell-mode-hook 'eglot-ensure)
  (my/local-leader-def haskell-mode
      "b" 'haskell-process-cabal-build
      "c" 'haskell-cabal-visit-file
      "h" 'haskell-hide-toggle
      "H" 'haskell-hide-toggle-all))
(use-package ob-haskell
  :ensure nil
  :after org
  :commands org-babel-execute:haskell
  :init
  (add-to-list 'org-babel-load-languages '(haskell . t)))
#+end_src
** Julia
#+begin_src emacs-lisp
(use-package julia-mode
  :mode ("\\.jl\\'" . julia-mode)
  :config
  (add-hook 'julia-mode-hook #'eglot-ensure)
  (my/local-leader-def julia-mode
		       "b" 'julia-repl-send-buffer
		       "r" 'julia-repl-send-region-or-line
		       "R" 'julia-repl
		       "f" 'julia-repl-send-defun
		       "l" 'julia-repl-send-line
		       "s" 'julia-repl
		       "S" 'julia-repl-switch)
  (defun my/julia-def ()
    (my/general-global-Open :keymaps 'local
      "r" 'julia-repl-send-region-or-line
      "f" 'julia-repl-send-defun
      "l" 'julia-repl-send-line))
  (add-hook 'julia-mode-hook #'my/julia-def))
;; First use requires running 'import Pkg; Pkg.add("LanguageServer")' in the Julia REPL
#+end_src
*** REPL
#+begin_src emacs-lisp
(use-package julia-vterm
  :hook (julia-mode . julia-vterm-mode)
  :init (setq julia-vterm-repl-program (concat (executable-find "julia") " --color=yes --startup-file=no -t " (number-to-string my/available-cores)))
  :config
  (add-popup! "\\*julia:main\\*")
  (add-hook 'julia-mode-hook (lambda () (setf (alist-get 'julia-mode my/repl-alist) #'julia-vterm-repl))))
#+end_src
*** Babel
#+begin_src emacs-lisp
(use-package ob-julia-vterm
  :after org
  :commands org-babel-execute:julia-vterm
  :init
  (add-to-list 'org-babel-load-languages '(julia-vterm . t)))
#+end_src
** PDF
#+begin_src emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq pdf-view-use-scaling t)
  (add-hook 'pdf-view-mode-hook #'my/disable-line-numbers)
  (add-to-list 'recentf-exclude "/**/*.pdf")
  (after! undo-tree
	  (add-to-list 'undo-tree-incompatible-major-modes 'pdf-view-mode)))
#+end_src
** Shell
#+begin_src emacs-lisp
(use-package sh-script
  :ensure nil
  :mode ("\\.zsh\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.zshrc\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.sh\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :mode ("\\.bashrc\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :config 
  (setq sh-basic-offset 4
        sh-indentation 4))
#+end_src
*** Org Babel
#+begin_src emacs-lisp
(use-package ob-shell
  :ensure nil
  :after org
  :custom
  (org-babel-shell-results-defaults-to-output t)
  (org-babel-default-header-args:sh '((:session . nil))))
#+end_src
** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile.*\\'" . dockerfile-mode))

(use-package docker
  :general (my/general-global-Open "D" 'docker))
#+end_src
** Latex
Mostly only used for double checking after org export.
#+begin_src emacs-lisp
(use-package auctex
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((latex . t))))

(use-package reftex
  :after auctex
  :ensure nil
  :hook (LaTeX-mode , turn-on-reftex))

(use-package cdlatex
  :hook (org-mode . org-cdlatex-mode)
  :hook (LaTeX-mod . turn-on-cdlatex))
#+end_src
* Mail
** mu4e
#+begin_src emacs-lisp :lexical t
(defun my/get-mail-dir ()
  (expand-file-name "mail/" (getenv "XDG_DATA_HOME")))

(defconst my/mail-dir (my/get-mail-dir))
;; Only load on personal machines with mail
(defconst my/enable/mu4e (and (not noninteractive) IS-PERSONAL (file-directory-p my/mail-dir)))

(use-package mu4e
  :if my/enable/mu4e
  :general(my/general-global-Open "m" '(mu4e :which-key "Email"))
  :init
  (add-to-list 'recentf-exclude my/mail-dir)
  :config
  (my/local-leader-def mu4e-headers-mode
		       "u" '(mu4e-update-mail-and-index :which-key "Update"))
  ;; Context switching for multiple accounts
  (defun my/create-mu4e-context (name address signature server &optional key)
    (unless key (setq key (substring name 0 1)))
    (make-mu4e-context
     :name (format "%s(%s)" key name)
     :enter-func (lambda () (mu4e-message "Entering context %s" name))
     :leave-func (lambda () (mu4e-message "Leaving context %s" name))
     :match-func (lambda (msg)
		   (when msg
		     (string-prefix-p (format "/%s" address)
				      (mu4e-message-field msg :maildir))))
     :vars `((user-mail-address . ,address)
	     (user-full-name . ,user-full-name)
	     (mu4e-compose-signature . ,(if (package-installed-p 'org-msg) signature))
	     (mu4e-sent-folder . ,(format "/%s/Sent" name))
	     (mu4e-drafts-folder . ,(format "/%s/Drafts" name))
	     (mu4e-trash-folder . ,(format "/%s/Trash" name))
	     (mu4e-refile-folder . ,(format "/%s/Archive" name))
	     (smtpmail-smtp-user . ,address)
	     (smtpmail-smtp-server . ,server)
	     (smtpmail-smtp-service . 587)
	     (smtpmail-stream-type . starttls)
	     (smtpmail-debug-info . t)
	     (smtpmail-debug-verb . t))))
  (defun my/wrap-signature (str)
    (concat
     "#+begin_signature\n"
     str
     "\n#+end_signature"))
  (defun my/gmail-signature (name)
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: " name "@gmail.com\n")))
  (defun my/udmercy-signature ()
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: bakheakm@udmercy.edu")))

  (setq
   mail-user-agent 'mu4e-user-agent
   read-mail-command 'mu4e
   mu4e-maildir my/mail-dir
   mu4e-confirm-quit nil
   ;; This is set to 't' to avoid mail syncing issues when using mbsync
   mu4e-change-filenames-when-moving t

   ;; Refresh mail using isync every 10 minutes
   mu4e-update-interval (* 10 60)
   mu4e-get-mail-command "mbsync -a"

   ;; Context policy
   mu4e-context-policy 'pick-first
   mu4e-compose-context-policy 'ask
   mu4e-contexts (list
                  (my/create-mu4e-context "kbakheat-gmail" "kbakheat@gmail.com" (my/gmail-signature "kbakheat") "smtp.gmail.com")
                  (my/create-mu4e-context "kirolsb5-gmail" "kirolsb5@gmail.com" (my/gmail-signature "kirolsb5") "smtp.gmail.com" "a")
                  (my/create-mu4e-context "bakheakm-udmercy" "bakheakm@udmercy.edu" (my/udmercy-signature) "smtp.office365.com"))))


(use-package mu4e-alert
  :if my/enable/mu4e
  :after mu4e
  :config
  (when IS-LINUX
    (progn (mu4e-alert-set-default-style 'libnotify)
	   (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (when IS-MAC
    (progn (mu4e-alert-set-default-style 'notifier)
	   (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src
** msmtp
#+begin_src emacs-lisp
(after! mu4e
        (setq message-send-mail-function #'message-send-mail-with-sendmail
              sendmail-program (executable-find "msmtp")
              send-mail-function #'smtpmail-send-it
              message-sendmail-f-is-evil t
              message-sendmail-extra-arguments '("--read-envelope-from")))
#+end_src
** Compose mail with org mode
#+begin_src emacs-lisp
(use-package org-msg
  :if my/enable/mu4e
  :after (org mu4e)
  :config (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
                org-msg-startup "hidestars indent inlineimages"
                org-msg-greeting-fmt "\nHey%s,\n\n"
                org-msg-greeting-name-limit 3
                org-msg-default-alternatives '((new		. (text html))
                                               (reply-to-html	. (text html))
                                               (reply-to-text	. (text)))
                org-msg-convert-citation t
                org-msg-signature "")
  (org-msg-mode))
#+end_src
* Org Mode
#+begin_src emacs-lisp
(use-package org
  :defer 1
  :ensure nil ;; included in emacs
  :init
  (defun my/relative-org (dir)
    "Makes a sting representing a directory relative to my org base directory"
    (setq my-org-base-dir "~/org")
    (concat (file-name-as-directory my-org-base-dir) dir))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        org-directory (my/relative-org "general/")
        org-insert-heading-respect-content t
        org-export-in-background t
        org-export-with-sub-superscripts '{}
	org-pretty-entities t
	org-pretty-entities-include-sub-superscripts t
        org-list-allow-alphabetical t
        org-catch-invisible-edits 'smart
        org-special-ctrl-a/e t))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(after! (org smartparens)
	(sp-local-pair 'org-mode "\\[" "\\]")
	(sp-local-pair 'org-mode "\\(" "\\)")
	(sp-local-pair 'org-mode "$" "$"))
#+end_src
** Org Modern
#+begin_src emacs-lisp
(use-package org-modern
  :hook (org-mode . org-modern-mode))
#+end_src
** Keybindings
#+begin_src emacs-lisp
(use-package org
  :config
  (my/local-leader-def org-mode
    "#" #'org-update-statistics-cookies
    "'" #'org-edit-special
    "*" #'org-ctrl-c-star
    "+" #'org-ctrl-c-minus
    "," #'org-switchb
    "@" #'org-cite-insert
    "." #'consult-org-heading
    "/" #'counsel-org-goto-all
    "A" #'org-archive-subtree
    "e" #'org-export-dispatch
    "f" #'org-footnote-action
    "h" #'org-toggle-heading
    "i" #'org-toggle-item
    "I" #'org-id-get-create
    "k" #'org-babel-remove-result
    "n" #'org-store-link
    "o" #'org-set-property
    "q" #'org-set-tags-command
    "t" #'org-todo
    "T" #'org-todo-list
    "x" #'org-toggle-checkbox

    "a" '(nil :which-key "attachments")
    "aa" 'org-attach
    "ad" 'org-attach-delete-one
    "aD" 'org-attach-delete-all
    "af" '+org/find-file-in-attachments
    "al" '+org/attach-file-and-insert-link
    "an" 'org-attach-new
    "ao" 'org-attach-open
    "aO" 'org-attach-open-in-emacs
    "ar" 'org-attach-reveal
    "aR" 'org-attach-reveal-in-emacs
    "au" 'org-attach-url
    "as" 'org-attach-set-directory
    "aS" 'org-attach-sync

    "b" '(nil :which-key "tabels")
    "b-" 'org-table-insert-hline
    "ba" 'org-table-align
    "bb" 'org-table-blank-field
    "bc" 'org-table-create-or-convert-from-region
    "be" 'org-table-edit-field
    "bf" 'org-table-edit-formulas
    "bh" 'org-table-field-info
    "bs" 'org-table-sort-lines
    "br" 'org-table-recalculate
    "bR" 'org-table-recalculate-buffer-tables

    "bd" '(nil :which-key "delete")
    "bdc" 'org-table-delete-column
    "bdr" 'org-table-kill-row

    "bi" '(nil :which-key "insert")
    "bic" 'org-table-insert-column
    "bih" 'org-table-insert-hline
    "bir" 'org-table-insert-row
    "biH" 'org-table-hline-and-move

    "l" '(nil :which-key "links")
    "lc" 'org-cliplink
    "ld" '+org/remove-link
    "li" 'org-id-store-link
    "ll" 'org-insert-link
    "lL" 'org-insert-all-links
    "ls" 'org-store-link
    "lS" 'org-insert-last-stored-link
    "lt" 'org-toggle-link-display
    "lg" '(org-mac-link-get-link :if IS-MAC)


    "s" '(nil :which-key "subtree")
    "sa" 'org-toggle-archive-tag
    "sb" 'org-tree-to-indirect-buffer
    "sc" 'org-clone-subtree-with-time-shift
    "sd" 'org-cut-subtree
    "sh" 'org-promote-subtree
    "sj" 'org-move-subtree-down
    "sk" 'org-move-subtree-up
    "sl" 'org-demote-subtree
    "sn" 'org-narrow-to-subtree
    "sr" 'org-refile
    "ss" 'org-sparse-tree
    "sA" 'org-archive-subtree
    "sN" 'widen
    "sS" 'org-sort))
#+end_src
** Agenda
#+begin_src emacs-lisp
(use-package org-gcal
  :after org-agenda
  :unless noninteractive
  :if (and IS-PERSONAL (executable-find "pass") (file-exists-p (concat (getenv "PASSWORD_STORE_DIR") "/google.com/api/client_secret.gpg")))
  :commands (org-gcal-sync)
  :general (my/general-global-Open
	     "a" '(org-gcal-sync :which-key "agenda"))
  :custom
  (org-gcal-client-id (auth-source-pass-get 'secret "google.com/api/client_id"))
  (org-gcal-client-secret (auth-source-pass-get 'secret "google.com/api/client_secret"))
  (org-gcal-fetch-file-alist `(("kbakheat@gmail.com" . ,(my/relative-org "/agenda/google.org"))))
  (org-gcal-notify-p t)
  (org-gcal-recurring-events-mode 'nested)
  (oauth2-auto-plstore (concat my/etc-dir "oauth2-auto.plist"))
  :config
  (cl-loop for (key . value) in org-gcal-file-alist
	   do (append! org-agenda-files value))
  (unless (file-exists-p oauth2-auto-plstore) (f-touch oauth2-auto-plstore))
  (use-package plstore
    :ensure nil
    :config (add-to-list 'plstore-encrypt-to "kbakheat@gmail.com")))
#+end_src
** Presenting
#+begin_src emacs-lisp
(use-package visual-fill-column
  :unless noninteractive
  :hook (org-present . visual-fill-column)
  :hook (org-present . visual-fill-line)
  :custom
  (visual-fill-column-width 110)
  (visual-fill-column-center-text t))
(use-package org-present
  :unless noninteractive
  :commands (org-present)
  :config
  ;; enable list of modes in org present then disable on quit
  (add-hook 'org-present-mode-hook
	    (lambda ()
	      (org-present-big)
	      (org-display-inline-images)
	      (org-present-hide-cursor)
	      (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
	    (lambda ()
	      (org-present-small)
	      (org-remove-inline-images)
	      (org-present-show-cursor)
	      (org-present-read-write))))
#+end_src
** LilyPond
#+begin_src emacs-lisp
(use-package lilypond-mode
  :ensure nil ;; Comes with lilypond, installed with nix
  :preface (defvar my/lilypond (executable-find "lilypond"))
  :mode ("\\.ly\\'" . LilyPond-mode)
  :commands (LilyPond-mode)
  :if my/lilypond
  :init (defalias 'lilypond-mode 'LilyPond-mode))
(use-package ob-lilypond
  :ensure nil
  :after (org lilypond-mode)
  :commands (org-babel-lilypond-tangle org-babel-execute:lilypond)
  :if my/lilypond
  :config
  ;; org-babel-lilypond-commands is a list of strings. We set just the first one to lilypond
  (setf (car org-babel-lilypond-commands) (executable-find "lilypond"))
  (setopt org-babel-lilypond-commands org-babel-lilypond-commands)
  (add-to-list 'org-babel-load-languages '(lilypond . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Org Previews
#+begin_src emacs-lisp
(after! org
	;; Latex fragments
	(add-hook 'org-mode-hook #'org-latex-preview)

	;; Images
	(add-hook 'org-mode-hook #'org-display-inline-images)
	(add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images))
#+end_src
** Notes
#+begin_src emacs-lisp
(my/general-global-menu! "Notes" "n")
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :unless noninteractive
  :commands (deft)
  :custom
  (deft-directory (my/relative-org "deft"))
  (deft-recursive t)
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t)
  (deft-extensions '("org" "md" "txt"))
  (deft-default-extension "org")
  (deft-file-naming-rules '((noslash . "-")
                            (nospace . "-")
                            (case-fn . downcase)))
  (deft-text-mode 'org-mode)
  :config
  (add-popup! "\\*Deft\\*")
  :general (my/general-global-Notes
             "d" '(deft :which-key "deft")))
#+end_src
*** Roam
#+begin_src emacs-lisp
(use-package org-roam
  :unless noninteractive
  :custom
  (org-roam-v2-ack t)
  (org-roam-directory (my/relative-org "roam"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(
     <<roam-templates>>
     ))
  :general (my/general-global-Notes
	     "r"  '(nil :which-key "roam")
	     "rf" '(org-roam-node-find :which-key "find")
	     "ri" '(org-roam-node-insert :which-key "insert")
	     "rg" '(org-roam-graph :which-key "graph")
	     "rt" '(org-roam-dailies-find-today :which-key "today")
	     "ry" '(org-roam-dailies-find-yesterday :which-key "yesterday")
	     "rr" '(org-roam-dailies-find-tomorrow :which-key "tomorrow")
	     "rd" '(org-roam-dailies-find-date :which-key "date")
	     "rc" '(org-roam-dailies-capture-today :which-key "capture today")
	     "rC" '(org-roam-dailies-capture-tomorrow :which-key "capture tomorrow")
	     "rD" '(org-roam-dailies-capture-date :which-key "capture date")
	     "rl" '(org-roam-buffer-toggle-display :which-key "toggle display")
	     "rL" '(org-roam-buffer-display-dedicated :which-key "display dedicated")
	     "rs" '(org-roam-db-sync :which-key "sync")
	     "rS" '(org-roam-server-mode :which-key "server")))
#+end_src
**** Templates
:PROPERTIES:
:header-args: :tangle no :noweb-ref roam-templates
:END:
***** Religious
#+begin_src emacs-lisp
("r" "Templates for religious meditations")
#+end_src
****** Bible
#+begin_src emacs-lisp
("rb" "Bible Study" plain "#+filetags: \"bible study\" \"Book: ${book}\" \"Topic: ${topic}\"\n\n* Topic\n\n* Related\n** Passages\n\n** Meditations\n\n* Personal Meditation\n\n"
 :if-new (file+head "religious/bible-study/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Saint
#+begin_src emacs-lisp
("rs" "Saint" plain "#+filetags: saint \"Saint Type: ${saint type}\" \"Years: ${birth year}-${death year}\" \"Country: ${country}\" \"City: ${city}\"\n\n* Birth\n%?\n\n* Life\n\n\n* Death\n\n\n* Related saints\n\n"
 :if-new (file+head "religious/saints/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Lesson
#+begin_src emacs-lisp
("rl" "Lesson" plain "#+filetags: lesson \"Topic: ${topic}\"\n* %?"
 :if-new (file+head "religious/lessons/%<%Y%m%d%H%M%S>-${slug}.org"
		    "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
***** Generic
****** Default
#+begin_src emacs-lisp
("d" "Default" plain "#+filetags: \"${tags}\"\n\n* %?"
 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
****** Note
#+begin_src emacs-lisp
("n" "Note" plain "#+filetags: note\n\n* %?"
 :if-new (file+head "notes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: note ${field}\n\n")
 :unnarrowed t)
#+end_src

****** Project
#+begin_src emacs-lisp
("p" "Project" plain "#+filetags: project\n\n* %?"
 :if-new (file+head "projects/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: project ${field}\n\n")
 :unnarrowed t)
#+end_src
** Babel
#+begin_src emacs-lisp
(use-package org
  :config
  (add-popup! '("^\\*Org-Babel Error Output\\*$" . hide))
  (setq org-confirm-babel-evaluate nil
	org-src-fontify-natively t
	org-src-tab-acts-natively t
	org-src-window-setup 'current-window
	org-src-preserve-indentation t
	org-src-strip-leading-and-trailing-blank-lines t
	org-src-ask-before-returning-to-edit-buffer nil
        org-babel-load-languages '((emacs-lisp . t))
	org-babel-default-header-args '((:session . "default")
					(:results . "replace")
					(:mkdirp . "yes")
					(:exports . "both")
					(:cache . "yes")
					(:noweb . "yes")
					(:hlines . "no")
					(:tangle . "no")
					(:padnewline . "yes")
					(:eval . "never-export")
					(:comments . "link")))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Auto Tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :custom (org-auto-tangle-default t)
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Export
*** =ox-latex=
#+begin_src emacs-lisp
(use-package ox-latex
  :ensure nil
  :after org
  :config
  (setq org-latex-compiler "xelatex")
  (add-to-list 'org-latex-logfiles-extensions "tex")
  (add-to-list 'org-latex-packages-alist '("" "siunitx"))
  (add-to-list 'org-latex-packages-alist '("" "amsmath"))
  (add-to-list 'org-latex-packages-alist '("" "fancyhdr"))
  (add-to-list 'org-latex-classes
               '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" .    "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("exam"
                 "\\documentclass{exam}"
                 ("\\begin{questions} %% %s"
                  "\\end{questions}"
                  "\\begin{questions} %% %s"
                  "\\end{questions}")
                 ("\\question %s " . "\\question* %s")
		 ("\\begin{parts} %s"
		  "\\end{parts}"
                  "\\begin{parts} %s"
                  "\\end{parts}"))))
#+end_src
*** =ox-html=
#+begin_src emacs-lisp
(use-package ox-html
:ensure nil
:after org)
#+end_src
*** =ox-chameleon=
#+begin_src emacs-lisp
(use-package ox-chameleon
  :ensure nil
  :after org
  :config
  (add-to-list 'org-latex-packages-alist '("" "scrextend" nil))
  (add-to-list 'org-latex-packages-alist '("" "xcolor" nil))
  (after! org-msg
	  (setq org-msg-options (concat org-msg-options " html-content-class: chameleon "))))
#+end_src
*** Async patch
#+begin_src emacs-lisp
(when (not noninteractive) 
  (after! ox
	  (setq org-export-async-init-file (make-temp-file "org-export-async-init-file" nil ".el"))
	  (defun my/get-loaded-nix-file (name)
	    (car (load-history-filename-element
		  (concat
		   "^/nix/store/.*emacs-packages-deps/share/emacs/site-lisp/"
		   name
		   "\\.elc?\\(\\.gz\\)?$"))))

	  (with-temp-file org-export-async-init-file
	    (mapc (lambda (s)
		    (insert (format "(load \"%s\")\n" s)))
		  (-select #'identity
			   (list
			    (my/get-loaded-nix-file "site-start")
			    (my/get-loaded-nix-file "subdirs")
			    (my/get-loaded-nix-file "default")
			    (my/get-loaded-nix-file "init"))))
	    (insert (format "(setq engrave-faces-preset-styles '%S)\n" engrave-faces-preset-styles))
	    (insert (format "(setq engrave-faces-themes '%S)\n" engrave-faces-themes))
	    (insert (format "(setq load-path '%S)\n" load-path))
	    (insert (format "(setq exec-path '%S)\n" exec-path)))))
#+end_src
*** Syntax Highlighting
#+name: engrave-faces-init
#+begin_src emacs-lisp :tangle no
;;; Definers
(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (ensure-list ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
	 (dolist (target (cdr targets))
	   (advice-add target (car targets) #',symbol))))))
(defvar-local org-export-has-code-p nil)

(defadvice! org-export-expect-no-code (&rest _)
	    :before #'org-export-as
	    (setq org-export-has-code-p nil))

(defadvice! org-export-register-code (&rest _)
	    :after #'org-latex-src-block
	    :after #'org-latex-inline-src-block-engraved
	    (setq org-export-has-code-p t))

(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
	    "Like `org-latex-example-block', but supporting an engraved backend"
	    :around #'org-latex-example-block
	    (let ((output-block (funcall orig-fn example-block contents info)))
	      (if (eq 'engraved (plist-get info :latex-listings))
		  (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
		output-block)))
#+end_src
#+begin_src emacs-lisp
;; both installed by engrave-faces
(use-package engrave-faces-latex
  :ensure engrave-faces
  :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
(use-package engrave-faces-html
  :ensure engrave-faces
  :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
#+end_src
** Evil Org
#+begin_src emacs-lisp
(use-package evil-org
  :unless noninteractive
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  (add-hook 'evil-org-mode-hook
	    (lambda ()
	      (evil-org-set-key-theme)))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src
** Org Src
#+begin_src emacs-lisp
(use-package org-src-context
  :after org
  :general
  (my/local-leader-def-org-mode
    "S" '(org-src-context-mode :which-key "src LSP")))
#+end_src
** Poly Org
#+begin_src emacs-lisp
(use-package poly-org
  :unless noninteractive
  :commands poly-org-mode
  :after org
  :init
  (my/local-leader-def-org-mode
    "p" '(poly-org-mode :which-key "poly-org-mode")))
#+end_src
* Local Variables
# Local Variables:
# org-use-property-inheritance: t
# End:
