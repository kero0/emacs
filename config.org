* Setup
#+property: header-args :tangle init.el :results output silent :noweb yes :lexical t :eval never-export
#+startup: fold
#+auto_tangle: t
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src
** Requires
#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src
** Basic variables
*** System type
#+begin_src emacs-lisp
(defconst IS-MAC      (eq system-type 'darwin))
(defconst IS-LINUX    (memq system-type '(gnu gnu/linux gnu/kfreebsd berkeley-unix)))
(defconst IS-WINDOWS  (memq system-type '(cygwin windows-nt ms-dos)))
(defconst IS-BSD      (memq system-type '(darwin berkeley-unix gnu/kfreebsd)))
;; personal or work
(defconst IS-PERSONAL t)
(defconst IS-WORK     (not IS-PERSONAL))
(defconst my/available-cores
  (string-to-number
   (shell-command-to-string (if (eq system-type 'darwin)
                                "sysctl -n hw.ncpu"
                              "nproc --all"))))
#+end_src
*** Directories
#+begin_src emacs-lisp
(defvar my/local-dir (expand-file-name ".local/" user-emacs-directory)
  "Default local directory.")
(if-let ((local-dir (getenv "XDG_DATA_HOME")))
    (setq my/local-dir (expand-file-name "emacs/" local-dir)))
(make-directory my/local-dir t)
(defvar my/cache-dir (expand-file-name "cache/" my/local-dir)
  "Default cache directory.")
(if-let ((cache-dir (getenv "XDG_CACHE_HOME")))
    (setq my/cache-dir (expand-file-name "emacs/" cache-dir)))
(make-directory my/cache-dir t)
(defvar my/etc-dir (expand-file-name "etc/" my/local-dir)
  "Default etc directory.")
(defvar my/emacs-dir user-emacs-directory
  "Default emacs directory.")
#+end_src
*** Personal info
#+begin_src emacs-lisp
(setq user-full-name "Kirols Bakheat"
      user-mail-address "kbakheat@gmail.com")
#+end_src
** Disable package.el
#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

** Macros
*** ~after!~
#+begin_src emacs-lisp
(cl-defmacro after! (features &rest body)
  "A smart wrapper around `with-eval-after-load'"
  (if (listp features)
      (pcase (length features)
	(0 `(progn ,@body))
	(1 `(with-eval-after-load (quote ,(car features))
	      (progn
		,@body)))
        (_ (if (eq (car features) 'or)
               `(progn
                  ,@(cl-map 'list
                           (lambda (feature)
                             `(after! ,feature ,@body))
                           (cdr features)))
             `(with-eval-after-load (quote ,(car features))
                (after! ,(cdr features) ,@body)))))
    `(with-eval-after-load (quote ,features)
       (progn ,@body))))
#+end_src
*** ~append!~
#+begin_src emacs-lisp
(cl-defmacro append! (var &rest values)
  "Append VALUES to the end of VAR, if they don't already exist in VAR."
  (declare (indent defun))
  `(dolist (value (list ,@values))
     (unless (member value ,var)
       (setf ,var (append ,var (list value))))))
#+end_src
** Startup
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 100 1000 1000))

(defun my/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done)
  (setq gc-cons-threshold (* 2 1000 1000)))

(add-hook 'emacs-startup-hook #'my/display-startup-time)
#+end_src
** gcmh
#+begin_src emacs-lisp
(use-package gcmh
  :unless noninteractive
  :demand
  :hook
  (focus-out-hook . gcmh-idle-garbage-collect)

  :custom
  (gcmh-idle-delay 10)
  (gcmh-high-cons-threshold 104857600)

  :config
  (gcmh-mode +1))
#+end_src
** Hooks
#+begin_src emacs-lisp
(defun my/disable-line-numbers ()
  (display-line-numbers-mode -1)
  (setq-local display-line-numbers nil))
#+end_src
** no-littering
#+begin_src emacs-lisp
(use-package no-littering
  :config
  (setq no-littering-etc-directory (expand-file-name "etc/" my/local-dir)
        no-littering-var-directory (expand-file-name "var/" my/local-dir)
        custom-file (no-littering-expand-etc-file-name "custom.el"))
  (load custom-file 'noerror 'nomessage))
#+end_src
** History
*** recentf
#+begin_src emacs-lisp
(use-package recentf
  :unless noninteractive
  :ensure nil
  :config
  (dolist (dir `("/nix/store/.*"
		 "/tmp/.*"
		 "/var/tmp/.*"
		 "/var/folders/.*"
		 "/private/tmp/.*"
		 "/private/var/.*"
		 ,my/etc-dir
		 ,my/local-dir
		 ,my/cache-dir))
    (add-to-list 'recentf-exclude dir))
  (when-let ((dir (getenv "XDG_DATA_HOME")))
    (add-to-list 'recentf-exclude (concat dir "/.*")))
  (setq recentf-max-menu-items 25
	recentf-save-file (expand-file-name "recentf" my/local-dir))
  (recentf-mode 1))
#+end_src
*** savehist
#+begin_src emacs-lisp
(use-package savehist
  :unless noninteractive
  :ensure nil
  :config
  (setq savehist-file (expand-file-name "savehist" my/local-dir)
	savehist-save-minibuffer-history t
	savehist-autosave-interval 60
	savehist-additional-variables '(kill-ring
					search-ring
					regexp-search-ring))
  (savehist-mode 1))
#+end_src
*** saveplace
#+begin_src emacs-lisp
(use-package saveplace
  :unless noninteractive
  :ensure nil
  :config
  (setq save-place-file (expand-file-name "saveplace" my/local-dir))
  (save-place-mode 1))
#+end_src
** Custom file
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" my/etc-dir))
#+end_src
** Backup files
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" my/local-dir)))
      auto-save-file-name-transforms `((".*" ,(expand-file-name "auto-save/" my/local-dir) t)))
#+end_src
** Lockfiles
#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src
** Autosave
#+begin_src emacs-lisp
(setq auto-save-default nil)
#+end_src
** Auto-revert
#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode
  :config
  (setq auto-revert-verbose nil
        auto-revert-interval 2
        auto-revert-check-vc-info t
        auto-revert-remote-files t)
  (global-auto-revert-mode +1))
#+end_src
** Yes-or-No
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Authsources
#+begin_src emacs-lisp
(setq auth-sources (list (expand-file-name "authinfo.gpg" my/local-dir)))
#+end_src
** Native Comp
#+begin_src emacs-lisp
(setq comp-eln-cache-path (expand-file-name "eln-cache/" my/cache-dir)
      native-comp-async-report-warnings-errors nil
      native-comp-deferred-compilation nil
      native-comp-verbose nil)
#+end_src
** Window management
I want windows that start with '*' to be opened in the lower 1/3 of the frame. These windows should close when their buffer dies and should not be reused. If they are not in ~my/special-window-no-cursor-manage-alist~ then they should automatically grab the cursor.
#+begin_src emacs-lisp
(defvar my/special-window-no-cursor-manage-alist '("*Help*" "*Warnings*" "*Backtrace*" "*Messages*"))
#+end_src
** Proxy Settings
#+begin_src emacs-lisp
(defvar my/proxy nil
  "Proxy to use")
(when IS-WORK
  (setq my/proxy  "http://internet.ford.com:83")
  (setq url-using-proxy my/proxy
        url-proxy-services `(("http" . ,my/proxy)
                             ("https" . ,my/proxy)
                             ("ssh" . ,my/proxy)))
  (after! lsp-mode
          (setq lsp-http-proxy my/proxy)))
#+end_src
* Keybindings
** Basics
#+begin_src emacs-lisp
(cond
 (IS-MAC
  (define-key key-translation-map [S-iso-lefttab] [backtab])
  (setq mac-command-modifier      'meta
        ns-command-modifier       'meta
        mac-option-modifier       'meta
        ns-option-modifier        'meta
        mac-right-option-modifier 'super
        ns-right-option-modifier  'super))
 (IS-WINDOWS
  (setq w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super)))
;; Make ESC quit prompts
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq use-package-always-demand (daemonp))
#+end_src
** general.el
*** Helpers
Macro to define nested keymaps
#+begin_src emacs-lisp
;; copied from https://github.com/progfolio/.emacs.d/blob/master/init.org
(cl-defmacro my/general-global-menu! (name prefix-key &rest body &key def-settings &allow-other-keys)
  "Create a definer named +general-global-NAME wrapping global-definer.
  Create prefix map: +general-global-NAME-map. Prefix bindings in BODY with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n (concat "my/general-global-" name))
         (prefix-map (intern (concat n "-map")))
         (body (if def-settings (remove ':def-settings body) body))
         (body (if def-settings (remove def-settings body) body)))
    `(eval-after-load 'general
       (progn
	 (defvar-keymap ,prefix-map)
         (my/leader-def
	   :wk-full-keys nil
           ,prefix-key '(:keymap ,prefix-map :wk ,name))
         (general-create-definer ,(intern n)
           :keymaps ',prefix-map)
         (,(intern n) ,@body)))))
#+end_src
Do something in other window
#+begin_src emacs-lisp
(defun my/do-in-other-window (fn &rest args)
    (let ((buf (current-buffer)))
        (other-window 1)
        (apply fn args)
        (switch-to-buffer buf)))
#+end_src
**** Local Bindings
#+begin_src emacs-lisp :noweb-ref keybindings :tangle no
(defmacro my/local-leader-def (mode &rest args)
  "Define a local leader key sequence in mode"
  `(progn
     (defvar ,(intern (concat "my/local-leader-def-" (symbol-name mode))) (make-sparse-keymap)
       ,(concat "Local leader keymap for " (symbol-name mode)))
     (general-create-definer ,(intern (concat "my/local-leader-def-" (symbol-name mode)))
       :prefix ,(concat my/leader-def-prefix " " my/local-leader-def-prefix)
       :global-prefix (concat my/leader-def-prefix-alt " " my/local-leader-def-prefix)
       :states ',my/prefix-states
       :keymaps 'local
       "" '(:ignore t :wk "<local-leader>"))
     (add-hook ',(intern (concat (symbol-name mode) "-hook"))
               (lambda ()
                 (,(intern (concat "my/local-leader-def-" (symbol-name mode)))
                  ,@args)))))
#+end_src
*** general.el setup
#+begin_src emacs-lisp :noweb yes
(defvar my/leader-def-prefix "SPC"
  "Prefix for general.el leader keybindings.")
(defvar my/leader-def-prefix-alt "M-SPC"
  "Alternative prefix for general.el leader keybindings.")
(defvar my/local-leader-def-prefix "m"
  "Prefix for general.el local leader keybindings.
   Relative to `my/leader-def-prefix'.")
(defvar my/prefix-states '(normal visual motion)
;; (defvar my/prefix-states '(normal visual motion insert)
  "States in which to bind general.el leader keybindings.")

(use-package general
  :config
  (general-evil-setup)
  (general-override-mode 1)
  (general-auto-unbind-keys)
  (general-define-key
   :keymaps 'override
   :states my/prefix-states
   :prefix-map 'my/prefix-map
   :prefix my/leader-def-prefix
   :global-prefix my/leader-def-prefix-alt)


  (general-create-definer my/leader-def
    :wk-full-keys nil
    :keymaps 'my/prefix-map)
  (my/leader-def
    "SPC" '(project-find-file :wk "Find file")
    "h"   '(:keymap help-map :wk "Help")
    "H"   '(helpful-at-point :wk "Help at point")
    ";"   '(execute-extended-command :wk "M-x")
    ":"   '(eval-expression :wk "Eval")
    "."   '(repeat :wk "Repeat")
    "r"   '(async-shell-command :wk "Run command")
    "R"   '(shell-command :wk "Run command synchronously"))
  <<keybindings>>
  )
#+end_src
**** Assorted Keybindings
:PROPERTIES:
:header-args: :tangle no :noweb-ref keybindings
:END:
***** Quit
#+begin_src emacs-lisp
(my/general-global-menu! "Quit" "q"
  "q" '(save-buffers-kill-terminal :wk "Quit Emacs")
  "Q" '(kill-emacs :wk "Quit Emacs immediately")
  "r" '(restart-emacs :wk "Restart Emacs")
  "R" '(restart-emacs--daemon :wk "Restart Emacs daemon")
  "d" '(restart-emacs-debug-init :wk "Restart Emacs with debug init"))


(message "Loading general-global-menu... Done")
#+end_src
***** Buffer
#+begin_src emacs-lisp
(defun my/kill-buffer (&optional buf)
  (interactive)
  (let ((buf (or buf (current-buffer)))
        (kill-buffer-query-functions '()))
    (kill-buffer buf)))

(defun my/kill-other-window ()
  (interactive)
  (my/do-in-other-window (lambda () (progn (my/kill-buffer) (delete-window)))))
        

(my/general-global-menu! "Buffer" "b"
  "B" '(switch-to-buffer-other-window :wk "Switch buffer other window")
  "d" '(kill-current-buffer :wk "Kill current buffer")
  "k" '(my/kill-buffer :wk "Kill buffer")
  "K" '(my/kill-other-window :wk "Kill buffer other window")
  "r" '(revert-buffer :wk "Revert buffer")
  "[" '(previous-buffer :wk "Previous buffer")
  "]" '(next-buffer :wk "Next buffer")
  "n" '(next-buffer :wk "Next buffer")
  "p" '(previous-buffer :wk "Previous buffer")
  "s" '(save-buffer :wk "Save buffer")
  "S" '(save-some-buffers :wk "Save some buffers")
  "u" '(bury-buffer :wk "Bury buffer")
  "U" '(unbury-buffer :wk "Unbury buffer")
  "x" '(scratch-buffer :wk "Open scratch buffer"))
(my/leader-def
  "x" '(scratch-buffer :wk "Open scratch buffer"))
#+end_src
***** Code
#+begin_src emacs-lisp
(my/general-global-menu! "Code" "c"
  "c" '(recompile :wk "Recompile")
  "C" '(compile :wk "Compile"))
#+end_src
***** File
#+begin_src emacs-lisp
(defun my/find-file-other-window ()
  (interactive)
  (my/do-in-other-window #'find-file))
(defun my/find-file-sudo ()
  (interactive)
  (let ((file-name (read-file-name "Find file (as root): ")))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(defun my/this-file-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (find-file (concat "/sudo:root@localhost:" file-name))))
(my/general-global-menu! "File" "f"

  "f" '(find-file :wk "Find file")
  "F" '(find-file-other-window :wk "Find file other window")
  "s" '(save-buffer :wk "Save buffer")
  "S" '(write-file :wk "Save file as")
  "r" '(recentf-open-files :wk "Recent files")
  "R" '(rename-file :wk "Rename file")
  "d" '(delete-file :wk "Delete file")
  "u" '(my/find-file-sudo :wk "Find file as root")
  "U" '(my/this-file-sudo :wk "Open this file as root"))
#+end_src
***** Git
#+begin_src emacs-lisp
(my/general-global-menu! "Git" "g")
#+end_src
***** Open
#+begin_src emacs-lisp
(defvar my/open-proc (cond (IS-MAC "open")
                           (IS-LINUX "xdg-open"))
  "The defualt process to open files with.")
(defun my/default-open (file)
  (interactive)
  (start-process my/open-proc nil my/open-proc file))

(my/general-global-menu! "Open" "o"
                         "o" '((lambda () (interactive) (my/default-open (buffer-file-name))) :wk "Open file")
                         "s" '(shell :wk "Shell"))
#+end_src
***** REPL
#+begin_src emacs-lisp
(defvar my/repl-alist '((emacs-lisp-mode . ielm)
                        (fallback . my/repl-fallback))
  "Alist of modes to repls.")
(defvar my/repl-fallback #'shell "The fallback repl to use.")
(defun my/repl--open-or-create ()
  (let* ((mode (buffer-local-value 'major-mode (current-buffer)))
	 (repl (alist-get mode my/repl-alist my/repl-fallback))
	 (repl-buffer-name (concat "*"
				   (symbol-name (if (eq repl my/repl-fallback) mode repl))
				   ":repl*")))
    (if (get-buffer repl-buffer-name)
	(popper--find-buried-popups (get-buffer repl-buffer-name))
      (progn
	(add-popup! repl-buffer-name)
	(funcall repl)
	(rename-buffer repl-buffer-name)))))
(defun my/repl--choose (arg)
  (interactive (list (completing-read "Choose repl: " (mapcar #'symbol-name (mapcar #'car my/repl-alist)) nil t)))
  (let* ((repl (if (string= arg "fallback")
                   my/repl-fallback
                 (alist-get (intern arg) my/repl-alist my/repl-fallback)))
	 (repl-buffer-name (concat "*"
				   (symbol-name repl)
				   ":repl*")))
    (if (get-buffer repl-buffer-name)
        (popper-raise-popup (get-buffer repl-buffer-name))
      (progn
	(add-popup! repl-buffer-name)
	(funcall repl)
	(rename-buffer repl-buffer-name)))))

(defun my/repl (arg)
  (interactive "P")
  (if arg
      (call-interactively #'my/repl--choose)
    (my/repl--open-or-create)))
(my/general-global-Open "r" '(my/repl :wk "REPL"))
#+end_src
***** Toggle
#+begin_src emacs-lisp
(defun my/toggle-comment (beg end)
  "Comment or uncomment current region or line."
  (interactive (if (use-region-p)
		   (list (region-beginning) (region-end))
		 (list (line-beginning-position) (line-end-position))))
  (comment-or-uncomment-region beg end))
(my/general-global-menu! "Toggle" "t"
  "d" '(toggle-debug-on-error :wk "debug")
  "/" '(comment-or-uncomment-region :wk "comment"))
#+end_src
***** Search
#+begin_src emacs-lisp
(my/general-global-menu! "Search" "s")
#+end_src

** evil
#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t
	evil-want-keybinding nil
	evil-want-C-u-scroll t
	evil-want-C-i-jump t
	evil-undo-system 'undo-tree
	select-enable-clipboard nil)
  :config
  (evil-mode (not noninteractive))
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)
  (my/general-global-menu! "Window" "w"
    "" '(:keymap evil-window-map :wk "Window"))
  (my/leader-def
    "u"  '(universal-argument :wk "Universal argument")))

(use-package evil-collection
  :after evil
  :custom
  (evil-collection-setup-minibuffer t)
  :config
  (unless noninteractive
    (evil-collection-init))
  (general-def minibuffer-local-map
    :states 'normal
    [escape] 'abort-recursive-edit))
#+end_src
*** evil-surround
#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src
*** evil-commentary
#+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode))
#+end_src
*** evil-nerd-commenter
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :config
  (evilnc-default-hotkeys))
#+end_src
*** evil-goggles
#+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :init
  (setq evil-goggles-duration 0.05)
  :config
  (push '(evil-operator-eval
          :face evil-goggles-yank-face
          :switch evil-goggles-enable-yank
          :advice evil-goggles--generic-async-advice)
        evil-goggles--commands)
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces)
  )
#+end_src
*** evil-snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :config
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))
#+end_src
*** evil-mc
#+begin_src emacs-lisp
(use-package evil-mc
  :after evil
  :general (general-nmap
            "M-d" 'evil-mc-make-and-goto-next-match
            "M-S-d" 'evil-mc-make-and-goto-prev-match)
  :general (general-vmap
            "A" 'evil-mc-make-cursor-in-visual-selection-end
            "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  :general (my/general-global-menu! "Multi-Cursor" "c m"

                                    "a" '(evil-mc-make-all-cursors :wk "Make all cursors")
                                    "n" '(evil-mc-make-and-goto-next-match :wk "Make and go to next match")
                                    "N" '(evil-mc-make-and-goto-prev-match :wk "Make and go to previous match")
                                    "q" '(evil-mc-undo-all-cursors :wk "Undo all cursors"))
  :config
  (global-evil-mc-mode 1))
#+end_src
*** Extra Text Objects
#+begin_src emacs-lisp
(use-package targets
  :config
  (setq targets-composite-text-objects
	'((all-quotes
	   (("\"" "\"" quote)
	    ("'" "'" quote)
	    ("`" "`" quote)
	    ("‘" "’" quote)
	    ("“" "”" quote))
	   :bind t
	   :keys "q")
	  (all-brackets
	   (("[" "]" pair)
	    ("{" "}" pair)
	    ("<" ">" pair)
	    ("</" ">" )
	    ("(" ")" pair))
	   :bind t
	   :keys "b")))
  (targets-setup t))
#+end_src
** which-key
#+begin_src emacs-lisp
(use-package which-key
  :unless noninteractive
  :hook (after-init . which-key-mode)
  :diminish
  :config
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.01
        which-key-max-description-length 32
        which-key-sort-order 'which-key-key-order-alpha
        which-key-allow-evil-operators t
        which-key-prefix-prefix "+"))
#+end_src
* UI
#+begin_src emacs-lisp
(defvar my/frame-transparency '(90 . 90))
(setq inhibit-startup-message t)

(scroll-bar-mode -1)         ; Disable visible scrollbar
(tool-bar-mode -1)           ; Disable the toolbar
(tooltip-mode -1)            ; Disable tooltips
(set-fringe-mode '(14 . 10)) ; Give some breathing room

(menu-bar-mode -1)           ; Disable the menu bar

(setq ring-bell-function 'ignore)

(column-number-mode)
(global-display-line-numbers-mode t)
(setq display-line-numbers-type 'relative)
(setq use-dialog-box nil)

;; Set frame transparency
;; (set-frame-parameter (selected-frame) 'alpha my/frame-transparency)
;; (add-to-list 'default-frame-alist `(alpha . ,my/frame-transparency))
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
** Fancy Compile
#+begin_src emacs-lisp
(use-package ansi-color
  :unless noninteractive
  :ensure nil
  :hook  (compilation-filter . ansi-color-compilation-filter))
#+end_src
** Fonts
#+begin_src emacs-lisp
(defconst my/font/name "JetBrainsMono Nerd Font Mono") ;; ligatures assumes this font
(defvar my/font/size 180)
(defvar my/font/unicode-name "Julia Mono")



(set-face-attribute 'default nil :font my/font/name :height my/font/size)
(set-face-attribute 'fixed-pitch nil :font my/font/name :height my/font/size)
(set-face-attribute 'variable-pitch nil :font my/font/name :height my/font/size :weight 'regular)
#+end_src
*** Ligatures
#+begin_src emacs-lisp
(defun my/font/enable-ligatures ()
  "Enable ligatures for Jetbrains"
  (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
		 (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
		 (36 . ".\\(?:>\\)")
		 (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
		 (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
		 (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
		 (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
		 (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
		 (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
		 (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
		 (48 . ".\\(?:x[a-zA-Z]\\)")
		 (58 . ".\\(?:::\\|[:=]\\)")
		 (59 . ".\\(?:;;\\|;\\)")
		 (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
		 (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
		 (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
		 (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
		 (91 . ".\\(?:]\\)")
		 (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
		 (94 . ".\\(?:=\\)")
		 (119 . ".\\(?:ww\\)")
		 (123 . ".\\(?:-\\)")
		 (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
		 (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
		 )))
    (dolist (char-regexp alist)
      (set-char-table-range composition-function-table (car char-regexp)
                            `([,(cdr char-regexp) 0 font-shape-gstring])))))
(add-hook 'after-init-hook #'my/font/enable-ligatures)
#+end_src
*** Prettify symbols
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init
  (cl-defmacro my/prettify-symbols-extend (&rest pairs &allow-other-keys)
    "Extend the alist of `prettify-symbols-alist' with PAIRS."
    (declare (indent 0))
    `(setq prettify-symbols-alist
	   (-concat prettify-symbols-alist '(,@pairs))))
  (cl-defmacro my/prettify-symbols-extend-mode (mode &rest pairs &allow-other-keys)
    "Extend the alist of `prettify-symbols-alist' with PAIRS for MODE."
    (declare (indent 1))
    `(add-hook (intern (concat (symbol-name ,mode) "-hook"))
	       (lambda ()
		 (make-local-variable 'prettify-symbols-alist)
		 ,(macroexpand 
		   `(my/prettify-symbols-extend ,@pairs)))))
  :config
  (global-prettify-symbols-mode nil))
#+end_src
*** Emoji
#+begin_src emacs-lisp
(use-package emojify
  ;; :unless noninteractive
  :unless t
  :hook (after-init . global-emojify-mode)
  :config (setq emojify-styles '(unicode)))
#+end_src
*** Unicode
#+begin_src emacs-lisp
(use-package unicode-fonts
  :config
  (unicode-fonts-setup '(my/font/unicode-name))
  :init
  (my/leader-def
    "U" '(unicode-fonts-insert 'interactive "Insert Unicode char (by name)")))
#+end_src
** Dashboard
#+begin_src emacs-lisp
(use-package nerd-icons)
(use-package dashboard
  :unless noninteractive
  :hook (after-init . dashboard-setup-startup-hook)
  :init
  (setq dashboard-banner-logo-title "Welcome to Emacs Dashboard"
        dashboard-startup-banner 'logo
        dashboard-center-content t
        dashboard-show-shortcuts t
        dashboard-display-icons-p t
        dashboard-icon-type 'nerd-icons
        dashboard-projects-backend (if (package-installed-p 'projectile) 'projectile 'project)
        dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)
                          (registers . 5))
        dashboard-set-navigator t
        dashboard-set-init-info t
        inhibit-startup-screen t)

  (add-hook 'dashboard-mode-hook #'my/disable-line-numbers))
#+end_src
** Theme
#+begin_src emacs-lisp
(setq
 modus-themes-italic-constructs t
 modus-themes-bold-constructs t
 modus-themes-subtle-line-numbers nil
 modus-themes-tabs-accented t
 modus-themes-variable-pitch-ui t
 modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

 ;; Options for `modus-themes-prompts' are either nil (the
 ;; default), or a list of properties that may include any of those
 ;; symbols: `background', `bold', `gray', `intense', `italic'
 modus-themes-prompts '(background bold intense italic)

 ;; The `modus-themes-completions' is an alist that reads three
 ;; keys: `matches', `selection', `popup'.  Each accepts a nil
 ;; value (or empty list) or a list of properties that can include
 ;; any of the following (for WEIGHT read further below):
 ;;
 ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
 ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
 ;; `popup' - same as `selected'
 ;; `t' - applies to any key not explicitly referenced (check docs)
 ;;
 ;; WEIGHT is a symbol such as `semibold', `light', or anything
 ;; covered in `modus-themes-weights'.  Bold is used in the absence
 ;; of an explicit WEIGHT.
 modus-themes-completions
 '((matches . (semibold))
   (selection . (extrabold accented))
   (popup . (extrabold accented)))

 modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

 ;; The `modus-themes-headings' is an alist with lots of possible
 ;; combinations, include per-heading-level tweaks: read the
 ;; manual or its doc string
 modus-themes-headings
 '((0 . (variable-pitch light (height 2.2)))
   (1 . (rainbow variable-pitch light (height 1.6)))
   (2 . (rainbow variable-pitch light (height 1.4)))
   (3 . (rainbow variable-pitch regular (height 1.3)))
   (4 . (rainbow regular (height 1.2)))
   (5 . (rainbow (height 1.1)))
   (t . (variable-pitch extrabold))))

(setq modus-themes-italic-constructs t
      modus-themes-bold-constructs t
      modus-themes-mixed-fonts t
      modus-themes-variable-pitch-ui t
      modus-themes-custom-auto-reload nil
      modus-themes-disable-other-themes t

      ;; Options for `modus-themes-prompts' are either nil (the
      ;; default), or a list of properties that may include any of those
      ;; symbols: `italic', `WEIGHT'
      modus-themes-prompts '(italic bold)

      ;; The `modus-themes-completions' is an alist that reads two
      ;; keys: `matches', `selection'.  Each accepts a nil value (or
      ;; empty list) or a list of properties that can include any of
      ;; the following (for WEIGHT read further below):
      ;;
      ;; `matches'   :: `underline', `italic', `WEIGHT'
      ;; `selection' :: `underline', `italic', `WEIGHT'
      modus-themes-completions
      '((matches . (semibold))
        (selection . (extrabold accented)))

      modus-themes-org-blocks 'tinted-background ; {nil,'gray-background,'tinted-background}

      ;; The `modus-themes-headings' is an alist: read the manual's
      ;; node about it or its doc string.  Basically, it supports
      ;; per-level configurations for the optional use of
      ;; `variable-pitch' typography, a height value as a multiple of
      ;; the base font size (e.g. 1.5), and a `WEIGHT'.
      modus-themes-headings
      '((1 . (variable-pitch 1.5))
        (2 . (1.3))
        (agenda-date . (1.3))
        (agenda-structure . (variable-pitch light 1.8))
        (t . (1.1))))

(load-theme 'modus-operandi t)
(setq modus-themes-to-toggle '(modus-operandi modus-vivendi))
(my/general-global-Toggle
  "t" '(modus-themes-toggle :wk "theme"))
#+end_src

** Indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :hook (prog-mode . highlight-indent-guides-mode)
  :hook (conf-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-delay 0))
#+end_src
** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :unless noninteractive
  :init
  (unless (equal "Battery status not available"
		 (battery))
    (display-battery-mode 1))
  :config (doom-modeline-mode 1)
  :custom
  (doom-modeline-height 15)
  (doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode)))
  #+end_src
** Word Wrapping
#+begin_src emacs-lisp
(global-visual-line-mode t)
(my/general-global-Toggle
 "w" '(visual-line-mode :wk "Word wrap"))
#+end_src
** Rainbow delimeters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Popper
#+begin_src emacs-lisp
(use-package popper
  :unless noninteractive
  :demand t
  :bind (:map popper-mode-map
              ("C-`"   . popper-toggle)
              ("M-`"   . popper-cycle)
              ("C-M-`" . popper-toggle-type))
  :general (my/general-global-menu! "Popper" "`"
             "`" '(my/popper-toggle-latest :wk "Toggle latest")
             "c" '(popper-cycle :wk "Cycle")
             "T" '(popper-toggle-type :wk "Toggle type"))
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "\\*helpful .*\\*"
          "\\*.*:repl\\*"
          "\\*scratch\\*"
          help-mode
          compilation-mode))

  (setq popper-group-function #'popper-group-by-directory
	popper-display-function #'display-buffer-at-bottom)
  (cl-defmacro add-popup! (&rest rules)
    "Add popup rules."
    `(after! popper
	     (let ((x popper-reference-buffers))
	       (progn
		 (append! x ,@rules)
		 (setopt popper-reference-buffers x)))))
  :config
  (popper-mode +1)
  ;;(popper-echo-mode +1)
  ;; Hook to auto close a window when a popup buffer in that window is killed
  (defun my/kill-buffer-advice (orig-fn &rest args)
    "Advice function to close the window after killing the buffer."
    (let ((buf (current-buffer)))
      (when (popper-popup-p buf)
        (delete-window (get-buffer-window buf)))
      (apply orig-fn args)))
  (add-hook 'after-hook-hook (lambda () (advice-add 'kill-buffer :around #'my/kill-buffer-advice))))
(when noninteractive
  (defmacro add-popup! (&rest _)))
#+end_src
* Bookmarks
** Evil
#+begin_src emacs-lisp
(use-package evil-fringe-mark
  :unless noninteractive
  :requires evil
  :after evil
  :hook (after-init . global-evil-fringe-mark-mode)
  :general (my/general-global-Toggle "f" '(evil-fringe-mark-mode :wk "Evil Marks"))
  :init
  ;; Persist global marks
  (after! savehist
	  (add-to-list 'savehist-additional-variables 'evil-markers-alist)
	  (add-hook 'savehist-save-hook (lambda ()
					  (kill-local-variable 'evil-markers-alist)
					  (dolist (entry evil-markers-alist)
					    (when (markerp (cdr entry))
					      (setcdr entry (cons (file-truename (buffer-file-name (marker-buffer (cdr entry))))
								  (marker-position (cdr entry))))))))
	  (add-hook 'savehist-mode-hook (lambda ()
					  (setq-default evil-markers-alist evil-markers-alist)
					  (kill-local-variable 'evil-markers-alist)
					  (make-local-variable 'evil-markers-alist))))
  ;; Persist local marks
  (append! desktop-locals-to-save evil-markers-alist)
  ;; Show Marks in buffer
  (my/general-global-Open "`" '(evil-show-marks :wk "Show marks"))
  :config (setq evil-fringe-mark-show-special t))
#+end_src

** Bookmark
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :unless noninteractive
  :after evil
  :config (my/general-global-menu! "Bookmarks" "B"
             "b" '(bookmark-jump :wk "Jump")
             "l" '(bookmark-bmenu-list :wk "List")
             "s" '(bookmark-set :wk "Set")
             "r" '(bookmark-rename :wk "Rename")
             "d" '(bookmark-delete :wk "Delete")
             "a" '(bookmark-set :wk "Add"))
  :init
  (setq bookmark-default-file (concat my/cache-dir "bookmarks")
        bookmark-save-flag 1))
#+end_src
* Project management
** Projectile
#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :unless noninteractive
  :config
  (projectile-mode +1)
  (my/general-global-menu! "Projects" "p"
    "" '(:keymap projectile-command-map :wk "projectile"))
  (setq projectile-switch-project-action #'projectile-dired)
  (defvar my/projectile-ignore-projects '("^/sudo:" "^/docker:" "^/nix/store"))
  (defun my/projectile-ignore-projects (project-root)
    "Ignore matching regexes in `my/projectile-ignore-projects'."
    (cl-some (lambda (regex) (string-match-p regex project-root))
	     my/projectile-ignore-projects))
  (setq projectile-ignored-project-function #'my/projectile-ignore-projects))
#+end_src
** Tabs
#+begin_src emacs-lisp
(use-package tabspaces
  ;; use this next line only if you also use straight, otherwise ignore it. 
  :hook (after-init . tabspaces-mode) ;; use this only if you want the minor-mode loaded at startup. 
  ;; :commands (tabspaces-switch-or-create-workspace
  ;;            tabspaces-open-or-create-project-and-workspace)
  :custom
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "Default")
  (tabspaces-remove-to-default t)
  (tabspaces-include-buffers '("*scratch*"))
  (tabspaces-initialize-project-with-todo t)
  (tabspaces-todo-file-name "project-todo.org")
  ;; sessions
  (tabspaces-session t)
  (tabspaces-session-auto-restore t)
  (tabspaces-session-file (concat my/cache-dir "tabspaces.el"))
  (tabspaces-keymap-prefix nil)
  :config
  (my/general-global-menu! "Workspaces" "TAB"
    "C" '(tabspaces-clear-buffers :wk "Clear buffers")
    "r" '(tabspaces-remove-current-buffer :wk "Remove current buffer")
    "R" '(tabspaces-remove-selected-buffer :wk "Remove selected buffer")
    "d" '(tabspaces-close-workspace :wk "Delete workspace")
    "D" '(tabspaces-kill-buffers-close-workspace :wk "Delete workspace and kill buffers")
    "o" '(tabspaces-open-or-create-project-and-workspace :wk "Open/Create project ws")
    "s" '(tabspaces-switch-or-create-workspace :wk "Switch/Create ws")
    "TAB" '(tabspaces-switch-or-create-workspace :wk "Switch/Create ws")
    "t" '(tabspaces-switch-buffer-and-tab :wk "Switch buffer and tab")
    "b" '(tabspaces-switch-to-buffer :wk "Switch buffer")
    )
  (setopt tab-bar-show nil))
  #+end_src
* Buffer management
#+begin_src emacs-lisp
(use-package ibuffer
  :unless noninteractive
  :ensure nil
  :general (my/general-global-Buffer
	     "i" '(ibuffer :wk "ibuffer"))
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-saved-filters nil)
  (define-ibuffer-column size
    (:name "Size" :inline t)
    (file-size-human-readable (buffer-size))))
; next/prev buffer skip special buffers
(setq switch-to-prev-buffer-skip-regexp '("^\\*.*\\*$"))
#+end_src
* Dired
#+begin_src emacs-lisp
(use-package dired
  :unless noninteractive
  :ensure nil
  :general (my/general-global-Open "d" '(dired :wk "dired"))
  :config
  (setq dired-listing-switches "-alh --group-directories-first"
	dired-dwim-target t
	dired-recursive-copies 'always
	dired-recursive-deletes 'always
	dired-hide-details-hide-symlink-targets nil
	dired-hide-details-hide-information-lines nil
	insert-directory-program (if IS-MAC (executable-find "gls") insert-directory-program)
	dired-use-ls-dired t
	dired-auto-revert-buffer t
      dired-kill-when-opening-new-dired-buffer t)
  (add-hook 'dired-mode-hook #'hl-line-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode))
#+end_src
* Tree Sitter
#+begin_src emacs-lisp
(use-package tree-sitter
  :ensure nil
  :config
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
  (global-tree-sitter-mode))
(use-package tree-sitter-langs
  :requires tree-sitter
  :unless noninteractive
  :after tree-sitter)
(use-package treesit-auto
  :config
  (setq treesit-auto-install 'prompt))
#+end_src
**** Tree Sitter
#+begin_src emacs-lisp
(use-package evil-textobj-tree-sitter
  :requires (evil tree-sitter)
  :config
  (defun meain/fancy-narrow-to-thing (thing)
    (interactive)
    (if (buffer-narrowed-p) (fancy-widen))
    (let ((range (evil-textobj-tree-sitter--range 1 (list (intern thing)))))
      (fancy-narrow-to-region (car range) (cdr range))))
  (my/general-global-menu! "Narrow" "n"
    "n" `(,(lambda () (interactive) (fancy-widen)) :wk "widen")
    "f" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "function.outer")) :wk "function")
    "c" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "class.outer")) :wk "class")
    "C" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "comment.outer")) :wk "comment")
    "o" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "loop.outer")) :wk "loop")
    "i" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "conditional.outer")) :wk "conditional")
    "a" `(,(lambda () (interactive) (meain/fancy-narrow-to-thing "parameter.outer")) :wk "parameter"))
  ;; copied from doomemacs
  (defvar +tree-sitter-inner-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-outer-text-objects-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-previous-map (make-sparse-keymap))
  (defvar +tree-sitter-goto-next-map (make-sparse-keymap))


  (evil-define-key '(visual operator) 'tree-sitter-mode
    "i" +tree-sitter-inner-text-objects-map
    "a" +tree-sitter-outer-text-objects-map)
  (evil-define-key 'normal 'tree-sitter-mode
    "[g" +tree-sitter-goto-previous-map
    "]g" +tree-sitter-goto-next-map)
  (general-def :keymaps '+tree-sitter-inner-text-objects-map
    "A" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.inner" "call.inner")) :wk "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.inner") :wk "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.inner") :wk "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.inner") :wk "class")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.inner") :wk "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.inner") :wk "loop")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.inner") :wk "comment"))
  (general-def :keymaps '+tree-sitter-outer-text-objects-map
    "A" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")) :wk "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.outer") :wk "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.outer") :wk "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.outer") :wk "class")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.outer") :wk "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.outer") :wk "loop")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.outer") :wk "comment"))
  (general-def :keymaps '+tree-sitter-goto-previous-map
    "a" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer") t) :wk "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.outer" t) :wk "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.outer" t) :wk "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.outer" t) :wk "class")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.outer" t) :wk "comment")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.outer" t) :wk "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.outer" t) :wk "loop"))
  (general-def :keymaps '+tree-sitter-goto-next-map
    "a" `(,(evil-textobj-tree-sitter-get-textobj ("parameter.outer" "call.outer")) :wk "call")
    "f" `(,(evil-textobj-tree-sitter-get-textobj "function.outer") :wk "function")
    "F" `(,(evil-textobj-tree-sitter-get-textobj "call.outer") :wk "call")
    "C" `(,(evil-textobj-tree-sitter-get-textobj "class.outer") :wk "class")
    "c" `(,(evil-textobj-tree-sitter-get-textobj "comment.outer") :wk "comment")
    "v" `(,(evil-textobj-tree-sitter-get-textobj "conditional.outer") :wk "conditional")
    "l" `(,(evil-textobj-tree-sitter-get-textobj "loop.outer") :wk "loop")))
#+end_src
* Aggressive Indent Mode
#+begin_src emacs-lisp
(use-package aggressive-indent
  :unless noninteractive
  :config
  (global-aggressive-indent-mode 1))
#+end_src
* Calc
#+begin_src emacs-lisp
(use-package calc
  :unless noninteractive
  :ensure nil ;; built-in
  :general (my/general-global-Open
	     "c" '(calc :wk "calc")
	     "C" '(full-calc :wk "full-calc"))
  :config
  (setq calc-angle-mode 'rad
	calc-algebraic-mode t
        calc-display-trail t
        calc-group-digits t
        calc-line-numbering t
        calc-multiplication-has-precedence t
        calc-number-radix 10
        calc-symbolic-mode t
        calc-undo-length 1000
        calc-window-height 15)
  (add-hook 'calc-mode-hook #'my/disable-line-numbers))
#+end_src
* String Inflection
#+begin_src emacs-lisp
(use-package string-inflection
  :unless noninteractive
  :after evil
  :general (my/general-global-menu! "naming convention" "c ~"

             "~" '(string-inflection-all-cycle :wk "cycle")
	     "t" '(string-inflection-toggle :wk "toggle")
	     "c" '(string-inflection-camelcase :wk "CamelCase")
	     "d" '(string-inflection-lower-camelcase :wk "downCase")
	     "k" '(string-inflection-kebab-case :wk "kebab-case")
	     "_" '(string-inflection-underscore :wk "under_score")
	     "u" '(string-inflection-capital-underscore :wk "Upper_Score")
	     "U" '(string-inflection-upcase :wk "UP_CASE"))
  :init
  
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection))
    #+end_src
* Smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :unless noninteractive
  :general (my/general-global-Toggle "p" #'smartparens-mode)
  :hook (prog-mode . smartparens-mode)
  :hook (prog-mode . show-smartparens-mode)
  :config
  (show-smartparens-global-mode t))
(use-package evil-smartparens
  :unless noninteractive
  :after (evil smartparens)
  :hook (smartparens-mode . evil-smartparens-mode)
  :hook (smartparens-strict-mode . evil-smartparens-mode))
#+end_src
* Help
** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :unless noninteractive
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-command] . helpful-command)
  :config
  (after! undo-tree
	  (append! undo-tree-incompatible-major-modes #'helpful-mode)))
#+end_src
** Man & TLDR
#+begin_src emacs-lisp
(use-package tldr
  :unless noninteractive
  :commands (tldr tldr-update-docs)
  :init
  (my/general-global-menu! "Command line help" "h h"

                           "t" '('tldr :wk "tldr")
                           "h" '('man :wk "man")
                           "w" '('woman :wk "Woman"))
  :config
  (setq tldr-directory-path (concat my/cache-dir "tldr/")))
#+end_src
* Undo Tree
#+begin_src emacs-lisp
(use-package undo-tree 
  :unless noninteractive
  :demand
  :diminish
  :config
  (global-undo-tree-mode)
  (defun undo-tree-visualizer-update-linum (&rest args)
    (linum-update undo-tree-visualizer-parent-buffer))
  (advice-add 'undo-tree-visualize-undo :after #'undo-tree-visualizer-update-linum)
  (advice-add 'undo-tree-visualize-redo :after #'undo-tree-visualizer-update-linum)
  (advice-add 'undo-tree-visualize-undo-to-x :after #'undo-tree-visualizer-update-linum)
  (advice-add 'undo-tree-visualize-redo-to-x :after #'undo-tree-visualizer-update-linum)
  (advice-add 'undo-tree-visualizer-mouse-set :after #'undo-tree-visualizer-update-linum)
  (advice-add 'undo-tree-visualizer-set :after #'undo-tree-visualizer-update-linum) 
  (setq evil-undo-system 'undo-tree
	undo-tree-history-directory-alist `(("." . ,(concat my/cache-dir "undo-tree-hist/"))))
  ;; no need to save history for these modes
  (dolist (m '(read-only-mode
	       eshell-mode
	       help-mode
	       term-mode
	       vterm-mode
	       magit-status-mode
	       magit-log-mode
	       magit-diff-mode
	       magit-commit-mode))
    (add-to-list 'undo-tree-incompatible-major-modes m))
  (my/leader-def "o u" 'undo-tree-visualize))
#+end_src
* Completion
** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :unless noninteractive
  :demand
  :bind (:map corfu-map
              ("TAB" . corfu-next)
              ([tab] . corfu-next)
              ("S-TAB" . corfu-previous)
              ([backtab] . corfu-previous))
  :custom
  (corfu-cycle t)
  (corfu-auto t)                 ;; Enable auto completion
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  (corfu-preselect 'prompt)      ;; Preselect the prompt
  (corfu-on-exact-match nil)     ;; Configure handling of exact matches
  (corfu-scroll-margin 5)        ;; Use scroll margin
  :config
  (global-corfu-mode)
  (defun corfu-move-to-minibuffer ()
    (interactive)
    ;; close corfu popup then move to minibuffer
    (when completion-in-region--data
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
	(apply #'consult-completion-in-region completion-in-region--data))))
  (general-def 'insert corfu-map "C-j" #'corfu-move-to-minibuffer)
  (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)
  (add-hook 'corfu-mode #'corfu-popupinfo-mode)
  (setq corfu-popupinfo-delay '(0.25 . 0.25)))
(use-package emacs
  :ensure nil
  :init
  (setq completion-cycle-threshold t)

  ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  (setq read-extended-command-predicate #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
;; Use Dabbrev with Corfu!
(use-package dabbrev
  :unless noninteractive
  :ensure nil
  ;; Swap M-/ and C-M-/
  :bind (("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand))
  ;; Other useful Dabbrev configurations.
  :custom
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src
*** Corfu Popup Info
#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-hide nil)
  (corfu-popupinfo-delay '(0.25 . 0)))
#+end_src
*** Corfu History
#+begin_src emacs-lisp
(use-package corfu-history
  :unless noninteractive
  :ensure corfu
  :hook (corfu-mode . corfu-history-mode)
  :config)
  ;; (after! savehist
  ;; 	  (append! savehist-additional-variables corfu-history)))
#+end_src
** Icons
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :requires corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
** Cape
#+begin_src emacs-lisp
(use-package cape
  :unless noninteractive
  :general (my/general-global-menu! "Completions" "c p"
             "p" '(completion-at-point :wk "Complete at point")
             "t" '(complete-tag :wk "Complete tag")
             "d" '(cape-dabbrev :wk "Dabbrev")
             "f" '(cape-file :wk "File")
             "k" '(cape-keyword :wk "Keyword")
             "s" '(cape-symbol :wk "Symbol")
             "a" '(cape-abbrev :wk "Abbrev")
             "i" '(cape-ispell :wk "Ispell")
             "l" '(cape-line :wk "Line")
             "w" '(cape-dict :wk "Dict")
             "\\" '(cape-tex :wk "Tex")
             "_" '(cape-tex :wk "Tex")
             "^" '(cape-tex :wk "Tex")
             "&" '(cape-sgml :wk "Sgml")
             "r" '(cape-rfc1345 :wk "Rfc1345"))
  :init (defvar my/completion-at-point-functions (list))
  :config
  ;; (setq completion-at-point-functions
  ;;       (cape-super-capf #'cape-dabbrev #'cape-file #'cape-keyword #'cape-symbol))
  (append! my/completion-at-point-functions
    #'cape-abbrev
    #'cape-file
    #'cape-elisp-block
    #'cape-history
    ;;#'cape-tex
    #'cape-keyword
    ;;#'cape-sgml
    ;;#'cape-rfc1345
    #'cape-symbol
    ;;#'cape-line
    #'cape-dict
    #'cape-ispell
    )
  ;; update `completion-at-point-functions' if `my/completion-at-point-functions' changed.
  (add-hook 'after-change-major-mode-hook
	    (lambda ()
	      (setq completion-at-point-functions
		    (cape-super-capf my/completion-at-point-functions)))))
#+end_src
** Tempel
#+begin_src emacs-lisp
(use-package tempel
  :unless noninteractive
  :init
  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
    ;; only triggers on exact matches. Alternatively use `tempel-complete' if
    ;; you want to see all matches, but then Tempel will probably trigger too
    ;; often when you don't expect it.
    ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
    ;; such that it will be tried first.
    ;; (setq-local completion-at-point-functions
    ;;             (cons #'tempel-expand
    ;;                   completion-at-point-functions))
    (after! cape
	    (append! my/completion-at-point-functions #'tempel-expand)))

  :hook (prog-mode . tempel-setup-capf)
  :hook (text-mode . tempel-setup-capf)
  :defer 1)
(use-package tempel-collection
  :after tempel
  :config)
#+end_src
** Marginalia
#+begin_src emacs-lisp
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  :unless noninteractive
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  ;; :bind (:map minibuffer-local-map
  ;;        ("M-A" . marginalia-cycle))
  ;; load after completion-at-point
  :config (marginalia-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp
;; Enable orderless matching style.  See `+orderless-dispatch' in
;; `consult-config.el' for an advanced Orderless style dispatcher.
(use-package orderless
  :unless noninteractive
  :after vertico
  :custom
  (completion-styles '(orderless partial-completion basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src
** Vertico
#+begin_src emacs-lisp
;; Enable vertico
(use-package vertico
  :unless noninteractive
  :custom
  ;; Enable cycling for `vertico-next' and `vertico-previous'.
  (vertico-cycle t)
  ;; Grow and shrink the Vertico minibuffer
  (resize-mini-windows 'grow-only)
  (vertico-count 20)
  :config
  (vertico-mode)
  (after! embark
	  (general-def
	    :keymaps 'vertico-map
	    "C-c C-o" #'embark-export
	    "C-c C-c" #'embark-act
	    "C-c C-f" #'embark-become))
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src
** Consult
#+begin_src emacs-lisp
(use-package consult
  :unless noninteractive
  :general (my/leader-def
             "/" '(consult-ripgrep :wk "Search project"))
  :general (my/general-global-Search
	     "s" '(consult-line :wk "Search line"))
  :general (my/general-global-Buffer
	     "b" '(consult-buffer :wk "Buffer selection"))
  :general (my/general-global-File
	     "r" '(consult-recent-file :wk "Recent File"))
  :general (:keymaps 'help-map
		     "h m" '(consult-man :wk "Manpage")))
(use-package consult-flymake
  :ensure consult
  :general (my/general-global-Errors
	     "f" '(consult-flymake :wk "Consult Flymake")))
#+end_src
** Embark
#+begin_src emacs-lisp
(use-package embark
  :unless noninteractive
  :config
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  (setq which-key-use-C-h-commands nil
        prefix-help-command #'embark-prefix-help-command)
  (general-define-key [remap describe-bindings] #'embark-bindings)
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (setq embark-prompter 'embark-completing-read-prompter)
  :general (my/general-global-menu! "Embark" "e"
	     "o" '(embark-export :wk "export")
	     "e" '(embark-act :wk "act")
	     "b" '(embark-bindings :wk "bindings")
	     "c" '(embark-collect :wk "collect"))
  :general (general-def
	     :prefix "C-c e"
	     "o" '(embark-export :wk "export")
	     "e" '(embark-act :wk "act")
	     "b" '(embark-bindings :wk "bindings")
	     "c" '(embark-collect :wk "collect")))
(use-package embark-consult
  :if (and (featurep 'embark)
	   (featurep 'consult))
  :after (embark consult)
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src
* Terminal
** EAT
#+begin_src emacs-lisp
(use-package eat
  :unless noninteractive
  :hook (eshell-load . eat-eshell-mode)
  :general (my/general-global-Open "t" '(eat :wk "Terminal"))
  :config
  (add-popup!
   "^\\*eat.*\\*$"  'eat-mode)
  (eat-eshell-mode))
#+end_src
** Eshell
#+begin_src emacs-lisp
(use-package eshell
  :unless noninteractive
  :ensure nil
  :commands eshell
  :init
  (setq my/repl-fallback #'eshell)
  (my/general-global-Open
    "e" '(eshell :wk "eshell"))
  (setq eshell-aliases-file (concat my/cache-dir "eshell/alias")
	eshell-history-file-name (concat my/cache-dir "eshell/history")
	eshell-buffer-maximum-lines 10000
	eshell-hist-ignoredups t
	eshell-scroll-to-bottom-on-input 'all
	eshell-error-if-no-glob t
	eshell-glob-case-insensitive t
	eshell-scroll-show-maximum-output nil)
  (make-directory (concat my/cache-dir "eshell") t)
  :config
  (add-popup! "^\\*eshell.*\\*$" 'eshell-mode)
  (add-hook 'eshell-mode-hook #'my/disable-line-numbers)
  (after! corfu (add-hook 'eshell-mode-hook #'corfu-mode)))
(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+end_src
* Formatting and linting/checking
** Format on save
#+begin_src emacs-lisp
(use-package apheleia
  :unless noninteractive
  ;;:config (apheleia-global-mode +1)
)
#+end_src
** Linting
#+begin_src emacs-lisp
(use-package flycheck
  :unless noninteractive
  :general (my/general-global-menu! "Errors" "c e"
             "e" '(flycheck-list-errors :wk "List errors")
             "n" '(flycheck-next-error :wk "Next error")
             "p" '(flycheck-previous-error :wk "Previous error")
             "d" '(flycheck-describe-checker :wk "Describe checker")
             "v" '(flycheck-verify-setup :wk "Verify setup"))
  :config
  (global-flycheck-mode)
  (add-popup! "^\\*Flycheck.*\\*$" #'flycheck-error-list-mode)
  :custom
  (flycheck-emacs-lisp-load-path 'inherit)
  (flycheck-display-errors-delay 0.25)
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-indication-mode 'right-fringe))
#+end_src
** Spell Checking (aspell)
#+begin_src emacs-lisp
(use-package flycheck-aspell
  :unless noninteractive
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode))
  :general (my/general-global-menu! "Spell" "e s"

                                   "s" '(flyspell-buffer :wk "Spell buffer")
                                   "n" '(flyspell-goto-next-error :wk "Next error")
                                   "p" '(flyspell-goto-previous-error :wk "Previous error"))
  :config
  ;; If you want to check TeX/LaTeX/ConTeXt buffers
  (add-to-list 'flycheck-checkers 'tex-aspell-dynamic)
  ;; If you want to check Markdown/GFM buffers
  (add-to-list 'flycheck-checkers 'markdown-aspell-dynamic)
  ;; If you want to check HTML buffers
  (add-to-list 'flycheck-checkers 'html-aspell-dynamic)
  ;; If you want to check XML/SGML buffers
  (add-to-list 'flycheck-checkers 'xml-aspell-dynamic)
  ;; If you want to check Nroff/Troff/Groff buffers
  (add-to-list 'flycheck-checkers 'nroff-aspell-dynamic)
  ;; If you want to check Texinfo buffers
  (add-to-list 'flycheck-checkers 'texinfo-aspell-dynamic)
  ;; If you want to check comments and strings for C-like languages
  (add-to-list 'flycheck-checkers 'c-aspell-dynamic)
  ;; If you want to check message buffers
  (add-to-list 'flycheck-checkers 'mail-aspell-dynamic)
  ;; Because Aspell does not support Org syntax, the user has
  ;; to define a checker with the desired flags themselves.
  (flycheck-aspell-define-checker "org"
                                  "Org" ("--add-filter" "url")
                                  (org-mode))
  (add-to-list 'flycheck-checkers 'org-aspell-dynamic)


  (advice-add #'ispell-pdict-save :after #'flycheck-maybe-recheck)
  (defun flycheck-maybe-recheck (_)
    (when (bound-and-true-p flycheck-mode)
      (flycheck-buffer)))

  (evil-define-key 'normal flyspell-mode-map (kbd "z =") 'flyspell-correct-word-before-point)
  (evil-define-key 'normal flyspell-mode-map (kbd "z g") 'flyspell-auto-correct-word)
  :custom
  (ispell-program-name "aspell")
  (ispell-extra-args '("--sug-mode=ultra")))
#+end_src
* Env
** Inherit ENV
#+begin_src emacs-lisp
(use-package inheritenv)
#+end_src
** direnv
#+begin_src emacs-lisp
(use-package envrc
  :hook (after-init . envrc-global-mode))
#+end_src
* Git
** Magit
#+begin_src emacs-lisp
(use-package magit
  :unless noninteractive
  :general (my/general-global-Git
             "g" '(magit-status :wk "Status")
             "b" '(magit-blame :wk "Blame")
             "l" '(magit-log :wk "Log")
             "G" '(magit-status-here :wk "Status here")
             "B" '(magit-blame-here :wk "Blame here")
             "S" '(magit-stage-file :wk "Stage file"))
  :init
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-log-arguments '("--graph" "--decorate" "--color"))
  (setq git-commit-fill-column 72)
  :config
  (add-popup! "\\*\\*magit-process:.*\\*\\*")
  (setq magit-buffer-name-format (concat "*" magit-buffer-name-format "*"))
  (append! magit-status-sections-hook #'magit-insert-modules)
  (evil-define-key* '(normal visual) magit-mode-map
    "zz" #'evil-scroll-line-to-center))
#+end_src
** Time Machine
#+begin_src emacs-lisp
(use-package git-timemachine
  :unless noninteractive
  :init (setq git-timemachine-show-minibuffer-details t)
  :config (add-hook 'git-timemachine-mode-hook 'evil-normalize-keymaps)
  :general
  (my/general-global-Git
    "t" '(git-timemachine :wk "Time machine"))
  (:keymaps 'git-timemachine-mode-map
	    "C-k" 'git-timemachine-show-previous-revision
	    "C-j" 'git-timemachine-show-next-revision
	    "q" 'git-timemachine-quit))
#+end_src
** Git Gutter
#+begin_src emacs-lisp
(use-package git-gutter+
  :unless noninteractive
  :config
  (global-git-gutter+-mode t)
  (my/general-global-Git
    "n" '(git-gutter+-next-hunk :wk "next hunk")
    "p" '(git-gutter+-previous-hunk :wk "previous hunk")
    "s" '(git-gutter+-stage-hunks :wk "stage hunk")
    "r" '(git-gutter+-revert-hunk :wk "revert hunk")))
#+end_src
** Forge
#+begin_src emacs-lisp
(use-package forge
  :unless noninteractive
  :after magit
  :commands (forge-insert-topics
	     forge-insert-assigned-pullreqs
	     forge-insert-authored-pullreqs
	     forge-insert-requested-reviews
	     forge-insert-assigned-issues
	     forge-insert-pullreqs
	     forge-insert-issues
	     forge-insert-discussions)
  :init
  (append! magit-status-sections-hook
    #'forge-insert-topics
    #'forge-insert-assigned-pullreqs
    #'forge-insert-authored-pullreqs
    #'forge-insert-requested-reviews
    #'forge-insert-assigned-issues
    #'forge-insert-pullreqs
    #'forge-insert-issues
    #'forge-insert-discussions))
#+end_src
* Eglot
#+begin_src emacs-lisp
(use-package eglot
  :unless noninteractive
  :ensure nil ;; included in emacs29+
  :commands (eglot eglot-ensure)
  :init
  (use-package markdown-mode) ;; Better formatting eldoc
  (setq eglot-events-buffer-size 0) ;; don't log events
  :config
  (my/general-global-menu! "LSP" "cl"
    "a" #'eglot-code-actions
    "d" #'eglot-help-at-point
    "f" #'eglot-format-buffer)
  (after! cape
	  (add-hook
	   'eglot-managed-mode-hook
	   (lambda ()
	     (append! completion-category-overrides '((eglot (styles orderless))))
	     (setq completion-category-defaults nil)
	     (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
             (make-local-variable 'my/completion-at-point-functions)
	     (append! my/completion-at-point-functions #'eglot-completion-at-point)
	     (setq-local completion-at-point-functions my/completion-at-point-functions)))))
#+end_src
** Eglot Tempel
#+begin_src emacs-lisp
(use-package eglot-tempel
  :unless noninteractive
  :after (eglot tempel))
#+end_src
** Flycheck Eglot
#+begin_src emacs-lisp
(use-package flycheck-eglot
  :unless noninteractive
  :after (flycheck eglot)
  :config (global-flycheck-eglot-mode 1))
#+end_src
** Sideline
#+begin_src emacs-lisp
(use-package sideline
  :hook ((flycheck-mode . sideline-mode)   ; for `sideline-flycheck`
         (flymake-mode  . sideline-mode))  ; for `sideline-flymake`
  :init
  (setq sideline-backends-left-skip-current-line t   ; don't display on current line (left)
        sideline-backends-right-skip-current-line t  ; don't display on current line (right)
        sideline-order-left 'down                    ; or 'up
        sideline-order-right 'up                     ; or 'down
        sideline-format-left "%s   "                 ; format for left aligment
        sideline-format-right "   %s"                ; format for right aligment
        sideline-priority 100                        ; overlays' priority
        sideline-display-backend-name t)             ; display the backend name
  )
(use-package sideline-flycheck
  :requires (sideline flycheck)
  :hook (flycheck-mode . sideline-flycheck-setup)
  :commands sideline-flycheck
  :init
  (setq sideline-backends-left '(sideline-flycheck)))
#+end_src
** eldoc
#+begin_src emacs-lisp
(use-package eldoc
  :ensure nil
  :diminish
  :custom
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t))
#+end_src
*** eldoc-box
#+begin_src emacs-lisp
(use-package eldoc-box
  :hook (emacs-lisp-mode . eldoc-box-hover-mode)
  :hook (eglot--managed-mode . eldoc-box-hover-mode))
#+end_src

* Languages
** Nix
#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'"
  :config
  (add-hook 'nix-mode-hook #'eglot-ensure))

(use-package nix-drv-mode
  :ensure nix-mode
  :mode "\\.drv\\'")
(use-package nix-shell
  :ensure nix-mode
  :commands (nix-shell-unpack nix-shell-configure nix-shell-build))
(use-package nix-repl
  :ensure nix-mode
  :general (my/general-global-Open
	     :definer 'minor-mode
	     :keymaps 'nix-mode-map
	     "r" 'nix-repl))
#+end_src
** Python
#+begin_src emacs-lisp
(my/local-leader-def python-mode)
(after! treesit-auto
	(setq python-ts-mode-hook python-mode-hook)) 

(use-package python
  ;; :mode ("\\.py\\'" . python-mode)
  :mode ("[./]flake8\\'" . conf-mode)
  :mode ("/Pipfile\\'" . conf-mode)
  ;; :interpreter ("python" . python-mode)
  :general (my/local-leader-def-python-mode
	     "r" '(run-python :wk "repl/python")
	     "b" '(python-shell-send-buffer :wk "send buffer to repl"))
  :init
  (setq python-check-command "pyflakes")
  :config
  (add-hook 'python-mode-hook 'eglot-ensure))

(use-package ob-python
  :ensure nil
  :after org
  :commands org-babel-execute:python
  :init
  (add-to-list 'org-babel-load-languages '(python . t))
  (setq org-babel-python-command "python3"))
#+end_src
*** Virtual Environments
#+begin_src emacs-lisp
(use-package pyvenv
  :defer t
  :config
  ;; Display virtual envs in the menu bar
  (setq pyvenv-menu t)
  ;; Restart the python process when switching environments
  (add-hook 'pyvenv-post-activate-hooks (lambda ()
					  (pyvenv-restart-python)))
  :after python
  :hook (python-mode . pyvenv-mode)
  :general (my/leader-def
             :keymaps 'python-mode-map
             :prefix "m"
             "v" '(pyvenv-workon :wk "workon")))

(use-package poetry
  :after python
  :hook (python-mode . poetry-tracking-mode)
  :general (my/leader-def
             :keymaps 'python-mode-map
	     :prefix "m"
	     "p" '(poetry :wk "poetry")))

#+end_src
*** Imports
#+begin_src emacs-lisp
(use-package pyimport
  :after python
  :general (my/local-leader-def-python-mode
	     "i" '(nil :wk "import")
	     "i i" '(pyimport-insert-missing :wk "insert missing imports")
	     "i r" '(pyimport-remove-unused :wk "remove unused imports")))

(use-package py-isort
  :hook (before-save . py-isort-before-save)
  :general (my/local-leader-def-python-mode
	     "i s" '(py-isort-buffer :wk "sort imports")))
#+end_src
*** Numpy Docstring
#+begin_src emacs-lisp
(use-package numpydoc
  :init
  (after! yasnippet
          (setq numpydoc-insertion-style 'numpydoc))
  :general (my/local-leader-def-python-mode
                                "d" '(numpydoc-generate :wk "generate docstring")))
#+end_src
** Rust
#+begin_src emacs-lisp
(use-package rustic
  :mode ("\\.rs$" . rustic-mode)
  :init
  (defun my/startup-rust ()
    (setq-local compile-command "cargo run")
    (when (boundp 'flycheck-checkers)
      (make-local-variable 'flycheck-checkers)
      (push 'rustic-clippy flycheck-checkers)))
  (add-hook 'rustic-mode-hook #'my/startup-rust)
  :config
  (add-hook 'rustic-mode-hook 'eglot-ensure)
  (setq rustic-indent-method-chain t)
  (my/local-leader-def rustic-mode
		       "b" '(nil :wk "build")
		       "bb" '(rustic-cargo-build :wk "build")
		       "br" '(rustic-cargo-run :wk "run")
		       "ba" '(rustic-cargo-audit :wk "audit")
		       "bt" '(rustic-cargo-test :wk "test")
		       "bc" '(rustic-cargo-check :wk "check")
		       "bd" '(rustic-cargo-build-doc :wk "doc")
		       "bD" '(rustic-cargo-doc :wk "doc open")
		       "bn" '(rustic-cargo-new :wk "new")
		       "c" '(nil :wk "cargo")
		       "co" '(rustic-cargo-outdated :wk "outdated")
		       "ca" '(rustic-cargo-add :wk "add")
		       "cd" '(rustic-cargo-rm :wk "rm")
		       "cA" '(rustic-cargo-add-missing-dependencies :wk "add missing")
		       "m" '(rustic-cargo-expand :wk "macro expand")))
(use-package rustic-babel
  :ensure nil
  :after org
  :commands (org-babel-execute:rustic)
  :init
  (add-to-list 'org-src-lang-modes '("rust" . rustic))
  (add-to-list 'org-babel-tangle-lang-exts '("rustic" . "rs"))
  (defalias 'org-babel-execute:rust #'org-babel-execute:rustic))
#+end_src
** Haskell
#+begin_src emacs-lisp
(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :config
  (add-hook 'haskell-mode-hook 'eglot-ensure)
  (my/local-leader-def haskell-mode
		       "b" 'haskell-process-cabal-build
		       "c" 'haskell-cabal-visit-file
		       "h" 'haskell-hide-toggle
		       "H" 'haskell-hide-toggle-all))
(use-package ob-haskell
  :ensure nil
  :after org
  :commands org-babel-execute:haskell
  :init
  (add-to-list 'org-babel-load-languages '(haskell . t)))
#+end_src
** Julia
#+begin_src emacs-lisp
(use-package julia-mode
  :mode ("\\.jl\\'" . julia-mode)
  :config
  (add-hook 'julia-mode-hook #'eglot-ensure)
  (my/local-leader-def julia-mode
		       "b" 'julia-repl-send-buffer
		       "r" 'julia-repl-send-region-or-line
		       "R" 'julia-repl
		       "f" 'julia-repl-send-defun
		       "l" 'julia-repl-send-line
		       "s" 'julia-repl
		       "S" 'julia-repl-switch)
  (defun my/julia-def ()
    (my/general-global-Open :keymaps 'local
      "r" 'julia-repl-send-region-or-line
      "f" 'julia-repl-send-defun
      "l" 'julia-repl-send-line))
  (add-hook 'julia-mode-hook #'my/julia-def))
;; First use requires running 'import Pkg; Pkg.add("LanguageServer")' in the Julia REPL
#+end_src
*** REPL
#+begin_src emacs-lisp
(use-package julia-vterm
  :hook (julia-mode . julia-vterm-mode)
  :init (setq julia-vterm-repl-program (concat (executable-find "julia") " --color=yes --startup-file=no -t " (number-to-string my/available-cores)))
  :config
  (add-popup! "\\*julia:main\\*")
  (add-hook 'julia-mode-hook (lambda () (setf (alist-get 'julia-mode my/repl-alist) #'julia-vterm-repl))))
#+end_src
*** Babel
#+begin_src emacs-lisp
(use-package ob-julia-vterm
  :after org
  :commands org-babel-execute:julia-vterm
  :init
  (add-to-list 'org-babel-load-languages '(julia-vterm . t)))
#+end_src
** PDF
#+begin_src emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq pdf-view-use-scaling t)
  (add-hook 'pdf-view-mode-hook #'my/disable-line-numbers)
  (add-to-list 'recentf-exclude "/**/*.pdf")
  (add-to-list 'undo-tree-incompatible-major-modes 'pdf-view-mode))
#+end_src
** Shell
#+begin_src emacs-lisp
(use-package sh-script
  :ensure nil
  :mode ("\\.zsh\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.zshrc\\'" . (lambda () (sh-mode) (sh-set-shell "zsh")))
  :mode ("\\.sh\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :mode ("\\.bashrc\\'" . (lambda () (sh-mode) (sh-set-shell "bash")))
  :config 
  (setq sh-basic-offset 4
        sh-indentation 4))
#+end_src
** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile.*\\'" . dockerfile-mode))

(use-package docker
  :general (my/general-global-Open "D" 'docker))
#+end_src
* Mail
** mu4e
#+begin_src emacs-lisp :lexical t
(defun my/get-mail-dir ()
  (expand-file-name "mail/" (getenv "XDG_DATA_HOME")))

(defconst my/mail-dir (my/get-mail-dir))
;; Only load on personal machines with mail
(defconst my/enable/mu4e (and (not noninteractive) IS-PERSONAL (file-directory-p my/mail-dir)))

(use-package mu4e
  :if my/enable/mu4e
  :general(my/general-global-Open "m" '(mu4e :wk "Email"))
  :init
  (add-to-list 'recentf-exclude my/mail-dir)
  :config
  (my/local-leader-def mu4e-headers-mode
		       "u" '(mu4e-update-mail-and-index :wk "Update"))
  ;; Context switching for multiple accounts
  (defun my/create-mu4e-context (name address signature server &optional key)
    (unless key (setq key (substring name 0 1)))
    (make-mu4e-context
     :name (format "%s(%s)" key name)
     :enter-func (lambda () (mu4e-message "Entering context %s" name))
     :leave-func (lambda () (mu4e-message "Leaving context %s" name))
     :match-func (lambda (msg)
		   (when msg
		     (string-prefix-p (format "/%s" address)
				      (mu4e-message-field msg :maildir))))
     :vars `((user-mail-address . ,address)
	     (user-full-name . ,user-full-name)
	     (mu4e-compose-signature . ,(if (package-installed-p 'org-msg) signature))
	     (mu4e-sent-folder . ,(format "/%s/Sent" name))
	     (mu4e-drafts-folder . ,(format "/%s/Drafts" name))
	     (mu4e-trash-folder . ,(format "/%s/Trash" name))
	     (mu4e-refile-folder . ,(format "/%s/Archive" name))
	     (smtpmail-smtp-user . ,address)
	     (smtpmail-smtp-server . ,server)
	     (smtpmail-smtp-service . 587)
	     (smtpmail-stream-type . starttls)
	     (smtpmail-debug-info . t)
	     (smtpmail-debug-verb . t))))
  (defun my/wrap-signature (str)
    (concat
     "#+begin_signature\n"
     str
     "\n#+end_signature"))
  (defun my/gmail-signature (name)
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: " name "@gmail.com\n")))
  (defun my/udmercy-signature ()
    (my/wrap-signature
     (concat
      "\n*" user-full-name "*\n"
      "Email: bakheakm@udmercy.edu")))

  (setq
   mail-user-agent 'mu4e-user-agent
   read-mail-command 'mu4e
   mu4e-maildir my/mail-dir
   mu4e-confirm-quit nil
   ;; This is set to 't' to avoid mail syncing issues when using mbsync
   mu4e-change-filenames-when-moving t

   ;; Refresh mail using isync every 10 minutes
   mu4e-update-interval (* 10 60)
   mu4e-get-mail-command "mbsync -a"

   ;; Context policy
   mu4e-context-policy 'pick-first
   mu4e-compose-context-policy 'ask
   mu4e-contexts (list
                  (my/create-mu4e-context "kbakheat-gmail" "kbakheat@gmail.com" (my/gmail-signature "kbakheat") "smtp.gmail.com")
                  (my/create-mu4e-context "kirolsb5-gmail" "kirolsb5@gmail.com" (my/gmail-signature "kirolsb5") "smtp.gmail.com" "a")
                  (my/create-mu4e-context "bakheakm-udmercy" "bakheakm@udmercy.edu" (my/udmercy-signature) "smtp.office365.com"))))


(use-package mu4e-alert
  :if my/enable/mu4e
  :after mu4e
  :config
  (when IS-LINUX
    (progn (mu4e-alert-set-default-style 'libnotify)
	   (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (when IS-MAC
    (progn (mu4e-alert-set-default-style 'notifier)
	   (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)))
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src
** msmtp
#+begin_src emacs-lisp
(after! mu4e
        (setq message-send-mail-function #'message-send-mail-with-sendmail
              sendmail-program (executable-find "msmtp")
              send-mail-function #'smtpmail-send-it
              message-sendmail-f-is-evil t
              message-sendmail-extra-arguments '("--read-envelope-from")))
#+end_src
** Compose mail with org mode
#+begin_src emacs-lisp
(use-package org-msg
  :if my/enable/mu4e
  :after (org mu4e)
  :config (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
                org-msg-startup "hidestars indent inlineimages"
                org-msg-greeting-fmt "\nHey%s,\n\n"
                org-msg-greeting-name-limit 3
                org-msg-default-alternatives '((new		. (text html))
                                               (reply-to-html	. (text html))
                                               (reply-to-text	. (text)))
                org-msg-convert-citation t
                org-msg-signature "")
  (org-msg-mode))
#+end_src
* Org Mode
#+begin_src emacs-lisp
(use-package org
  :ensure nil ;; included in emacs
  :init
  (defun my/relative-org (dir)
    "Makes a sting representing a directory relative to my org base directory"
    (setq my-org-base-dir "~/org")
    (concat (file-name-as-directory my-org-base-dir) dir))
  :config
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        org-directory (my/relative-org "general/")
        org-insert-heading-respect-content t
        org-export-in-background t
        org-export-with-sub-superscripts '{}
        org-list-allow-alphabetical t
        org-auto-align-tags t
        org-tags-column 0
        org-catch-invisible-edits 'smart
        org-special-ctrl-a/e t
        org-fontify-quote-and-verse-blocks t
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-emphasized-text t

	org-ellipsis " ↷ "
	org-hide-emphasis-markers t
	org-pretty-entities t
	org-hide-leading-stars nil

	org-startup-indented t
	org-use-property-inheritance t))
#+end_src
** Keybindings
#+begin_src emacs-lisp
(use-package org
  :config
  (my/local-leader-def org-mode
    "#" #'org-update-statistics-cookies
    "'" #'org-edit-special
    "*" #'org-ctrl-c-star
    "+" #'org-ctrl-c-minus
    "," #'org-switchb
    "@" #'org-cite-insert
    "." #'consult-org-heading
    "/" #'counsel-org-goto-all
    "A" #'org-archive-subtree
    "e" #'org-export-dispatch
    "f" #'org-footnote-action
    "h" #'org-toggle-heading
    "i" #'org-toggle-item
    "I" #'org-id-get-create
    "k" #'org-babel-remove-result
    "n" #'org-store-link
    "o" #'org-set-property
    "q" #'org-set-tags-command
    "t" #'org-todo
    "T" #'org-todo-list
    "x" #'org-toggle-checkbox

    "a" '(nil :wk "attachments")
    "aa" 'org-attach
    "ad" 'org-attach-delete-one
    "aD" 'org-attach-delete-all
    "af" '+org/find-file-in-attachments
    "al" '+org/attach-file-and-insert-link
    "an" 'org-attach-new
    "ao" 'org-attach-open
    "aO" 'org-attach-open-in-emacs
    "ar" 'org-attach-reveal
    "aR" 'org-attach-reveal-in-emacs
    "au" 'org-attach-url
    "as" 'org-attach-set-directory
    "aS" 'org-attach-sync

    "b" '(nil :wk "tabels")
    "b-" 'org-table-insert-hline
    "ba" 'org-table-align
    "bb" 'org-table-blank-field
    "bc" 'org-table-create-or-convert-from-region
    "be" 'org-table-edit-field
    "bf" 'org-table-edit-formulas
    "bh" 'org-table-field-info
    "bs" 'org-table-sort-lines
    "br" 'org-table-recalculate
    "bR" 'org-table-recalculate-buffer-tables

    "bd" '(nil :wk "delete")
    "bdc" 'org-table-delete-column
    "bdr" 'org-table-kill-row

    "bi" '(nil :wk "insert")
    "bic" 'org-table-insert-column
    "bih" 'org-table-insert-hline
    "bir" 'org-table-insert-row
    "biH" 'org-table-hline-and-move

    "l" '(nil :wk "links")
    "lc" 'org-cliplink
    "ld" '+org/remove-link
    "li" 'org-id-store-link
    "ll" 'org-insert-link
    "lL" 'org-insert-all-links
    "ls" 'org-store-link
    "lS" 'org-insert-last-stored-link
    "lt" 'org-toggle-link-display
    "lg" '(org-mac-link-get-link :if IS-MAC)


    "s" '(nil :wk "subtree")
    "sa" 'org-toggle-archive-tag
    "sb" 'org-tree-to-indirect-buffer
    "sc" 'org-clone-subtree-with-time-shift
    "sd" 'org-cut-subtree
    "sh" 'org-promote-subtree
    "sj" 'org-move-subtree-down
    "sk" 'org-move-subtree-up
    "sl" 'org-demote-subtree
    "sn" 'org-narrow-to-subtree
    "sr" 'org-refile
    "ss" 'org-sparse-tree
    "sA" 'org-archive-subtree
    "sN" 'widen
    "sS" 'org-sort))
#+end_src
** Appearance
*** Prettify Symbols
#+begin_src emacs-lisp
(use-package org
  :config
  (defmacro my/prettify-symbols-org-mode (&rest pairs)
    "In org mode, keywords can be capital or lowercase. This macro
   will repeat the same prettify symbol for both cases."
    `(my/prettify-symbols-extend-mode 'org-mode
       ,@(delete-dups `(,@(mapcar (lambda (pair)
				    (cons (downcase (car pair))
					  (cdr pair)))
				  pairs)
			,@(mapcar (lambda (pair)
				    (cons (upcase (car pair))
					  (cdr pair)))
				  pairs)))))
  (my/prettify-symbols-org-mode
   ("#+title" . "")
   ("#+author" . "")
   ("#+date" . "")
   ("#+email" . "")
   ("#+options:" . "⚙")
   ("#+begin_example" . "")
   ("#+end_example" . "")
   ("#+begin_quote" . "")
   ("#+end_quote" . "")
   ("#+results:" . "")
   (":results" . "")
   (":dir" . "")
   ("#+begin_src" . "λ")
   ("#+end_src" . "λ")
   ("#+begin_export" . "⇒")
   ("#+end_export" . "⇐")
   ("#+results:" . "⇒")
   (":results" . "⇒")
   (":session" . "@")
   (":properties:" . "")
   (":logbook:" . "")
   )
  (my/prettify-symbols-extend-mode 'org-mode
    ("[ ]" . "☐")
    ("[X]" . "✔")
    ("[-]" . "✘")
    ("TODO" . "☐")
    ("DONE" . "✔")
    ("WAITING" . "☕")
    ("HOLD" . "❢")
    ("CANCELLED" . "✘")))
#+end_src
*** Org Tempo
#+begin_src emacs-lisp
(use-package org-tempo
  :unless noninteractive
  :ensure nil
  :after org)
#+end_src
*** Org Bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "✸" "✿" "✜" "◆" "◇")))
#+end_src
*** Org Tables
#+begin_src emacs-lisp
(use-package org-pretty-table
        :hook (org-mode . org-pretty-table-mode))
#+end_src
*** Org Num
#+begin_src emacs-lisp
(use-package org
  :config
  (add-hook 'org-mode-hook #'org-num-mode))
#+end_src
** Presenting
#+begin_src emacs-lisp
(use-package visual-fill-column
  :unless noninteractive
  :hook (org-present . visual-fill-column)
  :hook (org-present . visual-fill-line)
  :custom
  (visual-fill-column-width 110)
  (visual-fill-column-center-text t))
(use-package org-present
  :unless noninteractive
  :commands (org-present))
#+end_src
** LilyPond
#+begin_src emacs-lisp
(use-package lilypond
  :ensure nil ;; Comes with lilypond, installed with nix
  :preface (defvar my/lilypond (executable-find "lilypond"))
  :mode ("\\.ly\\'" . LilyPond-mode)
  :commands (LilyPond-mode)
  :if my/lilypond
  :init (defalias 'lilypond-mode 'LilyPond-mode))
(use-package ob-lilypond
  :ensure nil
  :after org
  :defer t
  :if my/lilypond
  :init
  :config
  ;; org-babel-lilypond-commands is a list of strings. We set just the first one to lilypond
  (setf (car org-babel-lilypond-commands) (executable-find "lilypond"))
  (setopt org-babel-lilypond-commands org-babel-lilypond-commands)
  (add-to-list 'org-babel-load-languages '(lilypond . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Notes
#+begin_src emacs-lisp
(my/general-global-menu! "Notes" "n")
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :unless noninteractive
  :commands (deft)
  :custom
  (deft-directory (my/relative-org "deft"))
  (deft-recursive t)
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t)
  (deft-extensions '("org" "md" "txt"))
  (deft-default-extension "org")
  (deft-file-naming-rules '((noslash . "-")
                            (nospace . "-")
                            (case-fn . downcase)))
  (deft-text-mode 'org-mode)
  :config
  (add-popup! "\\*Deft\\*")
  :general (my/general-global-Notes
             "d" '(deft :wk "deft")))
#+end_src
*** Roam
#+begin_src emacs-lisp
(use-package org-roam
  :unless noninteractive
  :custom
  (org-roam-v2-ack t)
  (org-roam-directory (my/relative-org "roam"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(
     <<roam-templates>>
     ))
  :general (my/general-global-Notes
	     "r"  '(nil :wk "roam")
	     "rf" '(org-roam-node-find :wk "find")
	     "ri" '(org-roam-node-insert :wk "insert")
	     "rg" '(org-roam-graph :wk "graph")
	     "rt" '(org-roam-dailies-find-today :wk "today")
	     "ry" '(org-roam-dailies-find-yesterday :wk "yesterday")
	     "rr" '(org-roam-dailies-find-tomorrow :wk "tomorrow")
	     "rd" '(org-roam-dailies-find-date :wk "date")
	     "rc" '(org-roam-dailies-capture-today :wk "capture today")
	     "rC" '(org-roam-dailies-capture-tomorrow :wk "capture tomorrow")
	     "rD" '(org-roam-dailies-capture-date :wk "capture date")
	     "rl" '(org-roam-buffer-toggle-display :wk "toggle display")
	     "rL" '(org-roam-buffer-display-dedicated :wk "display dedicated")
	     "rs" '(org-roam-db-sync :wk "sync")
	     "rS" '(org-roam-server-mode :wk "server")))
#+end_src
**** Templates
:PROPERTIES:
:header-args: :tangle no :noweb-ref roam-templates
:END:
***** Religious
#+begin_src emacs-lisp
("r" "Templates for religious meditations")
#+end_src
****** Bible
#+begin_src emacs-lisp
("rb" "Bible Study" plain "#+filetags: \"bible study\" \"Book: ${book}\" \"Topic: ${topic}\"\n\n* Topic\n\n* Related\n** Passages\n\n** Meditations\n\n* Personal Meditation\n\n"
 :if-new (file+head "religious/bible-study/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Saint
#+begin_src emacs-lisp
("rs" "Saint" plain "#+filetags: saint \"Saint Type: ${saint type}\" \"Years: ${birth year}-${death year}\" \"Country: ${country}\" \"City: ${city}\"\n\n* Birth\n%?\n\n* Life\n\n\n* Death\n\n\n* Related saints\n\n"
 :if-new (file+head "religious/saints/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
 :unnarrowed t)
#+end_src
****** Lesson
#+begin_src emacs-lisp
("rl" "Lesson" plain "#+filetags: lesson \"Topic: ${topic}\"\n* %?"
 :if-new (file+head "religious/lessons/%<%Y%m%d%H%M%S>-${slug}.org"
		    "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
***** Generic
****** Default
#+begin_src emacs-lisp
("d" "Default" plain "#+filetags: \"${tags}\"\n\n* %?"
 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n")
 :unnarrowed t)
#+end_src
****** Note
#+begin_src emacs-lisp
("n" "Note" plain "#+filetags: note\n\n* %?"
 :if-new (file+head "notes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: note ${field}\n\n")
 :unnarrowed t)
#+end_src

****** Project
#+begin_src emacs-lisp
("p" "Project" plain "#+filetags: project\n\n* %?"
 :if-new (file+head "projects/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n#+tags: project ${field}\n\n")
 :unnarrowed t)
#+end_src
** Babel
#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-confirm-babel-evaluate nil
	org-src-fontify-natively t
	org-src-tab-acts-natively t
	org-src-window-setup 'current-window
	org-src-preserve-indentation t
	org-src-strip-leading-and-trailing-blank-lines t
	org-src-ask-before-returning-to-edit-buffer nil
        org-babel-load-languages '((emacs-lisp . t))
	org-babel-default-header-args '((:session . "default")
					(:results . "replace")
					(:mkdirp . "yes")
					(:exports . "both")
					(:cache . "yes")
					(:noweb . "yes")
					(:hlines . "no")
					(:tangle . "no")
					(:padnewline . "yes")
					(:eval . "never-export")
					(:comments . "link")))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src
** Auto Tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Export
*** =ox-latex=
#+begin_src emacs-lisp
(use-package ox-latex
  :ensure nil
  :config
  (setq org-latex-compiler "xelatex")
  (add-to-list 'org-latex-logfiles-extensions "tex")
  (add-to-list 'org-latex-packages-alist '("" "siunitx"))
  (add-to-list 'org-latex-packages-alist '("" "amsmath"))
  (add-to-list 'org-latex-packages-alist '("" "fancyhdr"))
  (add-to-list 'org-latex-classes
               '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" .    "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("exam"
                 "\\documentclass{exam}"
                 ("\\begin{questions} %% %s"
                  "\\end{questions}"
                  "\\begin{questions} %% %s"
                  "\\end{questions}")
                 ("\\question %s " . "\\question* %s")
		 ("\\begin{parts} %s"
		  "\\end{parts}"
                  "\\begin{parts} %s"
                  "\\end{parts}"))))
#+end_src
*** =ox-html=
#+begin_src emacs-lisp
(use-package ox-html
:ensure nil
:after org)
#+end_src
*** =ox-chameleon=
#+begin_src emacs-lisp
(use-package ox-chameleon
  :ensure nil
  :after org
  :config
  (after! org-msg
	  (setq org-msg-options (concat org-msg-options " html-content-class: chameleon "))))
#+end_src
*** Async patch
#+begin_src emacs-lisp
;; I don't use ~/.emacs which is the default value if default.el was loaded.
(when (and (not noninteractive) (string= user-init-file "~/.emacs")) 
  (after! (org ox default)
	  (setq org-export-async-init-file (make-temp-file "org-export-async-init-file" nil ".el"))
	  (defun my/get-loaded-nix-file (name)
	    (car (load-history-filename-element
		  (concat
		   "^/nix/store/.*emacs-packages-deps/share/emacs/site-lisp/"
		   name
		   "\\.elc?\\(\\.gz\\)?$"))))

	  (with-temp-file org-export-async-init-file
	    (mapc (lambda (s)
		    (insert (format "(load \"%s\")\n" s)))
		  (list
		   (my/get-loaded-nix-file "site-start")
		   (my/get-loaded-nix-file "subdirs")
		   (my/get-loaded-nix-file "default"))))))
#+end_src
*** Syntax Highlighting
#+name: engrave-faces-init
#+begin_src emacs-lisp :tangle no
;;; Definers
(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (ensure-list ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
	 (dolist (target (cdr targets))
	   (advice-add target (car targets) #',symbol))))))
(defvar-local org-export-has-code-p nil)

(defadvice! org-export-expect-no-code (&rest _)
	    :before #'org-export-as
	    (setq org-export-has-code-p nil))

(defadvice! org-export-register-code (&rest _)
	    :after #'org-latex-src-block
	    :after #'org-latex-inline-src-block-engraved
	    (setq org-export-has-code-p t))

(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
	    "Like `org-latex-example-block', but supporting an engraved backend"
	    :around #'org-latex-example-block
	    (let ((output-block (funcall orig-fn example-block contents info)))
	      (if (eq 'engraved (plist-get info :latex-listings))
		  (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
		output-block)))
#+end_src
#+begin_src emacs-lisp
;; both installed by engrave-faces
(use-package engrave-faces-latex
  :ensure engrave-faces
  ;; :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
(use-package engrave-faces-html
  :ensure engrave-faces
  ;; :after org
  :config
  <<engrave-faces-init>>
  (setq org-latex-listings 'engraved))
#+end_src
** Evil Org
#+begin_src emacs-lisp
(use-package evil-org
  :unless noninteractive
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  (add-hook 'evil-org-mode-hook
	    (lambda ()
	      (evil-org-set-key-theme)))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src
** Poly Org
#+begin_src emacs-lisp
(use-package poly-org
  :unless noninteractive
  :commands poly-org-mode
  :after org
  :init
  (my/local-leader-def org-mode
                       "p" '(poly-org-mode :wk "poly-org-mode")))
#+end_src
* Local Variables
# Local Variables:
# org-use-property-inheritance: t
# End:
